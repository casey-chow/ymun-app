{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n/**\n * PollingSubscription keeps a given resource updated by\n * dispatching a fetch at a rate equal to the minimum update\n * interval requested.\n */\n\nvar PollingSubscription =\n/*#__PURE__*/\nfunction () {\n  function PollingSubscription(_ref, dispatch) {\n    var url = _ref.url,\n        schema = _ref.schema,\n        fetch = _ref.fetch,\n        frequency = _ref.frequency;\n\n    _classCallCheck(this, PollingSubscription);\n\n    _defineProperty(this, \"schema\", void 0);\n\n    _defineProperty(this, \"fetch\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"frequency\", void 0);\n\n    _defineProperty(this, \"frequencyHistogram\", new Map());\n\n    _defineProperty(this, \"dispatch\", void 0);\n\n    _defineProperty(this, \"intervalId\", void 0);\n\n    _defineProperty(this, \"lastIntervalId\", void 0);\n\n    if (frequency === undefined) throw new Error('frequency needed for polling subscription');\n    this.schema = schema;\n    this.fetch = fetch;\n    this.frequency = frequency;\n    this.url = url;\n    this.frequencyHistogram.set(this.frequency, 1);\n    this.dispatch = dispatch;\n    this.run();\n  }\n  /** Subscribe to a frequency */\n\n\n  _createClass(PollingSubscription, [{\n    key: \"add\",\n    value: function add(frequency) {\n      if (frequency === undefined) return;\n\n      if (this.frequencyHistogram.has(frequency)) {\n        this.frequencyHistogram.set(frequency, this.frequencyHistogram.get(frequency) + 1);\n      } else {\n        this.frequencyHistogram.set(frequency, 1); // new min so restart service\n\n        if (frequency < this.frequency) {\n          this.frequency = frequency;\n          this.run();\n        }\n      }\n    }\n    /** Unsubscribe from a frequency */\n\n  }, {\n    key: \"remove\",\n    value: function remove(frequency) {\n      if (frequency === undefined) return false;\n\n      if (this.frequencyHistogram.has(frequency)) {\n        this.frequencyHistogram.set(frequency, this.frequencyHistogram.get(frequency) - 1);\n\n        if (this.frequencyHistogram.get(frequency) < 1) {\n          this.frequencyHistogram[\"delete\"](frequency); // nothing subscribed to this anymore...it is invalid\n\n          if (this.frequencyHistogram.size === 0) {\n            this.cleanup();\n            return true;\n          } // this was the min, so find the next size\n\n\n          if (frequency <= this.frequency) {\n            this.frequency = Math.min.apply(Math, _toConsumableArray(this.frequencyHistogram.keys()));\n            this.run();\n          }\n        }\n      } else if (process.env.NODE_ENV !== 'production') {\n        console.error(\"Mismatched remove: \".concat(frequency, \" is not subscribed for \").concat(this.url));\n      }\n\n      return false;\n    }\n    /** Cleanup means clearing out background interval. */\n\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      if (this.intervalId) {\n        clearInterval(this.intervalId);\n        this.intervalId = undefined;\n      }\n\n      if (this.lastIntervalId) {\n        clearInterval(this.lastIntervalId);\n        this.lastIntervalId = undefined;\n      }\n    }\n    /** Trigger request for latest resource */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.dispatch({\n        type: 'rest-hooks/fetch',\n        payload: this.fetch,\n        meta: {\n          schema: this.schema,\n          url: this.url,\n          responseType: 'rest-hooks/receive',\n          throttle: true,\n          options: {\n            dataExpiryLength: this.frequency / 2,\n            errorExpiryLength: this.frequency / 10\n          },\n          resolve: function resolve() {},\n          reject: function reject() {}\n        }\n      });\n    }\n    /** Run polling process with current frequency\n     *\n     * Will clean up old poll interval on next run\n     */\n\n  }, {\n    key: \"run\",\n    value: function run() {\n      var _this = this;\n\n      this.lastIntervalId = this.intervalId;\n      this.intervalId = setInterval(function () {\n        // since we don't know how long into the last poll it was before resetting\n        // we wait til the next fetch to clear old intervals\n        if (_this.lastIntervalId) {\n          clearInterval(_this.lastIntervalId);\n          _this.lastIntervalId = undefined;\n        }\n\n        _this.update();\n      }, this.frequency);\n    }\n  }]);\n\n  return PollingSubscription;\n}();\n\nexport { PollingSubscription as default };","map":{"version":3,"sources":["../../src/state/PollingSubscription.ts"],"names":["PollingSubscription","url","schema","fetch","frequency","Math","process","console","clearInterval","type","payload","meta","responseType","throttle","options","dataExpiryLength","errorExpiryLength","resolve","reject","setInterval"],"mappings":"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","sourcesContent":["import { Schema } from '~/resource';\nimport { Dispatch } from '~/types';\nimport { Subscription, SubscriptionInit } from './SubscriptionManager';\n\n/**\n * PollingSubscription keeps a given resource updated by\n * dispatching a fetch at a rate equal to the minimum update\n * interval requested.\n */\nexport default class PollingSubscription implements Subscription {\n  protected readonly schema: Schema;\n  protected readonly fetch: () => Promise<any>;\n  protected readonly url: string;\n  protected frequency: number;\n  protected frequencyHistogram: Map<number, number> = new Map();\n  protected dispatch: Dispatch<any>;\n  protected intervalId?: NodeJS.Timeout;\n  protected lastIntervalId?: NodeJS.Timeout;\n\n  constructor(\n    { url, schema, fetch, frequency }: SubscriptionInit,\n    dispatch: Dispatch<any>,\n  ) {\n    if (frequency === undefined)\n      throw new Error('frequency needed for polling subscription');\n    this.schema = schema;\n    this.fetch = fetch;\n    this.frequency = frequency;\n    this.url = url;\n    this.frequencyHistogram.set(this.frequency, 1);\n    this.dispatch = dispatch;\n    this.run();\n  }\n\n  /** Subscribe to a frequency */\n  add(frequency?: number) {\n    if (frequency === undefined) return;\n    if (this.frequencyHistogram.has(frequency)) {\n      this.frequencyHistogram.set(\n        frequency,\n        (this.frequencyHistogram.get(frequency) as number) + 1,\n      );\n    } else {\n      this.frequencyHistogram.set(frequency, 1);\n\n      // new min so restart service\n      if (frequency < this.frequency) {\n        this.frequency = frequency;\n        this.run();\n      }\n    }\n  }\n\n  /** Unsubscribe from a frequency */\n  remove(frequency?: number) {\n    if (frequency === undefined) return false;\n    if (this.frequencyHistogram.has(frequency)) {\n      this.frequencyHistogram.set(\n        frequency,\n        (this.frequencyHistogram.get(frequency) as number) - 1,\n      );\n      if ((this.frequencyHistogram.get(frequency) as number) < 1) {\n        this.frequencyHistogram.delete(frequency);\n\n        // nothing subscribed to this anymore...it is invalid\n        if (this.frequencyHistogram.size === 0) {\n          this.cleanup();\n          return true;\n        }\n\n        // this was the min, so find the next size\n        if (frequency <= this.frequency) {\n          this.frequency = Math.min(...this.frequencyHistogram.keys());\n          this.run();\n        }\n      }\n    } else if (process.env.NODE_ENV !== 'production') {\n      console.error(\n        `Mismatched remove: ${frequency} is not subscribed for ${this.url}`,\n      );\n    }\n    return false;\n  }\n\n  /** Cleanup means clearing out background interval. */\n  cleanup() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = undefined;\n    }\n    if (this.lastIntervalId) {\n      clearInterval(this.lastIntervalId);\n      this.lastIntervalId = undefined;\n    }\n  }\n\n  /** Trigger request for latest resource */\n  protected update() {\n    this.dispatch({\n      type: 'rest-hooks/fetch',\n      payload: this.fetch,\n      meta: {\n        schema: this.schema,\n        url: this.url,\n        responseType: 'rest-hooks/receive',\n        throttle: true,\n        options: {\n          dataExpiryLength: this.frequency / 2,\n          errorExpiryLength: this.frequency / 10,\n        },\n        resolve: () => {},\n        reject: () => {},\n      },\n    });\n  }\n\n  /** Run polling process with current frequency\n   *\n   * Will clean up old poll interval on next run\n   */\n  protected run() {\n    this.lastIntervalId = this.intervalId;\n    this.intervalId = setInterval(() => {\n      // since we don't know how long into the last poll it was before resetting\n      // we wait til the next fetch to clear old intervals\n      if (this.lastIntervalId) {\n        clearInterval(this.lastIntervalId);\n        this.lastIntervalId = undefined;\n      }\n      this.update();\n    }, this.frequency);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}