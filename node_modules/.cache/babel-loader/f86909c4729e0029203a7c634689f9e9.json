{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport { useMemo } from 'react';\nimport { isEntity } from \"../../resource/types\";\nimport { denormalize } from \"../../resource\";\nimport buildInferredResultsLegacy from './buildInferredResultsLegacy';\n/**\n * Selects the Denormalize form from `state` cache.\n *\n * If `result` is not found, will attempt to generate it naturally\n * using params and schema. This increases cache hit rate for many\n * detail shapes.\n */\n\nexport default function useDenormalizedLegacy(_ref, params, state) {\n  var schema = _ref.schema,\n      getFetchKey = _ref.getFetchKey; // Select from state\n\n  var entities = state.entities;\n  var cacheResults = params && state.results[getFetchKey(params)]; // We can grab entities without actual results if the params compute a primary key\n\n  var results = useMemo(function () {\n    if (!params) return null;\n    if (cacheResults) return cacheResults; // in case we don't even have entities for a model yet, denormalize() will throw\n    // entities[entitySchema.key] === undefined\n\n    return buildInferredResultsLegacy(schema, params); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [cacheResults, params && getFetchKey(params)]); // The final denormalize block\n\n  return useMemo(function () {\n    if (!entities || !params || !results) return null; // Warn users with bad configurations\n\n    if (process.env.NODE_ENV !== 'production' && isEntity(schema)) {\n      if (Array.isArray(results)) {\n        throw new Error(\"url \".concat(getFetchKey(params), \" has list results when single result is expected\"));\n      }\n\n      if (_typeof(results) === 'object') {\n        throw new Error(\"url \".concat(getFetchKey(params), \" has object results when single result is expected\"));\n      }\n    } // Select the actual results now\n\n\n    var _denormalize = denormalize(results, schema, entities),\n        _denormalize2 = _slicedToArray(_denormalize, 2),\n        denormalized = _denormalize2[0],\n        entitiesFound = _denormalize2[1];\n\n    if (!entitiesFound && !cacheResults) return null;\n    return denormalized; // TODO: would be nice to make this only recompute on the entity types that are in schema\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [entities, params && getFetchKey(params), results]);\n}","map":{"version":3,"sources":["../../../src/state/selectors/useDenormalizedLegacy.ts"],"names":["schema","getFetchKey","entities","state","cacheResults","params","results","useMemo","buildInferredResultsLegacy","process","isEntity","Array","denormalized","entitiesFound","denormalize"],"mappings":";;AAAA,SAAA,OAAA,QAAA,OAAA;AAEA,SAAA,QAAA,QAAA,sBAAA;AACA,SAAA,WAAA,QAAA,gBAAA;AACA,OAAA,0BAAA,MAAA,8BAAA;AAEA;;;;;;;;AAOA,eAAe,SAAA,qBAAA,CAAA,IAAA,EAAA,MAAA,EAAA,KAAA,EAOsB;AAAA,MAHjCA,MAGiC,GAAA,IAAA,CAHjCA,MAGiC;AAAA,MAHzBC,WAGyB,GAAA,IAAA,CAHzBA,WAGyB,CAAA,CACnC;;AACA,MAAMC,QAAQ,GAAGC,KAAK,CAAtB,QAAA;AACA,MAAMC,YAAY,GAAGC,MAAM,IAAKF,KAAK,CAALA,OAAAA,CAAcF,WAAW,CAHtB,MAGsB,CAAzBE,CAAhC,CAHmC,CAKnC;;AACA,MAAMG,OAAO,GAAGC,OAAO,CAAC,YAAM;AAC5B,QAAI,CAAJ,MAAA,EAAa,OAAA,IAAA;AACb,QAAA,YAAA,EAAkB,OAFU,YAEV,CAFU,CAI5B;AACA;;AACA,WAAOC,0BAA0B,CAAA,MAAA,EANL,MAMK,CAAjC,CAN4B,CAO5B;AAPqB,GAAA,EAQpB,CAAA,YAAA,EAAeH,MAAM,IAAIJ,WAAW,CAdJ,MAcI,CAApC,CARoB,CAAvB,CANmC,CAgBnC;;AACA,SAAOM,OAAO,CAAC,YAAM;AACnB,QAAI,CAAA,QAAA,IAAa,CAAb,MAAA,IAAwB,CAA5B,OAAA,EAAsC,OADnB,IACmB,CADnB,CAGnB;;AACA,QAAIE,OAAO,CAAPA,GAAAA,CAAAA,QAAAA,KAAAA,YAAAA,IAAyCC,QAAQ,CAArD,MAAqD,CAArD,EAA+D;AAC7D,UAAIC,KAAK,CAALA,OAAAA,CAAJ,OAAIA,CAAJ,EAA4B;AAC1B,cAAM,IAAA,KAAA,CAAA,OAAA,MAAA,CACGV,WAAW,CADd,MACc,CADd,EAAN,kDAAM,CAAA,CAAN;AAKD;;AACD,UAAI,OAAA,CAAA,OAAA,CAAA,KAAJ,QAAA,EAAiC;AAC/B,cAAM,IAAA,KAAA,CAAA,OAAA,MAAA,CACGA,WAAW,CADd,MACc,CADd,EAAN,oDAAM,CAAA,CAAN;AAKD;AAlBgB,KAAA,CAqBnB;;;AArBmB,QAAA,YAAA,GAsBmBa,WAAW,CAAA,OAAA,EAAA,MAAA,EAtB9B,QAsB8B,CAtB9B;AAAA,QAAA,aAAA,GAAA,cAAA,CAAA,YAAA,EAAA,CAAA,CAAA;AAAA,QAsBZF,YAtBY,GAAA,aAAA,CAAA,CAAA,CAAA;AAAA,QAsBEC,aAtBF,GAAA,aAAA,CAAA,CAAA,CAAA;;AA2BnB,QAAI,CAAA,aAAA,IAAkB,CAAtB,YAAA,EAAqC,OAAA,IAAA;AACrC,WA5BmB,YA4BnB,CA5BmB,CA6BnB;AACA;AA9BY,GAAA,EA+BX,CAAA,QAAA,EAAWR,MAAM,IAAIJ,WAAW,CAAhC,MAAgC,CAAhC,EA/BH,OA+BG,CA/BW,CAAd;AAgCD","sourcesContent":["import { useMemo } from 'react';\nimport { State } from '~/types';\nimport { isEntity, ReadShape } from '~/resource/types';\nimport { Schema, denormalize, Normalize, Denormalize } from '~/resource';\nimport buildInferredResultsLegacy from './buildInferredResultsLegacy';\n\n/**\n * Selects the Denormalize form from `state` cache.\n *\n * If `result` is not found, will attempt to generate it naturally\n * using params and schema. This increases cache hit rate for many\n * detail shapes.\n */\nexport default function useDenormalizedLegacy<\n  Params extends Readonly<object>,\n  S extends Schema\n>(\n  { schema, getFetchKey }: Pick<ReadShape<S, Params>, 'schema' | 'getFetchKey'>,\n  params: Params | null,\n  state: State<any>,\n): Denormalize<typeof schema> | null {\n  // Select from state\n  const entities = state.entities;\n  const cacheResults = params && (state.results[getFetchKey(params)] as any);\n\n  // We can grab entities without actual results if the params compute a primary key\n  const results = useMemo(() => {\n    if (!params) return null;\n    if (cacheResults) return cacheResults;\n\n    // in case we don't even have entities for a model yet, denormalize() will throw\n    // entities[entitySchema.key] === undefined\n    return buildInferredResultsLegacy(schema, params);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [cacheResults, params && getFetchKey(params)]);\n\n  // The final denormalize block\n  return useMemo(() => {\n    if (!entities || !params || !results) return null;\n\n    // Warn users with bad configurations\n    if (process.env.NODE_ENV !== 'production' && isEntity(schema)) {\n      if (Array.isArray(results)) {\n        throw new Error(\n          `url ${getFetchKey(\n            params,\n          )} has list results when single result is expected`,\n        );\n      }\n      if (typeof results === 'object') {\n        throw new Error(\n          `url ${getFetchKey(\n            params,\n          )} has object results when single result is expected`,\n        );\n      }\n    }\n\n    // Select the actual results now\n    const [denormalized, entitiesFound] = denormalize(\n      results,\n      schema,\n      entities,\n    );\n    if (!entitiesFound && !cacheResults) return null;\n    return denormalized as any;\n    // TODO: would be nice to make this only recompute on the entity types that are in schema\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [entities, params && getFetchKey(params), results]);\n}\n"]},"metadata":{},"sourceType":"module"}