{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _memoize from \"lodash/memoize\";\n/** Handles subscription actions -> fetch or receive actions\n *\n * Constructor takes a SubscriptionConstructable class to control how\n * subscriptions are handled. (e.g., polling, websockets)\n */\n\nvar SubscriptionManager =\n/*#__PURE__*/\nfunction () {\n  function SubscriptionManager(Subscription) {\n    _classCallCheck(this, SubscriptionManager);\n\n    _defineProperty(this, \"subscriptions\", {});\n\n    _defineProperty(this, \"Subscription\", void 0);\n\n    this.Subscription = Subscription;\n    this.getMiddleware = _memoize(this.getMiddleware);\n  }\n  /** Ensures all subscriptions are cleaned up. */\n\n\n  _createClass(SubscriptionManager, [{\n    key: \"cleanup\",\n    value: function cleanup() {\n      for (var _url in this.subscriptions) {\n        this.subscriptions[_url].cleanup();\n      }\n    }\n    /** Called when middleware intercepts 'rest-hooks/subscribe' action.\n     *\n     */\n\n  }, {\n    key: \"handleSubscribe\",\n    value: function handleSubscribe(action, dispatch) {\n      var url = action.meta.url;\n\n      if (url in this.subscriptions) {\n        this.subscriptions[url].add(action.meta.frequency);\n      } else {\n        this.subscriptions[url] = new this.Subscription({\n          schema: action.meta.schema,\n          fetch: action.meta.fetch,\n          frequency: action.meta.frequency,\n          url: url\n        }, dispatch);\n      }\n    }\n    /** Called when middleware intercepts 'rest-hooks/unsubscribe' action.\n     *\n     */\n\n  }, {\n    key: \"handleUnsubscribe\",\n    value: function handleUnsubscribe(action, dispatch) {\n      var url = action.meta.url;\n\n      if (url in this.subscriptions) {\n        var empty = this.subscriptions[url].remove(action.meta.frequency);\n\n        if (empty) {\n          delete this.subscriptions[url];\n        }\n      } else if (process.env.NODE_ENV !== 'production') {\n        console.error(\"Mismatched unsubscribe: \".concat(url, \" is not subscribed\"));\n      }\n    }\n    /** Attaches Manager to store\n     *\n     * Intercepts 'rest-hooks/subscribe'/'rest-hooks/unsubscribe' to register resources that\n     * need to be kept up to date.\n     *\n     * Will possibly dispatch 'rest-hooks/fetch' or 'rest-hooks/receive' to keep resources fresh\n     *\n     */\n\n  }, {\n    key: \"getMiddleware\",\n    value: function getMiddleware() {\n      var _this = this;\n\n      return function (_ref) {\n        var dispatch = _ref.dispatch;\n        return function (next) {\n          return function (action) {\n            switch (action.type) {\n              case 'rest-hooks/subscribe':\n                _this.handleSubscribe(action, dispatch);\n\n                return Promise.resolve();\n\n              case 'rest-hooks/unsubscribe':\n                _this.handleUnsubscribe(action, dispatch);\n\n                return Promise.resolve();\n\n              default:\n                return next(action);\n            }\n          };\n        };\n      };\n    }\n  }]);\n\n  return SubscriptionManager;\n}();\n\nexport { SubscriptionManager as default };","map":{"version":3,"sources":["../../src/state/SubscriptionManager.ts"],"names":["SubscriptionManager","action","dispatch","url","schema","fetch","frequency","empty","process","console","Promise","next"],"mappings":";;;;AAgCA;;;;;;IAKqBA,mB;;;AAOnB,WAAA,mBAAA,CAAA,YAAA,EAA6B;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,mBAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,eAAA,EAHzB,EAGyB,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,cAAA,EAAA,KAAA,CAAA,CAAA;;AAC3B,SAAA,YAAA,GAAA,YAAA;AACA,SAAA,aAAA,GAAqB,QAAA,CAAQ,KAA7B,aAAqB,CAArB;AACD;AAED;;;;;8BACU;AACR,WAAK,IAAL,IAAA,IAAkB,KAAlB,aAAA,EAAsC;AACpC,aAAA,aAAA,CAAA,IAAA,EAAA,OAAA;AACD;AACF;AAED;;;;;;oCAG0BC,M,EAAyBC,Q,EAAyB;AAC1E,UAAMC,GAAG,GAAGF,MAAM,CAANA,IAAAA,CAAZ,GAAA;;AACA,UAAIE,GAAG,IAAI,KAAX,aAAA,EAA+B;AAC7B,aAAA,aAAA,CAAA,GAAA,EAAA,GAAA,CAA4BF,MAAM,CAANA,IAAAA,CAA5B,SAAA;AADF,OAAA,MAEO;AACL,aAAA,aAAA,CAAA,GAAA,IAA0B,IAAI,KAAJ,YAAA,CACxB;AACEG,UAAAA,MAAM,EAAEH,MAAM,CAANA,IAAAA,CADV,MAAA;AAEEI,UAAAA,KAAK,EAAEJ,MAAM,CAANA,IAAAA,CAFT,KAAA;AAGEK,UAAAA,SAAS,EAAEL,MAAM,CAANA,IAAAA,CAHb,SAAA;AAIEE,UAAAA,GAAG,EAAHA;AAJF,SADwB,EAA1B,QAA0B,CAA1B;AASD;AACF;AAED;;;;;;sCAIEF,M,EACAC,Q,EACA;AACA,UAAMC,GAAG,GAAGF,MAAM,CAANA,IAAAA,CAAZ,GAAA;;AACA,UAAIE,GAAG,IAAI,KAAX,aAAA,EAA+B;AAC7B,YAAMI,KAAK,GAAG,KAAA,aAAA,CAAA,GAAA,EAAA,MAAA,CAA+BN,MAAM,CAANA,IAAAA,CAA7C,SAAc,CAAd;;AACA,YAAA,KAAA,EAAW;AACT,iBAAO,KAAA,aAAA,CAAP,GAAO,CAAP;AACD;AAJH,OAAA,MAKO,IAAIO,OAAO,CAAPA,GAAAA,CAAAA,QAAAA,KAAJ,YAAA,EAA2C;AAChDC,QAAAA,OAAO,CAAPA,KAAAA,CAAAA,2BAAAA,MAAAA,CAAAA,GAAAA,EAAAA,oBAAAA,CAAAA;AACD;AACF;AAED;;;;;;;;;;;oCAQyD;AAAA,UAAA,KAAA,GAAA,IAAA;;AACvD,aAAO,UAAA,IAAA,EAEiB;AAAA,YADtBP,QACsB,GAAA,IAAA,CADtBA,QACsB;AACtB,eAAO,UAAA,IAAA,EAAA;AAAA,iBAAuB,UAAA,MAAA,EAAqB;AACjD,oBAAQD,MAAM,CAAd,IAAA;AACE,mBAAA,sBAAA;AACE,gBAAA,KAAI,CAAJ,eAAA,CAAA,MAAA,EAAA,QAAA;;AACA,uBAAOS,OAAO,CAAd,OAAOA,EAAP;;AACF,mBAAA,wBAAA;AACE,gBAAA,KAAI,CAAJ,iBAAA,CAAA,MAAA,EAAA,QAAA;;AACA,uBAAOA,OAAO,CAAd,OAAOA,EAAP;;AACF;AACE,uBAAOC,IAAI,CAAX,MAAW,CAAX;AARJ;AADK,WAAA;AAAP,SAAA;AAHF,OAAA;AAgBD;;;;;;SAlFkBX,mB","sourcesContent":["import { memoize } from 'lodash';\nimport {\n  MiddlewareAPI,\n  SubscribeAction,\n  UnsubscribeAction,\n  Manager,\n  Dispatch,\n} from '~/types';\nimport { Schema } from '~/resource';\n\ntype Actions = UnsubscribeAction | SubscribeAction;\n\n/** Properties sent to Subscription constructor */\nexport interface SubscriptionInit {\n  schema: Schema;\n  fetch: () => Promise<any>;\n  url: string;\n  frequency?: number;\n}\n\n/** Interface handling a single resource subscription */\nexport interface Subscription {\n  add(frequency?: number): void;\n  remove(frequency?: number): boolean;\n  cleanup(): void;\n}\n\n/** The static class that constructs Subscription */\nexport interface SubscriptionConstructable {\n  new (init: SubscriptionInit, dispatch: Dispatch<any>): Subscription;\n}\n\n/** Handles subscription actions -> fetch or receive actions\n *\n * Constructor takes a SubscriptionConstructable class to control how\n * subscriptions are handled. (e.g., polling, websockets)\n */\nexport default class SubscriptionManager<S extends SubscriptionConstructable>\n  implements Manager {\n  protected subscriptions: {\n    [url: string]: InstanceType<S>;\n  } = {};\n  protected readonly Subscription: S;\n\n  constructor(Subscription: S) {\n    this.Subscription = Subscription;\n    this.getMiddleware = memoize(this.getMiddleware);\n  }\n\n  /** Ensures all subscriptions are cleaned up. */\n  cleanup() {\n    for (const url in this.subscriptions) {\n      this.subscriptions[url].cleanup();\n    }\n  }\n\n  /** Called when middleware intercepts 'rest-hooks/subscribe' action.\n   *\n   */\n  protected handleSubscribe(action: SubscribeAction, dispatch: Dispatch<any>) {\n    const url = action.meta.url;\n    if (url in this.subscriptions) {\n      this.subscriptions[url].add(action.meta.frequency);\n    } else {\n      this.subscriptions[url] = new this.Subscription(\n        {\n          schema: action.meta.schema,\n          fetch: action.meta.fetch,\n          frequency: action.meta.frequency,\n          url,\n        },\n        dispatch,\n      ) as InstanceType<S>;\n    }\n  }\n\n  /** Called when middleware intercepts 'rest-hooks/unsubscribe' action.\n   *\n   */\n  protected handleUnsubscribe(\n    action: UnsubscribeAction,\n    dispatch: Dispatch<any>,\n  ) {\n    const url = action.meta.url;\n    if (url in this.subscriptions) {\n      const empty = this.subscriptions[url].remove(action.meta.frequency);\n      if (empty) {\n        delete this.subscriptions[url];\n      }\n    } else if (process.env.NODE_ENV !== 'production') {\n      console.error(`Mismatched unsubscribe: ${url} is not subscribed`);\n    }\n  }\n\n  /** Attaches Manager to store\n   *\n   * Intercepts 'rest-hooks/subscribe'/'rest-hooks/unsubscribe' to register resources that\n   * need to be kept up to date.\n   *\n   * Will possibly dispatch 'rest-hooks/fetch' or 'rest-hooks/receive' to keep resources fresh\n   *\n   */\n  getMiddleware<T extends SubscriptionManager<S>>(this: T) {\n    return <R extends React.Reducer<any, A>, A extends Actions>({\n      dispatch,\n    }: MiddlewareAPI<R>) => {\n      return (next: Dispatch<R>) => (action: Actions) => {\n        switch (action.type) {\n          case 'rest-hooks/subscribe':\n            this.handleSubscribe(action, dispatch);\n            return Promise.resolve();\n          case 'rest-hooks/unsubscribe':\n            this.handleUnsubscribe(action, dispatch);\n            return Promise.resolve();\n          default:\n            return next(action);\n        }\n      };\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}