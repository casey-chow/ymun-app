{"ast":null,"code":"import _possibleConstructorReturn from \"/Users/juliablair/Desktop/christemp/ymun-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/juliablair/Desktop/christemp/ymun-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/juliablair/Desktop/christemp/ymun-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _defineProperty from \"/Users/juliablair/Desktop/christemp/ymun-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/Users/juliablair/Desktop/christemp/ymun-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/juliablair/Desktop/christemp/ymun-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"/Users/juliablair/Desktop/christemp/ymun-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * Helpers to enable Immutable compatibility *without* bringing in\n * the 'immutable' package as a dependency.\n */\n\n/**\n * Check if an object is immutable by checking if it has a key specific\n * to the immutable library.\n *\n * @param  {any} object\n * @return {bool}\n */\nfunction isImmutable(object) {\n  return !!(object && typeof object.hasOwnProperty === 'function' && (object.hasOwnProperty('__ownerID') || // Immutable.Map\n  object._map && object._map.hasOwnProperty('__ownerID'))); // Immutable.Record\n}\n/**\n * Denormalize an immutable entity.\n *\n * @param  {Schema} schema\n * @param  {Immutable.Map|Immutable.Record} input\n * @param  {function} unvisit\n * @param  {function} getDenormalizedEntity\n * @return {Immutable.Map|Immutable.Record}\n */\n\n\nfunction denormalizeImmutable(schema, input, unvisit) {\n  var found = true;\n  return [Object.keys(schema).reduce(function (object, key) {\n    // Immutable maps cast keys to strings on write so we need to ensure\n    // we're accessing them using string keys.\n    var stringKey = \"\" + key;\n\n    var _unvisit = unvisit(object.get(stringKey), schema[stringKey]),\n        _unvisit2 = _slicedToArray(_unvisit, 2),\n        item = _unvisit2[0],\n        foundItem = _unvisit2[1];\n\n    if (!foundItem) {\n      found = false;\n    }\n\n    if (object.has(stringKey)) {\n      return object.set(stringKey, item);\n    } else {\n      return object;\n    }\n  }, input), found];\n}\n\nvar getDefaultGetId = function getDefaultGetId(idAttribute) {\n  return function (input) {\n    return isImmutable(input) ? input.get(idAttribute) : input[idAttribute];\n  };\n};\n\nvar EntitySchema =\n/*#__PURE__*/\nfunction () {\n  function EntitySchema(key) {\n    var definition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, EntitySchema);\n\n    if (!key || typeof key !== 'string') {\n      throw new Error(\"Expected a string key for Entity, but found \" + key + \".\");\n    }\n\n    var _options$idAttribute = options.idAttribute,\n        idAttribute = _options$idAttribute === void 0 ? 'id' : _options$idAttribute,\n        _options$mergeStrateg = options.mergeStrategy,\n        mergeStrategy = _options$mergeStrateg === void 0 ? function (entityA, entityB) {\n      return Object.assign({}, entityA, {}, entityB);\n    } : _options$mergeStrateg,\n        _options$processStrat = options.processStrategy,\n        processStrategy = _options$processStrat === void 0 ? function (input) {\n      return Object.assign({}, input);\n    } : _options$processStrat;\n    this._key = key;\n    this._getId = typeof idAttribute === 'function' ? idAttribute : getDefaultGetId(idAttribute);\n    this._idAttribute = idAttribute;\n    this._mergeStrategy = mergeStrategy;\n    this._processStrategy = processStrategy;\n    this.define(definition);\n  }\n\n  _createClass(EntitySchema, [{\n    key: \"define\",\n    value: function define(definition) {\n      this.schema = Object.keys(definition).reduce(function (entitySchema, key) {\n        var schema = definition[key];\n        return Object.assign({}, entitySchema, _defineProperty({}, key, schema));\n      }, this.schema || {});\n    }\n  }, {\n    key: \"getId\",\n    value: function getId(input, parent, key) {\n      return this._getId(input, parent, key);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(entityA, entityB) {\n      return this._mergeStrategy(entityA, entityB);\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize(input, parent, key, visit, addEntity, visitedEntities) {\n      var _this = this;\n\n      var id = this.getId(input, parent, key);\n      var entityType = this.key;\n\n      if (!(entityType in visitedEntities)) {\n        visitedEntities[entityType] = {};\n      }\n\n      if (!(id in visitedEntities[entityType])) {\n        visitedEntities[entityType][id] = [];\n      }\n\n      if (visitedEntities[entityType][id].some(function (entity) {\n        return entity === input;\n      })) {\n        return id;\n      }\n\n      visitedEntities[entityType][id].push(input);\n\n      var processedEntity = this._processStrategy(input, parent, key);\n\n      Object.keys(this.schema).forEach(function (key) {\n        if (processedEntity.hasOwnProperty(key) && typeof processedEntity[key] === 'object') {\n          var _schema = _this.schema[key];\n          processedEntity[key] = visit(processedEntity[key], processedEntity, key, _schema, addEntity, visitedEntities);\n        }\n      });\n      addEntity(this, processedEntity, input, parent, key);\n      return id;\n    }\n  }, {\n    key: \"denormalize\",\n    value: function denormalize(entity, unvisit) {\n      var _this2 = this;\n\n      if (isImmutable(entity)) {\n        return denormalizeImmutable(this.schema, entity, unvisit);\n      }\n\n      var found = true;\n      Object.keys(this.schema).forEach(function (key) {\n        var schema = _this2.schema[key];\n\n        var _unvisit3 = unvisit(entity[key], schema),\n            _unvisit4 = _slicedToArray(_unvisit3, 2),\n            value = _unvisit4[0],\n            foundItem = _unvisit4[1];\n\n        if (!foundItem) {\n          found = false;\n        }\n\n        if (entity.hasOwnProperty(key)) {\n          entity[key] = value;\n        }\n      });\n      return [entity, found];\n    }\n  }, {\n    key: \"key\",\n    get: function get() {\n      return this._key;\n    }\n  }, {\n    key: \"idAttribute\",\n    get: function get() {\n      return this._idAttribute;\n    }\n  }]);\n\n  return EntitySchema;\n}();\n\nvar PolymorphicSchema =\n/*#__PURE__*/\nfunction () {\n  function PolymorphicSchema(definition, schemaAttribute) {\n    _classCallCheck(this, PolymorphicSchema);\n\n    if (schemaAttribute) {\n      this._schemaAttribute = typeof schemaAttribute === 'string' ? function (input) {\n        return input[schemaAttribute];\n      } : schemaAttribute;\n    }\n\n    this.define(definition);\n  }\n\n  _createClass(PolymorphicSchema, [{\n    key: \"define\",\n    value: function define(definition) {\n      this.schema = definition;\n    }\n  }, {\n    key: \"getSchemaAttribute\",\n    value: function getSchemaAttribute(input, parent, key) {\n      return !this.isSingleSchema && this._schemaAttribute(input, parent, key);\n    }\n  }, {\n    key: \"inferSchema\",\n    value: function inferSchema(input, parent, key) {\n      if (this.isSingleSchema) {\n        return this.schema;\n      }\n\n      var attr = this.getSchemaAttribute(input, parent, key);\n      return this.schema[attr];\n    }\n  }, {\n    key: \"normalizeValue\",\n    value: function normalizeValue(value, parent, key, visit, addEntity, visitedEntities) {\n      var schema = this.inferSchema(value, parent, key);\n\n      if (!schema) {\n        return value;\n      }\n\n      var normalizedValue = visit(value, parent, key, schema, addEntity, visitedEntities);\n      return this.isSingleSchema || normalizedValue === undefined || normalizedValue === null ? normalizedValue : {\n        id: normalizedValue,\n        schema: this.getSchemaAttribute(value, parent, key)\n      };\n    }\n  }, {\n    key: \"denormalizeValue\",\n    value: function denormalizeValue(value, unvisit) {\n      var schemaKey = isImmutable(value) ? value.get('schema') : value.schema;\n\n      if (!this.isSingleSchema && !schemaKey) {\n        return [value, true];\n      }\n\n      var id = isImmutable(value) ? value.get('id') : value.id;\n      var schema = this.isSingleSchema ? this.schema : this.schema[schemaKey];\n      return unvisit(id || value, schema);\n    }\n  }, {\n    key: \"isSingleSchema\",\n    get: function get() {\n      return !this._schemaAttribute;\n    }\n  }]);\n\n  return PolymorphicSchema;\n}();\n\nvar UnionSchema =\n/*#__PURE__*/\nfunction (_PolymorphicSchema) {\n  _inherits(UnionSchema, _PolymorphicSchema);\n\n  function UnionSchema(definition, schemaAttribute) {\n    _classCallCheck(this, UnionSchema);\n\n    if (!schemaAttribute) {\n      throw new Error('Expected option \"schemaAttribute\" not found on UnionSchema.');\n    }\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UnionSchema).call(this, definition, schemaAttribute));\n  }\n\n  _createClass(UnionSchema, [{\n    key: \"normalize\",\n    value: function normalize(input, parent, key, visit, addEntity, visitedEntities) {\n      return this.normalizeValue(input, parent, key, visit, addEntity, visitedEntities);\n    }\n  }, {\n    key: \"denormalize\",\n    value: function denormalize(input, unvisit) {\n      return this.denormalizeValue(input, unvisit);\n    }\n  }]);\n\n  return UnionSchema;\n}(PolymorphicSchema);\n\nvar ValuesSchema =\n/*#__PURE__*/\nfunction (_PolymorphicSchema2) {\n  _inherits(ValuesSchema, _PolymorphicSchema2);\n\n  function ValuesSchema() {\n    _classCallCheck(this, ValuesSchema);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ValuesSchema).apply(this, arguments));\n  }\n\n  _createClass(ValuesSchema, [{\n    key: \"normalize\",\n    value: function normalize(input, parent, key, visit, addEntity, visitedEntities) {\n      var _this3 = this;\n\n      return Object.keys(input).reduce(function (output, key, index) {\n        var value = input[key];\n        return value !== undefined && value !== null ? Object.assign({}, output, _defineProperty({}, key, _this3.normalizeValue(value, input, key, visit, addEntity, visitedEntities))) : output;\n      }, {});\n    }\n  }, {\n    key: \"denormalize\",\n    value: function denormalize(input, unvisit) {\n      var _this4 = this;\n\n      var found = true;\n      return [Object.keys(input).reduce(function (output, key) {\n        var entityOrId = input[key];\n\n        var _this4$denormalizeVal = _this4.denormalizeValue(entityOrId, unvisit),\n            _this4$denormalizeVal2 = _slicedToArray(_this4$denormalizeVal, 2),\n            value = _this4$denormalizeVal2[0],\n            foundItem = _this4$denormalizeVal2[1];\n\n        if (!foundItem) {\n          found = false;\n        }\n\n        return Object.assign({}, output, _defineProperty({}, key, value));\n      }, {}), found];\n    }\n  }]);\n\n  return ValuesSchema;\n}(PolymorphicSchema);\n\nvar validateSchema = function validateSchema(definition) {\n  var isArray = Array.isArray(definition);\n\n  if (isArray && definition.length > 1) {\n    throw new Error(\"Expected schema definition to be a single schema, but found \" + definition.length + \".\");\n  }\n\n  return definition[0];\n};\n\nvar getValues = function getValues(input) {\n  return Array.isArray(input) ? input : Object.keys(input).map(function (key) {\n    return input[key];\n  });\n};\n\nvar normalize = function normalize(schema, input, parent, key, visit, addEntity, visitedEntities) {\n  schema = validateSchema(schema);\n  var values = getValues(input); // Special case: Arrays pass *their* parent on to their children, since there\n  // is not any special information that can be gathered from themselves directly\n\n  return values.map(function (value, index) {\n    return visit(value, parent, key, schema, addEntity, visitedEntities);\n  });\n};\n\nvar denormalize = function denormalize(schema, input, unvisit) {\n  schema = validateSchema(schema);\n  var found = true;\n\n  if (input === undefined && schema) {\n    var _unvisit5 = unvisit(undefined, schema);\n\n    var _unvisit6 = _slicedToArray(_unvisit5, 2);\n\n    found = _unvisit6[1];\n  }\n\n  return [input && input.map ? input.map(function (entityOrId) {\n    return unvisit(entityOrId, schema);\n  }).filter(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        foundItem = _ref2[1];\n\n    return foundItem;\n  }).map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 1),\n        value = _ref4[0];\n\n    return value;\n  }) : input, found];\n};\n\nvar ArraySchema =\n/*#__PURE__*/\nfunction (_PolymorphicSchema3) {\n  _inherits(ArraySchema, _PolymorphicSchema3);\n\n  function ArraySchema() {\n    _classCallCheck(this, ArraySchema);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ArraySchema).apply(this, arguments));\n  }\n\n  _createClass(ArraySchema, [{\n    key: \"normalize\",\n    value: function normalize(input, parent, key, visit, addEntity, visitedEntities) {\n      var _this5 = this;\n\n      var values = getValues(input);\n      return values.map(function (value, index) {\n        return _this5.normalizeValue(value, parent, key, visit, addEntity, visitedEntities);\n      }).filter(function (value) {\n        return value !== undefined && value !== null;\n      });\n    }\n  }, {\n    key: \"denormalize\",\n    value: function denormalize(input, unvisit) {\n      var _this6 = this;\n\n      var found = true;\n\n      if (input === undefined && this.schema) {\n        var _unvisit7 = unvisit(undefined, this.schema);\n\n        var _unvisit8 = _slicedToArray(_unvisit7, 2);\n\n        found = _unvisit8[1];\n      }\n\n      return [input && input.map ? input.map(function (entityOrId) {\n        return _this6.denormalizeValue(entityOrId, unvisit);\n      }).filter(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            foundItem = _ref6[1];\n\n        return foundItem;\n      }).map(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 1),\n            value = _ref8[0];\n\n        return value;\n      }) : input, found];\n    }\n  }]);\n\n  return ArraySchema;\n}(PolymorphicSchema);\n\nvar normalize$1 = function normalize$1(schema, input, parent, key, visit, addEntity, visitedEntities) {\n  var object = Object.assign({}, input);\n  Object.keys(schema).forEach(function (key) {\n    var localSchema = schema[key];\n    var value = visit(input[key], input, key, localSchema, addEntity, visitedEntities);\n\n    if (value === undefined || value === null) {\n      delete object[key];\n    } else {\n      object[key] = value;\n    }\n  });\n  return object;\n};\n\nvar denormalize$1 = function denormalize$1(schema, input, unvisit) {\n  if (isImmutable(input)) {\n    return denormalizeImmutable(schema, input, unvisit);\n  }\n\n  var object = Object.assign({}, input);\n  var found = true;\n  Object.keys(schema).forEach(function (key) {\n    var _unvisit9 = unvisit(object[key], schema[key]),\n        _unvisit10 = _slicedToArray(_unvisit9, 2),\n        item = _unvisit10[0],\n        foundItem = _unvisit10[1];\n\n    if (object[key] != null) {\n      object[key] = item;\n    }\n\n    if (!foundItem) {\n      found = false;\n    }\n  });\n  return [object, found];\n};\n\nvar ObjectSchema =\n/*#__PURE__*/\nfunction () {\n  function ObjectSchema(definition) {\n    _classCallCheck(this, ObjectSchema);\n\n    this.define(definition);\n  }\n\n  _createClass(ObjectSchema, [{\n    key: \"define\",\n    value: function define(definition) {\n      this.schema = Object.keys(definition).reduce(function (entitySchema, key) {\n        var schema = definition[key];\n        return Object.assign({}, entitySchema, _defineProperty({}, key, schema));\n      }, this.schema || {});\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return normalize$1.apply(void 0, [this.schema].concat(args));\n    }\n  }, {\n    key: \"denormalize\",\n    value: function denormalize() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return denormalize$1.apply(void 0, [this.schema].concat(args));\n    }\n  }]);\n\n  return ObjectSchema;\n}();\n\nvar visit = function visit(value, parent, key, schema, addEntity, visitedEntities) {\n  if (typeof value !== 'object' || !value) {\n    return value;\n  }\n\n  if (typeof schema === 'object' && (!schema.normalize || typeof schema.normalize !== 'function')) {\n    var method = Array.isArray(schema) ? normalize : normalize$1;\n    return method(schema, value, parent, key, visit, addEntity, visitedEntities);\n  }\n\n  return schema.normalize(value, parent, key, visit, addEntity, visitedEntities);\n};\n\nvar addEntities = function addEntities(entities) {\n  return function (schema, processedEntity, value, parent, key) {\n    var schemaKey = schema.key;\n    var id = schema.getId(value, parent, key);\n\n    if (!(schemaKey in entities)) {\n      entities[schemaKey] = {};\n    }\n\n    var existingEntity = entities[schemaKey][id];\n\n    if (existingEntity) {\n      entities[schemaKey][id] = schema.merge(existingEntity, processedEntity);\n    } else {\n      entities[schemaKey][id] = processedEntity;\n    }\n  };\n};\n\nvar schema = {\n  Array: ArraySchema,\n  Entity: EntitySchema,\n  Object: ObjectSchema,\n  Union: UnionSchema,\n  Values: ValuesSchema\n};\n\nvar normalize$2 = function normalize$2(input, schema) {\n  if (!input || typeof input !== 'object') {\n    throw new Error(\"Unexpected input given to normalize. Expected type to be \\\"object\\\", found \\\"\" + (input === null ? 'null' : typeof input) + \"\\\".\");\n  }\n\n  var entities = {};\n  var addEntity = addEntities(entities);\n  var visitedEntities = {};\n  var result = visit(input, input, null, schema, addEntity, visitedEntities);\n  return {\n    entities: entities,\n    result: result\n  };\n};\n\nvar unvisitEntity = function unvisitEntity(id, schema, unvisit, getEntity, cache) {\n  var entity = getEntity(id, schema);\n\n  if (typeof entity !== 'object' || entity === null) {\n    return [entity, false];\n  }\n\n  if (!cache[schema.key]) {\n    cache[schema.key] = {};\n  }\n\n  var found = true;\n\n  if (!cache[schema.key][id]) {\n    // Ensure we don't mutate it non-immutable objects\n    var entityCopy = isImmutable(entity) ? entity : Object.assign({}, entity); // Need to set this first so that if it is referenced further within the\n    // denormalization the reference will already exist.\n\n    cache[schema.key][id] = entityCopy;\n\n    var _schema$denormalize = schema.denormalize(entityCopy, unvisit);\n\n    var _schema$denormalize2 = _slicedToArray(_schema$denormalize, 2);\n\n    cache[schema.key][id] = _schema$denormalize2[0];\n    found = _schema$denormalize2[1];\n  }\n\n  return [cache[schema.key][id], found];\n};\n\nvar getUnvisit = function getUnvisit(entities) {\n  var cache = {};\n  var getEntity = getEntities(entities);\n  return function unvisit(input, schema) {\n    if (typeof schema === 'object' && (!schema.denormalize || typeof schema.denormalize !== 'function')) {\n      var method = Array.isArray(schema) ? denormalize : denormalize$1;\n      return method(schema, input, unvisit);\n    } // null is considered intentional, thus always 'found' as true\n\n\n    if (input === null) {\n      return [input, true];\n    }\n\n    if (schema instanceof EntitySchema) {\n      // unvisitEntity just can't handle undefined\n      if (input === undefined) {\n        return [input, false];\n      }\n\n      return unvisitEntity(input, schema, unvisit, getEntity, cache);\n    }\n\n    if (typeof schema.denormalize === 'function') {\n      return schema.denormalize(input, unvisit);\n    }\n\n    return [input, true];\n  };\n};\n\nvar getEntities = function getEntities(entities) {\n  var isImmutable$1 = isImmutable(entities);\n  return function (entityOrId, schema) {\n    var schemaKey = schema.key;\n\n    if (typeof entityOrId === 'object') {\n      return entityOrId;\n    }\n\n    if (isImmutable$1) {\n      return entities.getIn([schemaKey, entityOrId.toString()]);\n    }\n\n    return entities[schemaKey] && entities[schemaKey][entityOrId];\n  };\n};\n\nvar denormalize$2 = function denormalize$2(input, schema, entities) {\n  if (typeof input !== 'undefined') {\n    return getUnvisit(entities)(input, schema);\n  }\n\n  return [undefined, false];\n};\n\nexport { denormalize$2 as denormalize, normalize$2 as normalize, schema };","map":{"version":3,"sources":["/Users/juliablair/Desktop/christemp/ymun-app/node_modules/@rest-hooks/normalizr/dist/normalizr.es.js"],"names":["isImmutable","object","hasOwnProperty","_map","denormalizeImmutable","schema","input","unvisit","found","Object","keys","reduce","key","stringKey","get","item","foundItem","has","set","getDefaultGetId","idAttribute","EntitySchema","definition","options","Error","mergeStrategy","entityA","entityB","assign","processStrategy","_key","_getId","_idAttribute","_mergeStrategy","_processStrategy","define","entitySchema","parent","visit","addEntity","visitedEntities","id","getId","entityType","some","entity","push","processedEntity","forEach","value","PolymorphicSchema","schemaAttribute","_schemaAttribute","isSingleSchema","attr","getSchemaAttribute","inferSchema","normalizedValue","undefined","schemaKey","UnionSchema","normalizeValue","denormalizeValue","ValuesSchema","output","index","entityOrId","validateSchema","isArray","Array","length","getValues","map","normalize","values","denormalize","filter","ArraySchema","normalize$1","localSchema","denormalize$1","ObjectSchema","args","method","addEntities","entities","existingEntity","merge","Entity","Union","Values","normalize$2","result","unvisitEntity","getEntity","cache","entityCopy","getUnvisit","getEntities","isImmutable$1","getIn","toString","denormalize$2"],"mappings":"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","sourcesContent":["/**\n * Helpers to enable Immutable compatibility *without* bringing in\n * the 'immutable' package as a dependency.\n */\n\n/**\n * Check if an object is immutable by checking if it has a key specific\n * to the immutable library.\n *\n * @param  {any} object\n * @return {bool}\n */\nfunction isImmutable(object) {\n  return !!(object && typeof object.hasOwnProperty === 'function' && (object.hasOwnProperty('__ownerID') || // Immutable.Map\n  object._map && object._map.hasOwnProperty('__ownerID'))); // Immutable.Record\n}\n/**\n * Denormalize an immutable entity.\n *\n * @param  {Schema} schema\n * @param  {Immutable.Map|Immutable.Record} input\n * @param  {function} unvisit\n * @param  {function} getDenormalizedEntity\n * @return {Immutable.Map|Immutable.Record}\n */\n\nfunction denormalizeImmutable(schema, input, unvisit) {\n  let found = true;\n  return [Object.keys(schema).reduce((object, key) => {\n    // Immutable maps cast keys to strings on write so we need to ensure\n    // we're accessing them using string keys.\n    const stringKey = \"\" + key;\n    const [item, foundItem] = unvisit(object.get(stringKey), schema[stringKey]);\n\n    if (!foundItem) {\n      found = false;\n    }\n\n    if (object.has(stringKey)) {\n      return object.set(stringKey, item);\n    } else {\n      return object;\n    }\n  }, input), found];\n}\n\nconst getDefaultGetId = idAttribute => input => isImmutable(input) ? input.get(idAttribute) : input[idAttribute];\n\nclass EntitySchema {\n  constructor(key, definition = {}, options = {}) {\n    if (!key || typeof key !== 'string') {\n      throw new Error(\"Expected a string key for Entity, but found \" + key + \".\");\n    }\n\n    const {\n      idAttribute = 'id',\n      mergeStrategy = (entityA, entityB) => {\n        return Object.assign({}, entityA, {}, entityB);\n      },\n      processStrategy = input => Object.assign({}, input)\n    } = options;\n    this._key = key;\n    this._getId = typeof idAttribute === 'function' ? idAttribute : getDefaultGetId(idAttribute);\n    this._idAttribute = idAttribute;\n    this._mergeStrategy = mergeStrategy;\n    this._processStrategy = processStrategy;\n    this.define(definition);\n  }\n\n  get key() {\n    return this._key;\n  }\n\n  get idAttribute() {\n    return this._idAttribute;\n  }\n\n  define(definition) {\n    this.schema = Object.keys(definition).reduce((entitySchema, key) => {\n      const schema = definition[key];\n      return Object.assign({}, entitySchema, {\n        [key]: schema\n      });\n    }, this.schema || {});\n  }\n\n  getId(input, parent, key) {\n    return this._getId(input, parent, key);\n  }\n\n  merge(entityA, entityB) {\n    return this._mergeStrategy(entityA, entityB);\n  }\n\n  normalize(input, parent, key, visit, addEntity, visitedEntities) {\n    const id = this.getId(input, parent, key);\n    const entityType = this.key;\n\n    if (!(entityType in visitedEntities)) {\n      visitedEntities[entityType] = {};\n    }\n\n    if (!(id in visitedEntities[entityType])) {\n      visitedEntities[entityType][id] = [];\n    }\n\n    if (visitedEntities[entityType][id].some(entity => entity === input)) {\n      return id;\n    }\n\n    visitedEntities[entityType][id].push(input);\n\n    const processedEntity = this._processStrategy(input, parent, key);\n\n    Object.keys(this.schema).forEach(key => {\n      if (processedEntity.hasOwnProperty(key) && typeof processedEntity[key] === 'object') {\n        const schema = this.schema[key];\n        processedEntity[key] = visit(processedEntity[key], processedEntity, key, schema, addEntity, visitedEntities);\n      }\n    });\n    addEntity(this, processedEntity, input, parent, key);\n    return id;\n  }\n\n  denormalize(entity, unvisit) {\n    if (isImmutable(entity)) {\n      return denormalizeImmutable(this.schema, entity, unvisit);\n    }\n\n    let found = true;\n    Object.keys(this.schema).forEach(key => {\n      const schema = this.schema[key];\n      const [value, foundItem] = unvisit(entity[key], schema);\n\n      if (!foundItem) {\n        found = false;\n      }\n\n      if (entity.hasOwnProperty(key)) {\n        entity[key] = value;\n      }\n    });\n    return [entity, found];\n  }\n\n}\n\nclass PolymorphicSchema {\n  constructor(definition, schemaAttribute) {\n    if (schemaAttribute) {\n      this._schemaAttribute = typeof schemaAttribute === 'string' ? input => input[schemaAttribute] : schemaAttribute;\n    }\n\n    this.define(definition);\n  }\n\n  get isSingleSchema() {\n    return !this._schemaAttribute;\n  }\n\n  define(definition) {\n    this.schema = definition;\n  }\n\n  getSchemaAttribute(input, parent, key) {\n    return !this.isSingleSchema && this._schemaAttribute(input, parent, key);\n  }\n\n  inferSchema(input, parent, key) {\n    if (this.isSingleSchema) {\n      return this.schema;\n    }\n\n    const attr = this.getSchemaAttribute(input, parent, key);\n    return this.schema[attr];\n  }\n\n  normalizeValue(value, parent, key, visit, addEntity, visitedEntities) {\n    const schema = this.inferSchema(value, parent, key);\n\n    if (!schema) {\n      return value;\n    }\n\n    const normalizedValue = visit(value, parent, key, schema, addEntity, visitedEntities);\n    return this.isSingleSchema || normalizedValue === undefined || normalizedValue === null ? normalizedValue : {\n      id: normalizedValue,\n      schema: this.getSchemaAttribute(value, parent, key)\n    };\n  }\n\n  denormalizeValue(value, unvisit) {\n    const schemaKey = isImmutable(value) ? value.get('schema') : value.schema;\n\n    if (!this.isSingleSchema && !schemaKey) {\n      return [value, true];\n    }\n\n    const id = isImmutable(value) ? value.get('id') : value.id;\n    const schema = this.isSingleSchema ? this.schema : this.schema[schemaKey];\n    return unvisit(id || value, schema);\n  }\n\n}\n\nclass UnionSchema extends PolymorphicSchema {\n  constructor(definition, schemaAttribute) {\n    if (!schemaAttribute) {\n      throw new Error('Expected option \"schemaAttribute\" not found on UnionSchema.');\n    }\n\n    super(definition, schemaAttribute);\n  }\n\n  normalize(input, parent, key, visit, addEntity, visitedEntities) {\n    return this.normalizeValue(input, parent, key, visit, addEntity, visitedEntities);\n  }\n\n  denormalize(input, unvisit) {\n    return this.denormalizeValue(input, unvisit);\n  }\n\n}\n\nclass ValuesSchema extends PolymorphicSchema {\n  normalize(input, parent, key, visit, addEntity, visitedEntities) {\n    return Object.keys(input).reduce((output, key, index) => {\n      const value = input[key];\n      return value !== undefined && value !== null ? Object.assign({}, output, {\n        [key]: this.normalizeValue(value, input, key, visit, addEntity, visitedEntities)\n      }) : output;\n    }, {});\n  }\n\n  denormalize(input, unvisit) {\n    let found = true;\n    return [Object.keys(input).reduce((output, key) => {\n      const entityOrId = input[key];\n      const [value, foundItem] = this.denormalizeValue(entityOrId, unvisit);\n\n      if (!foundItem) {\n        found = false;\n      }\n\n      return Object.assign({}, output, {\n        [key]: value\n      });\n    }, {}), found];\n  }\n\n}\n\nconst validateSchema = definition => {\n  const isArray = Array.isArray(definition);\n\n  if (isArray && definition.length > 1) {\n    throw new Error(\"Expected schema definition to be a single schema, but found \" + definition.length + \".\");\n  }\n\n  return definition[0];\n};\n\nconst getValues = input => Array.isArray(input) ? input : Object.keys(input).map(key => input[key]);\n\nconst normalize = (schema, input, parent, key, visit, addEntity, visitedEntities) => {\n  schema = validateSchema(schema);\n  const values = getValues(input); // Special case: Arrays pass *their* parent on to their children, since there\n  // is not any special information that can be gathered from themselves directly\n\n  return values.map((value, index) => visit(value, parent, key, schema, addEntity, visitedEntities));\n};\nconst denormalize = (schema, input, unvisit) => {\n  schema = validateSchema(schema);\n  let found = true;\n\n  if (input === undefined && schema) {\n    [, found] = unvisit(undefined, schema);\n  }\n\n  return [input && input.map ? input.map(entityOrId => unvisit(entityOrId, schema)).filter(([, foundItem]) => foundItem).map(([value]) => value) : input, found];\n};\nclass ArraySchema extends PolymorphicSchema {\n  normalize(input, parent, key, visit, addEntity, visitedEntities) {\n    const values = getValues(input);\n    return values.map((value, index) => this.normalizeValue(value, parent, key, visit, addEntity, visitedEntities)).filter(value => value !== undefined && value !== null);\n  }\n\n  denormalize(input, unvisit) {\n    let found = true;\n\n    if (input === undefined && this.schema) {\n      [, found] = unvisit(undefined, this.schema);\n    }\n\n    return [input && input.map ? input.map(entityOrId => this.denormalizeValue(entityOrId, unvisit)).filter(([, foundItem]) => foundItem).map(([value]) => value) : input, found];\n  }\n\n}\n\nconst normalize$1 = (schema, input, parent, key, visit, addEntity, visitedEntities) => {\n  const object = Object.assign({}, input);\n  Object.keys(schema).forEach(key => {\n    const localSchema = schema[key];\n    const value = visit(input[key], input, key, localSchema, addEntity, visitedEntities);\n\n    if (value === undefined || value === null) {\n      delete object[key];\n    } else {\n      object[key] = value;\n    }\n  });\n  return object;\n};\nconst denormalize$1 = (schema, input, unvisit) => {\n  if (isImmutable(input)) {\n    return denormalizeImmutable(schema, input, unvisit);\n  }\n\n  const object = Object.assign({}, input);\n  let found = true;\n  Object.keys(schema).forEach(key => {\n    const [item, foundItem] = unvisit(object[key], schema[key]);\n\n    if (object[key] != null) {\n      object[key] = item;\n    }\n\n    if (!foundItem) {\n      found = false;\n    }\n  });\n  return [object, found];\n};\nclass ObjectSchema {\n  constructor(definition) {\n    this.define(definition);\n  }\n\n  define(definition) {\n    this.schema = Object.keys(definition).reduce((entitySchema, key) => {\n      const schema = definition[key];\n      return Object.assign({}, entitySchema, {\n        [key]: schema\n      });\n    }, this.schema || {});\n  }\n\n  normalize(...args) {\n    return normalize$1(this.schema, ...args);\n  }\n\n  denormalize(...args) {\n    return denormalize$1(this.schema, ...args);\n  }\n\n}\n\nconst visit = (value, parent, key, schema, addEntity, visitedEntities) => {\n  if (typeof value !== 'object' || !value) {\n    return value;\n  }\n\n  if (typeof schema === 'object' && (!schema.normalize || typeof schema.normalize !== 'function')) {\n    const method = Array.isArray(schema) ? normalize : normalize$1;\n    return method(schema, value, parent, key, visit, addEntity, visitedEntities);\n  }\n\n  return schema.normalize(value, parent, key, visit, addEntity, visitedEntities);\n};\n\nconst addEntities = entities => (schema, processedEntity, value, parent, key) => {\n  const schemaKey = schema.key;\n  const id = schema.getId(value, parent, key);\n\n  if (!(schemaKey in entities)) {\n    entities[schemaKey] = {};\n  }\n\n  const existingEntity = entities[schemaKey][id];\n\n  if (existingEntity) {\n    entities[schemaKey][id] = schema.merge(existingEntity, processedEntity);\n  } else {\n    entities[schemaKey][id] = processedEntity;\n  }\n};\n\nconst schema = {\n  Array: ArraySchema,\n  Entity: EntitySchema,\n  Object: ObjectSchema,\n  Union: UnionSchema,\n  Values: ValuesSchema\n};\nconst normalize$2 = (input, schema) => {\n  if (!input || typeof input !== 'object') {\n    throw new Error(\"Unexpected input given to normalize. Expected type to be \\\"object\\\", found \\\"\" + (input === null ? 'null' : typeof input) + \"\\\".\");\n  }\n\n  const entities = {};\n  const addEntity = addEntities(entities);\n  const visitedEntities = {};\n  const result = visit(input, input, null, schema, addEntity, visitedEntities);\n  return {\n    entities,\n    result\n  };\n};\n\nconst unvisitEntity = (id, schema, unvisit, getEntity, cache) => {\n  const entity = getEntity(id, schema);\n\n  if (typeof entity !== 'object' || entity === null) {\n    return [entity, false];\n  }\n\n  if (!cache[schema.key]) {\n    cache[schema.key] = {};\n  }\n\n  let found = true;\n\n  if (!cache[schema.key][id]) {\n    // Ensure we don't mutate it non-immutable objects\n    const entityCopy = isImmutable(entity) ? entity : Object.assign({}, entity); // Need to set this first so that if it is referenced further within the\n    // denormalization the reference will already exist.\n\n    cache[schema.key][id] = entityCopy;\n    [cache[schema.key][id], found] = schema.denormalize(entityCopy, unvisit);\n  }\n\n  return [cache[schema.key][id], found];\n};\n\nconst getUnvisit = entities => {\n  const cache = {};\n  const getEntity = getEntities(entities);\n  return function unvisit(input, schema) {\n    if (typeof schema === 'object' && (!schema.denormalize || typeof schema.denormalize !== 'function')) {\n      const method = Array.isArray(schema) ? denormalize : denormalize$1;\n      return method(schema, input, unvisit);\n    } // null is considered intentional, thus always 'found' as true\n\n\n    if (input === null) {\n      return [input, true];\n    }\n\n    if (schema instanceof EntitySchema) {\n      // unvisitEntity just can't handle undefined\n      if (input === undefined) {\n        return [input, false];\n      }\n\n      return unvisitEntity(input, schema, unvisit, getEntity, cache);\n    }\n\n    if (typeof schema.denormalize === 'function') {\n      return schema.denormalize(input, unvisit);\n    }\n\n    return [input, true];\n  };\n};\n\nconst getEntities = entities => {\n  const isImmutable$1 = isImmutable(entities);\n  return (entityOrId, schema) => {\n    const schemaKey = schema.key;\n\n    if (typeof entityOrId === 'object') {\n      return entityOrId;\n    }\n\n    if (isImmutable$1) {\n      return entities.getIn([schemaKey, entityOrId.toString()]);\n    }\n\n    return entities[schemaKey] && entities[schemaKey][entityOrId];\n  };\n};\n\nconst denormalize$2 = (input, schema, entities) => {\n  if (typeof input !== 'undefined') {\n    return getUnvisit(entities)(input, schema);\n  }\n\n  return [undefined, false];\n};\n\nexport { denormalize$2 as denormalize, normalize$2 as normalize, schema };\n"]},"metadata":{},"sourceType":"module"}