{"ast":null,"code":"import { useRef, useCallback, useEffect } from 'react';\nexport default function usePromisifiedDispatch(dispatch, state) {\n  var dispatchPromiseRef = useRef(null);\n  useEffect(function () {\n    if (dispatchPromiseRef.current) {\n      dispatchPromiseRef.current.resolve();\n      dispatchPromiseRef.current = null;\n    }\n  }, [state]);\n  return useCallback(function (action) {\n    if (!dispatchPromiseRef.current) {\n      dispatchPromiseRef.current = NewPromiseHolder();\n    } // we use the promise before dispatch so we know it will be resolved\n    // however that can also make the ref clear, so we need to make sure we have to promise before\n    // dispatching so we can return it even if the ref changes.\n\n\n    var promise = dispatchPromiseRef.current.promise;\n    dispatch(action);\n    return promise;\n  }, [dispatch]);\n}\n\nfunction NewPromiseHolder() {\n  // any so we can build it\n  var promiseHolder = {};\n  promiseHolder.promise = new Promise(function (resolve) {\n    promiseHolder.resolve = resolve;\n  });\n  return promiseHolder;\n}","map":{"version":3,"sources":["../../../src/react-integration/provider/usePromisifiedDispatch.ts"],"names":["dispatchPromiseRef","useRef","useEffect","useCallback","NewPromiseHolder","promise","dispatch","promiseHolder"],"mappings":"AAAA,SAAA,MAAA,EAAA,WAAA,EAAA,SAAA,QAAA,OAAA;AAIA,eAAe,SAAA,sBAAA,CAAA,QAAA,EAAA,KAAA,EAKb;AACA,MAAMA,kBAAkB,GAAGC,MAAM,CAAjC,IAAiC,CAAjC;AACAC,EAAAA,SAAS,CAAC,YAAM;AACd,QAAIF,kBAAkB,CAAtB,OAAA,EAAgC;AAC9BA,MAAAA,kBAAkB,CAAlBA,OAAAA,CAAAA,OAAAA;AACAA,MAAAA,kBAAkB,CAAlBA,OAAAA,GAAAA,IAAAA;AACD;AAJM,GAAA,EAKN,CALHE,KAKG,CALM,CAATA;AAOA,SAAOC,WAAW,CAChB,UAAA,MAAA,EAAoC;AAClC,QAAI,CAACH,kBAAkB,CAAvB,OAAA,EAAiC;AAC/BA,MAAAA,kBAAkB,CAAlBA,OAAAA,GAA6BI,gBAA7BJ,EAAAA;AAFgC,KAAA,CAIlC;AACA;AACA;;;AACA,QAAMK,OAAO,GAAGL,kBAAkB,CAAlBA,OAAAA,CAAhB,OAAA;AACAM,IAAAA,QAAQ,CAARA,MAAQ,CAARA;AACA,WAAA,OAAA;AAVc,GAAA,EAYhB,CAZF,QAYE,CAZgB,CAAlB;AAcD;;AAED,SAAA,gBAAA,GAA2C;AACzC;AACA,MAAMC,aAAkB,GAAxB,EAAA;AACAA,EAAAA,aAAa,CAAbA,OAAAA,GAAwB,IAAA,OAAA,CAAY,UAAA,OAAA,EAAW;AAC7CA,IAAAA,aAAa,CAAbA,OAAAA,GAAAA,OAAAA;AADFA,GAAwB,CAAxBA;AAGA,SAAA,aAAA;AACD","sourcesContent":["import { useRef, useCallback, useEffect } from 'react';\n\ntype PromiseHolder = { promise: Promise<void>; resolve: () => void };\n\nexport default function usePromisifiedDispatch<\n  R extends React.Reducer<any, any>\n>(\n  dispatch: React.Dispatch<React.ReducerAction<R>>,\n  state: React.ReducerState<R>,\n) {\n  const dispatchPromiseRef = useRef<null | PromiseHolder>(null);\n  useEffect(() => {\n    if (dispatchPromiseRef.current) {\n      dispatchPromiseRef.current.resolve();\n      dispatchPromiseRef.current = null;\n    }\n  }, [state]);\n\n  return useCallback(\n    (action: React.ReducerAction<R>) => {\n      if (!dispatchPromiseRef.current) {\n        dispatchPromiseRef.current = NewPromiseHolder();\n      }\n      // we use the promise before dispatch so we know it will be resolved\n      // however that can also make the ref clear, so we need to make sure we have to promise before\n      // dispatching so we can return it even if the ref changes.\n      const promise = dispatchPromiseRef.current.promise;\n      dispatch(action);\n      return promise;\n    },\n    [dispatch],\n  );\n}\n\nfunction NewPromiseHolder(): PromiseHolder {\n  // any so we can build it\n  const promiseHolder: any = {};\n  promiseHolder.promise = new Promise(resolve => {\n    promiseHolder.resolve = resolve;\n  });\n  return promiseHolder;\n}\n"]},"metadata":{},"sourceType":"module"}