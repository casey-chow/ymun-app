{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useDenormalized } from \"../../state/selectors\";\nimport useRetrieve from './useRetrieve';\nimport useError from './useError';\nimport { useMemo, useContext } from 'react';\nimport { StateContext } from \"../context\";\nimport hasUsableData from './hasUsableData';\n/** single form resource */\n\nfunction useOneResource(fetchShape, params) {\n  var maybePromise = useRetrieve(fetchShape, params);\n  var state = useContext(StateContext);\n\n  var _useDenormalized = useDenormalized(fetchShape, params, state),\n      _useDenormalized2 = _slicedToArray(_useDenormalized, 2),\n      denormalized = _useDenormalized2[0],\n      ready = _useDenormalized2[1];\n\n  var error = useError(fetchShape, params, ready);\n  if (!hasUsableData(ready, fetchShape) && maybePromise) throw maybePromise;\n  if (error) throw error;\n  return denormalized;\n}\n/** many form resource */\n\n\nfunction useManyResources() {\n  for (var _len = arguments.length, resourceList = new Array(_len), _key = 0; _key < _len; _key++) {\n    resourceList[_key] = arguments[_key];\n  }\n\n  var state = useContext(StateContext);\n  var denormalizedValues = resourceList.map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        fetchShape = _ref2[0],\n        params = _ref2[1];\n\n    return (// eslint-disable-next-line react-hooks/rules-of-hooks\n      useDenormalized(fetchShape, params, state)\n    );\n  });\n  var promises = resourceList.map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        fetchShape = _ref4[0],\n        params = _ref4[1];\n\n    return (// eslint-disable-next-line react-hooks/rules-of-hooks\n      useRetrieve(fetchShape, params)\n    );\n  }) // only wait on promises without results\n  .map(function (p, i) {\n    return !hasUsableData(denormalizedValues[i][1], resourceList[i][0]) && p;\n  }); // throw first valid error\n\n  for (var i = 0; i < resourceList.length; i++) {\n    var _resourceList$i = _slicedToArray(resourceList[i], 2),\n        _fetchShape = _resourceList$i[0],\n        _params = _resourceList$i[1];\n\n    var _denormalizedValues$i = _slicedToArray(denormalizedValues[i], 2),\n        _ = _denormalizedValues$i[0],\n        ready = _denormalizedValues$i[1]; // eslint-disable-next-line react-hooks/rules-of-hooks\n\n\n    var error = useError(_fetchShape, _params, ready);\n    if (error && !promises[i]) throw error;\n  }\n\n  var promise = useMemo(function () {\n    var activePromises = promises.filter(function (p) {\n      return p;\n    });\n\n    if (activePromises.length) {\n      return Promise.all(activePromises);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, promises);\n  if (promise) throw promise;\n  return denormalizedValues.map(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 1),\n        denormalized = _ref6[0];\n\n    return denormalized;\n  });\n}\n\nexport default function useResource() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  } // this conditional use of hooks is ok as long as the structure of the arguments don't change\n\n\n  if (Array.isArray(args[0])) {\n    // TODO: provide type guard function to detect this\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return useManyResources.apply(void 0, _toConsumableArray(args));\n  }\n\n  args = args; // TODO: make return types match up with the branching logic we put in here.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n\n  return useOneResource(args[0], args[1]);\n}","map":{"version":3,"sources":["../../../src/react-integration/hooks/useResource.ts"],"names":["maybePromise","useRetrieve","state","useContext","denormalized","ready","useDenormalized","error","useError","hasUsableData","resourceList","denormalizedValues","fetchShape","params","promises","i","_","promise","useMemo","activePromises","Promise","args","Array","useManyResources","useOneResource"],"mappings":"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","sourcesContent":["import {\n  ReadShape,\n  Schema,\n  Denormalize,\n  DenormalizeNullable,\n} from '~/resource';\nimport { useDenormalized } from '~/state/selectors';\nimport useRetrieve from './useRetrieve';\nimport useError from './useError';\nimport { useMemo, useContext } from 'react';\nimport { StateContext } from '~/react-integration/context';\n\nimport hasUsableData from './hasUsableData';\n\ntype ResourceArgs<S extends Schema, Params extends Readonly<object>> = [\n  ReadShape<S, Params>,\n  Params | null,\n];\n\n/** single form resource */\nfunction useOneResource<Params extends Readonly<object>, S extends Schema>(\n  fetchShape: ReadShape<S, Params>,\n  params: Params | null,\n): CondNull<typeof params, DenormalizeNullable<S>, Denormalize<S>> {\n  const maybePromise = useRetrieve(fetchShape, params);\n  const state = useContext(StateContext);\n  const [denormalized, ready] = useDenormalized(fetchShape, params, state);\n  const error = useError(fetchShape, params, ready);\n\n  if (!hasUsableData(ready, fetchShape) && maybePromise) throw maybePromise;\n  if (error) throw error;\n\n  return denormalized as any;\n}\n\n/** many form resource */\nfunction useManyResources<A extends ResourceArgs<any, any>[]>(\n  ...resourceList: A\n) {\n  const state = useContext(StateContext);\n  const denormalizedValues = resourceList.map(\n    <Params extends Readonly<object>, S extends Schema>([\n      fetchShape,\n      params,\n    ]: ResourceArgs<S, Params>) =>\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      useDenormalized(fetchShape, params, state),\n  );\n  const promises = resourceList\n    .map(([fetchShape, params]) =>\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      useRetrieve(fetchShape, params),\n    )\n    // only wait on promises without results\n    .map(\n      (p, i) =>\n        !hasUsableData(denormalizedValues[i][1], resourceList[i][0]) && p,\n    );\n\n  // throw first valid error\n  for (let i = 0; i < resourceList.length; i++) {\n    const [fetchShape, params] = resourceList[i];\n    const [_, ready] = denormalizedValues[i];\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const error = useError(fetchShape, params, ready);\n    if (error && !promises[i]) throw error;\n  }\n\n  const promise = useMemo(() => {\n    const activePromises = promises.filter(p => p);\n    if (activePromises.length) {\n      return Promise.all(activePromises);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, promises);\n\n  if (promise) throw promise;\n\n  return denormalizedValues.map(([denormalized]) => denormalized);\n}\n\ntype CondNull<P, A, B> = P extends null ? A : B;\n\n/** Ensure a resource is available; suspending to React until it is. */\nexport default function useResource<\n  P extends Readonly<object> | null,\n  B extends Readonly<object | string> | void,\n  S extends Schema\n>(\n  fetchShape: ReadShape<S, NonNullable<P>>,\n  params: P,\n): CondNull<P, DenormalizeNullable<S>, Denormalize<S>>;\nexport default function useResource<\n  P1 extends Readonly<object> | null,\n  S1 extends Schema\n>(\n  v1: [ReadShape<S1, NonNullable<P1>>, P1],\n): [CondNull<P1, DenormalizeNullable<S1>, Denormalize<S1>>];\nexport default function useResource<\n  P1 extends Readonly<object> | null,\n  S1 extends Schema,\n  P2 extends Readonly<object> | null,\n  S2 extends Schema\n>(\n  v1: [ReadShape<S1, NonNullable<P1>>, P1],\n  v2: [ReadShape<S2, NonNullable<P2>>, P2],\n): [\n  CondNull<P1, DenormalizeNullable<S1>, Denormalize<S1>>,\n  CondNull<P2, DenormalizeNullable<S2>, Denormalize<S2>>,\n];\nexport default function useResource<\n  P1 extends Readonly<object> | null,\n  S1 extends Schema,\n  P2 extends Readonly<object> | null,\n  S2 extends Schema,\n  P3 extends Readonly<object> | null,\n  S3 extends Schema\n>(\n  v1: [ReadShape<S1, NonNullable<P1>>, P1],\n  v2: [ReadShape<S2, NonNullable<P2>>, P2],\n  v3: [ReadShape<S3, NonNullable<P3>>, P3],\n): [\n  CondNull<P1, DenormalizeNullable<S1>, Denormalize<S1>>,\n  CondNull<P2, DenormalizeNullable<S2>, Denormalize<S2>>,\n  CondNull<P3, DenormalizeNullable<S3>, Denormalize<S3>>,\n];\nexport default function useResource<\n  P1 extends Readonly<object> | null,\n  S1 extends Schema,\n  P2 extends Readonly<object> | null,\n  S2 extends Schema,\n  P3 extends Readonly<object> | null,\n  S3 extends Schema,\n  P4 extends Readonly<object> | null,\n  S4 extends Schema\n>(\n  v1: [ReadShape<S1, NonNullable<P1>>, P1],\n  v2: [ReadShape<S2, NonNullable<P2>>, P2],\n  v3: [ReadShape<S3, NonNullable<P3>>, P3],\n  v4: [ReadShape<S4, NonNullable<P4>>, P4],\n): [\n  CondNull<P1, DenormalizeNullable<S1>, Denormalize<S1>>,\n  CondNull<P2, DenormalizeNullable<S2>, Denormalize<S2>>,\n  CondNull<P3, DenormalizeNullable<S3>, Denormalize<S3>>,\n  CondNull<P4, DenormalizeNullable<S4>, Denormalize<S4>>,\n];\nexport default function useResource<\n  P1 extends Readonly<object> | null,\n  S1 extends Schema,\n  P2 extends Readonly<object> | null,\n  S2 extends Schema,\n  P3 extends Readonly<object> | null,\n  S3 extends Schema,\n  P4 extends Readonly<object> | null,\n  S4 extends Schema,\n  P5 extends Readonly<object> | null,\n  S5 extends Schema\n>(\n  v1: [ReadShape<S1, NonNullable<P1>>, P1],\n  v2: [ReadShape<S2, NonNullable<P2>>, P2],\n  v3: [ReadShape<S3, NonNullable<P3>>, P3],\n  v4: [ReadShape<S4, NonNullable<P4>>, P4],\n  v5: [ReadShape<S5, NonNullable<P5>>, P5],\n): [\n  CondNull<P1, DenormalizeNullable<S1>, Denormalize<S1>>,\n  CondNull<P2, DenormalizeNullable<S2>, Denormalize<S2>>,\n  CondNull<P3, DenormalizeNullable<S3>, Denormalize<S3>>,\n  CondNull<P4, DenormalizeNullable<S4>, Denormalize<S4>>,\n  CondNull<P5, DenormalizeNullable<S5>, Denormalize<S5>>,\n];\nexport default function useResource<\n  Params extends Readonly<object>,\n  S extends Schema\n>(...args: ResourceArgs<S, Params> | ResourceArgs<S, Params>[]): any {\n  // this conditional use of hooks is ok as long as the structure of the arguments don't change\n  if (Array.isArray(args[0])) {\n    // TODO: provide type guard function to detect this\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return useManyResources(...(args as ResourceArgs<S, Params>[]));\n  }\n  args = args as ResourceArgs<S, Params>;\n  // TODO: make return types match up with the branching logic we put in here.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return useOneResource(args[0], args[1]);\n}\n"]},"metadata":{},"sourceType":"module"}