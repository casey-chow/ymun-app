{"ast":null,"code":"import _slicedToArray from \"/Users/juliablair/Desktop/christemp/ymun-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * Helpers to enable Immutable compatibility *without* bringing in\n * the 'immutable' package as a dependency.\n */\n\n/**\n * Check if an object is immutable by checking if it has a key specific\n * to the immutable library.\n *\n * @param  {any} object\n * @return {bool}\n */\nfunction isImmutable(object) {\n  return !!(object && typeof object.hasOwnProperty === 'function' && (object.hasOwnProperty('__ownerID') || // Immutable.Map\n  object._map && object._map.hasOwnProperty('__ownerID'))); // Immutable.Record\n}\n/**\n * Denormalize an immutable entity.\n *\n * @param  {Schema} schema\n * @param  {Immutable.Map|Immutable.Record} input\n * @param  {function} unvisit\n * @param  {function} getDenormalizedEntity\n * @return {Immutable.Map|Immutable.Record}\n */\n\n\nfunction denormalizeImmutable(schema, input, unvisit) {\n  let found = true;\n  return [Object.keys(schema).reduce((object, key) => {\n    // Immutable maps cast keys to strings on write so we need to ensure\n    // we're accessing them using string keys.\n    const stringKey = \"\" + key;\n\n    const _unvisit = unvisit(object.get(stringKey), schema[stringKey]),\n          _unvisit2 = _slicedToArray(_unvisit, 2),\n          item = _unvisit2[0],\n          foundItem = _unvisit2[1];\n\n    if (!foundItem) {\n      found = false;\n    }\n\n    if (object.has(stringKey)) {\n      return object.set(stringKey, item);\n    } else {\n      return object;\n    }\n  }, input), found];\n}\n\nconst getDefaultGetId = idAttribute => input => isImmutable(input) ? input.get(idAttribute) : input[idAttribute];\n\nclass EntitySchema {\n  constructor(key, definition = {}, options = {}) {\n    if (!key || typeof key !== 'string') {\n      throw new Error(\"Expected a string key for Entity, but found \" + key + \".\");\n    }\n\n    const _options$idAttribute = options.idAttribute,\n          idAttribute = _options$idAttribute === void 0 ? 'id' : _options$idAttribute,\n          _options$mergeStrateg = options.mergeStrategy,\n          mergeStrategy = _options$mergeStrateg === void 0 ? (entityA, entityB) => {\n      return Object.assign({}, entityA, {}, entityB);\n    } : _options$mergeStrateg,\n          _options$processStrat = options.processStrategy,\n          processStrategy = _options$processStrat === void 0 ? input => Object.assign({}, input) : _options$processStrat;\n    this._key = key;\n    this._getId = typeof idAttribute === 'function' ? idAttribute : getDefaultGetId(idAttribute);\n    this._idAttribute = idAttribute;\n    this._mergeStrategy = mergeStrategy;\n    this._processStrategy = processStrategy;\n    this.define(definition);\n  }\n\n  get key() {\n    return this._key;\n  }\n\n  get idAttribute() {\n    return this._idAttribute;\n  }\n\n  define(definition) {\n    this.schema = Object.keys(definition).reduce((entitySchema, key) => {\n      const schema = definition[key];\n      return Object.assign({}, entitySchema, {\n        [key]: schema\n      });\n    }, this.schema || {});\n  }\n\n  getId(input, parent, key) {\n    return this._getId(input, parent, key);\n  }\n\n  merge(entityA, entityB) {\n    return this._mergeStrategy(entityA, entityB);\n  }\n\n  normalize(input, parent, key, visit, addEntity, visitedEntities) {\n    const id = this.getId(input, parent, key);\n    const entityType = this.key;\n\n    if (!(entityType in visitedEntities)) {\n      visitedEntities[entityType] = {};\n    }\n\n    if (!(id in visitedEntities[entityType])) {\n      visitedEntities[entityType][id] = [];\n    }\n\n    if (visitedEntities[entityType][id].some(entity => entity === input)) {\n      return id;\n    }\n\n    visitedEntities[entityType][id].push(input);\n\n    const processedEntity = this._processStrategy(input, parent, key);\n\n    Object.keys(this.schema).forEach(key => {\n      if (processedEntity.hasOwnProperty(key) && typeof processedEntity[key] === 'object') {\n        const schema = this.schema[key];\n        processedEntity[key] = visit(processedEntity[key], processedEntity, key, schema, addEntity, visitedEntities);\n      }\n    });\n    addEntity(this, processedEntity, input, parent, key);\n    return id;\n  }\n\n  denormalize(entity, unvisit) {\n    if (isImmutable(entity)) {\n      return denormalizeImmutable(this.schema, entity, unvisit);\n    }\n\n    let found = true;\n    Object.keys(this.schema).forEach(key => {\n      const schema = this.schema[key];\n\n      const _unvisit3 = unvisit(entity[key], schema),\n            _unvisit4 = _slicedToArray(_unvisit3, 2),\n            value = _unvisit4[0],\n            foundItem = _unvisit4[1];\n\n      if (!foundItem) {\n        found = false;\n      }\n\n      if (entity.hasOwnProperty(key)) {\n        entity[key] = value;\n      }\n    });\n    return [entity, found];\n  }\n\n}\n\nclass PolymorphicSchema {\n  constructor(definition, schemaAttribute) {\n    if (schemaAttribute) {\n      this._schemaAttribute = typeof schemaAttribute === 'string' ? input => input[schemaAttribute] : schemaAttribute;\n    }\n\n    this.define(definition);\n  }\n\n  get isSingleSchema() {\n    return !this._schemaAttribute;\n  }\n\n  define(definition) {\n    this.schema = definition;\n  }\n\n  getSchemaAttribute(input, parent, key) {\n    return !this.isSingleSchema && this._schemaAttribute(input, parent, key);\n  }\n\n  inferSchema(input, parent, key) {\n    if (this.isSingleSchema) {\n      return this.schema;\n    }\n\n    const attr = this.getSchemaAttribute(input, parent, key);\n    return this.schema[attr];\n  }\n\n  normalizeValue(value, parent, key, visit, addEntity, visitedEntities) {\n    const schema = this.inferSchema(value, parent, key);\n\n    if (!schema) {\n      return value;\n    }\n\n    const normalizedValue = visit(value, parent, key, schema, addEntity, visitedEntities);\n    return this.isSingleSchema || normalizedValue === undefined || normalizedValue === null ? normalizedValue : {\n      id: normalizedValue,\n      schema: this.getSchemaAttribute(value, parent, key)\n    };\n  }\n\n  denormalizeValue(value, unvisit) {\n    const schemaKey = isImmutable(value) ? value.get('schema') : value.schema;\n\n    if (!this.isSingleSchema && !schemaKey) {\n      return [value, true];\n    }\n\n    const id = isImmutable(value) ? value.get('id') : value.id;\n    const schema = this.isSingleSchema ? this.schema : this.schema[schemaKey];\n    return unvisit(id || value, schema);\n  }\n\n}\n\nclass UnionSchema extends PolymorphicSchema {\n  constructor(definition, schemaAttribute) {\n    if (!schemaAttribute) {\n      throw new Error('Expected option \"schemaAttribute\" not found on UnionSchema.');\n    }\n\n    super(definition, schemaAttribute);\n  }\n\n  normalize(input, parent, key, visit, addEntity, visitedEntities) {\n    return this.normalizeValue(input, parent, key, visit, addEntity, visitedEntities);\n  }\n\n  denormalize(input, unvisit) {\n    return this.denormalizeValue(input, unvisit);\n  }\n\n}\n\nclass ValuesSchema extends PolymorphicSchema {\n  normalize(input, parent, key, visit, addEntity, visitedEntities) {\n    return Object.keys(input).reduce((output, key, index) => {\n      const value = input[key];\n      return value !== undefined && value !== null ? Object.assign({}, output, {\n        [key]: this.normalizeValue(value, input, key, visit, addEntity, visitedEntities)\n      }) : output;\n    }, {});\n  }\n\n  denormalize(input, unvisit) {\n    let found = true;\n    return [Object.keys(input).reduce((output, key) => {\n      const entityOrId = input[key];\n\n      const _this$denormalizeValu = this.denormalizeValue(entityOrId, unvisit),\n            _this$denormalizeValu2 = _slicedToArray(_this$denormalizeValu, 2),\n            value = _this$denormalizeValu2[0],\n            foundItem = _this$denormalizeValu2[1];\n\n      if (!foundItem) {\n        found = false;\n      }\n\n      return Object.assign({}, output, {\n        [key]: value\n      });\n    }, {}), found];\n  }\n\n}\n\nconst validateSchema = definition => {\n  const isArray = Array.isArray(definition);\n\n  if (isArray && definition.length > 1) {\n    throw new Error(\"Expected schema definition to be a single schema, but found \" + definition.length + \".\");\n  }\n\n  return definition[0];\n};\n\nconst getValues = input => Array.isArray(input) ? input : Object.keys(input).map(key => input[key]);\n\nconst normalize = (schema, input, parent, key, visit, addEntity, visitedEntities) => {\n  schema = validateSchema(schema);\n  const values = getValues(input); // Special case: Arrays pass *their* parent on to their children, since there\n  // is not any special information that can be gathered from themselves directly\n\n  return values.map((value, index) => visit(value, parent, key, schema, addEntity, visitedEntities));\n};\n\nconst denormalize = (schema, input, unvisit) => {\n  schema = validateSchema(schema);\n  let found = true;\n\n  if (input === undefined && schema) {\n    var _unvisit5 = unvisit(undefined, schema);\n\n    var _unvisit6 = _slicedToArray(_unvisit5, 2);\n\n    found = _unvisit6[1];\n  }\n\n  return [input && input.map ? input.map(entityOrId => unvisit(entityOrId, schema)).filter(([, foundItem]) => foundItem).map(([value]) => value) : input, found];\n};\n\nclass ArraySchema extends PolymorphicSchema {\n  normalize(input, parent, key, visit, addEntity, visitedEntities) {\n    const values = getValues(input);\n    return values.map((value, index) => this.normalizeValue(value, parent, key, visit, addEntity, visitedEntities)).filter(value => value !== undefined && value !== null);\n  }\n\n  denormalize(input, unvisit) {\n    let found = true;\n\n    if (input === undefined && this.schema) {\n      var _unvisit7 = unvisit(undefined, this.schema);\n\n      var _unvisit8 = _slicedToArray(_unvisit7, 2);\n\n      found = _unvisit8[1];\n    }\n\n    return [input && input.map ? input.map(entityOrId => this.denormalizeValue(entityOrId, unvisit)).filter(([, foundItem]) => foundItem).map(([value]) => value) : input, found];\n  }\n\n}\n\nconst normalize$1 = (schema, input, parent, key, visit, addEntity, visitedEntities) => {\n  const object = Object.assign({}, input);\n  Object.keys(schema).forEach(key => {\n    const localSchema = schema[key];\n    const value = visit(input[key], input, key, localSchema, addEntity, visitedEntities);\n\n    if (value === undefined || value === null) {\n      delete object[key];\n    } else {\n      object[key] = value;\n    }\n  });\n  return object;\n};\n\nconst denormalize$1 = (schema, input, unvisit) => {\n  if (isImmutable(input)) {\n    return denormalizeImmutable(schema, input, unvisit);\n  }\n\n  const object = Object.assign({}, input);\n  let found = true;\n  Object.keys(schema).forEach(key => {\n    const _unvisit9 = unvisit(object[key], schema[key]),\n          _unvisit10 = _slicedToArray(_unvisit9, 2),\n          item = _unvisit10[0],\n          foundItem = _unvisit10[1];\n\n    if (object[key] != null) {\n      object[key] = item;\n    }\n\n    if (!foundItem) {\n      found = false;\n    }\n  });\n  return [object, found];\n};\n\nclass ObjectSchema {\n  constructor(definition) {\n    this.define(definition);\n  }\n\n  define(definition) {\n    this.schema = Object.keys(definition).reduce((entitySchema, key) => {\n      const schema = definition[key];\n      return Object.assign({}, entitySchema, {\n        [key]: schema\n      });\n    }, this.schema || {});\n  }\n\n  normalize(...args) {\n    return normalize$1(this.schema, ...args);\n  }\n\n  denormalize(...args) {\n    return denormalize$1(this.schema, ...args);\n  }\n\n}\n\nconst visit = (value, parent, key, schema, addEntity, visitedEntities) => {\n  if (typeof value !== 'object' || !value) {\n    return value;\n  }\n\n  if (typeof schema === 'object' && (!schema.normalize || typeof schema.normalize !== 'function')) {\n    const method = Array.isArray(schema) ? normalize : normalize$1;\n    return method(schema, value, parent, key, visit, addEntity, visitedEntities);\n  }\n\n  return schema.normalize(value, parent, key, visit, addEntity, visitedEntities);\n};\n\nconst addEntities = entities => (schema, processedEntity, value, parent, key) => {\n  const schemaKey = schema.key;\n  const id = schema.getId(value, parent, key);\n\n  if (!(schemaKey in entities)) {\n    entities[schemaKey] = {};\n  }\n\n  const existingEntity = entities[schemaKey][id];\n\n  if (existingEntity) {\n    entities[schemaKey][id] = schema.merge(existingEntity, processedEntity);\n  } else {\n    entities[schemaKey][id] = processedEntity;\n  }\n};\n\nconst schema = {\n  Array: ArraySchema,\n  Entity: EntitySchema,\n  Object: ObjectSchema,\n  Union: UnionSchema,\n  Values: ValuesSchema\n};\n\nconst normalize$2 = (input, schema) => {\n  if (!input || typeof input !== 'object') {\n    throw new Error(\"Unexpected input given to normalize. Expected type to be \\\"object\\\", found \\\"\" + (input === null ? 'null' : typeof input) + \"\\\".\");\n  }\n\n  const entities = {};\n  const addEntity = addEntities(entities);\n  const visitedEntities = {};\n  const result = visit(input, input, null, schema, addEntity, visitedEntities);\n  return {\n    entities,\n    result\n  };\n};\n\nconst unvisitEntity = (id, schema, unvisit, getEntity, cache) => {\n  const entity = getEntity(id, schema);\n\n  if (typeof entity !== 'object' || entity === null) {\n    return [entity, false];\n  }\n\n  if (!cache[schema.key]) {\n    cache[schema.key] = {};\n  }\n\n  let found = true;\n\n  if (!cache[schema.key][id]) {\n    // Ensure we don't mutate it non-immutable objects\n    const entityCopy = isImmutable(entity) ? entity : Object.assign({}, entity); // Need to set this first so that if it is referenced further within the\n    // denormalization the reference will already exist.\n\n    cache[schema.key][id] = entityCopy;\n\n    var _schema$denormalize = schema.denormalize(entityCopy, unvisit);\n\n    var _schema$denormalize2 = _slicedToArray(_schema$denormalize, 2);\n\n    cache[schema.key][id] = _schema$denormalize2[0];\n    found = _schema$denormalize2[1];\n  }\n\n  return [cache[schema.key][id], found];\n};\n\nconst getUnvisit = entities => {\n  const cache = {};\n  const getEntity = getEntities(entities);\n  return function unvisit(input, schema) {\n    if (typeof schema === 'object' && (!schema.denormalize || typeof schema.denormalize !== 'function')) {\n      const method = Array.isArray(schema) ? denormalize : denormalize$1;\n      return method(schema, input, unvisit);\n    } // null is considered intentional, thus always 'found' as true\n\n\n    if (input === null) {\n      return [input, true];\n    }\n\n    if (schema instanceof EntitySchema) {\n      // unvisitEntity just can't handle undefined\n      if (input === undefined) {\n        return [input, false];\n      }\n\n      return unvisitEntity(input, schema, unvisit, getEntity, cache);\n    }\n\n    if (typeof schema.denormalize === 'function') {\n      return schema.denormalize(input, unvisit);\n    }\n\n    return [input, true];\n  };\n};\n\nconst getEntities = entities => {\n  const isImmutable$1 = isImmutable(entities);\n  return (entityOrId, schema) => {\n    const schemaKey = schema.key;\n\n    if (typeof entityOrId === 'object') {\n      return entityOrId;\n    }\n\n    if (isImmutable$1) {\n      return entities.getIn([schemaKey, entityOrId.toString()]);\n    }\n\n    return entities[schemaKey] && entities[schemaKey][entityOrId];\n  };\n};\n\nconst denormalize$2 = (input, schema, entities) => {\n  if (typeof input !== 'undefined') {\n    return getUnvisit(entities)(input, schema);\n  }\n\n  return [undefined, false];\n};\n\nexport { denormalize$2 as denormalize, normalize$2 as normalize, schema };","map":{"version":3,"sources":["/Users/juliablair/Desktop/christemp/ymun-app/node_modules/@rest-hooks/normalizr/dist/normalizr.es.js"],"names":["isImmutable","object","hasOwnProperty","_map","denormalizeImmutable","schema","input","unvisit","found","Object","keys","reduce","key","stringKey","get","item","foundItem","has","set","getDefaultGetId","idAttribute","EntitySchema","constructor","definition","options","Error","mergeStrategy","entityA","entityB","assign","processStrategy","_key","_getId","_idAttribute","_mergeStrategy","_processStrategy","define","entitySchema","getId","parent","merge","normalize","visit","addEntity","visitedEntities","id","entityType","some","entity","push","processedEntity","forEach","denormalize","value","PolymorphicSchema","schemaAttribute","_schemaAttribute","isSingleSchema","getSchemaAttribute","inferSchema","attr","normalizeValue","normalizedValue","undefined","denormalizeValue","schemaKey","UnionSchema","ValuesSchema","output","index","entityOrId","validateSchema","isArray","Array","length","getValues","map","values","filter","ArraySchema","normalize$1","localSchema","denormalize$1","ObjectSchema","args","method","addEntities","entities","existingEntity","Entity","Union","Values","normalize$2","result","unvisitEntity","getEntity","cache","entityCopy","getUnvisit","getEntities","isImmutable$1","getIn","toString","denormalize$2"],"mappings":"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","sourcesContent":["/**\n * Helpers to enable Immutable compatibility *without* bringing in\n * the 'immutable' package as a dependency.\n */\n\n/**\n * Check if an object is immutable by checking if it has a key specific\n * to the immutable library.\n *\n * @param  {any} object\n * @return {bool}\n */\nfunction isImmutable(object) {\n  return !!(object && typeof object.hasOwnProperty === 'function' && (object.hasOwnProperty('__ownerID') || // Immutable.Map\n  object._map && object._map.hasOwnProperty('__ownerID'))); // Immutable.Record\n}\n/**\n * Denormalize an immutable entity.\n *\n * @param  {Schema} schema\n * @param  {Immutable.Map|Immutable.Record} input\n * @param  {function} unvisit\n * @param  {function} getDenormalizedEntity\n * @return {Immutable.Map|Immutable.Record}\n */\n\nfunction denormalizeImmutable(schema, input, unvisit) {\n  let found = true;\n  return [Object.keys(schema).reduce((object, key) => {\n    // Immutable maps cast keys to strings on write so we need to ensure\n    // we're accessing them using string keys.\n    const stringKey = \"\" + key;\n    const [item, foundItem] = unvisit(object.get(stringKey), schema[stringKey]);\n\n    if (!foundItem) {\n      found = false;\n    }\n\n    if (object.has(stringKey)) {\n      return object.set(stringKey, item);\n    } else {\n      return object;\n    }\n  }, input), found];\n}\n\nconst getDefaultGetId = idAttribute => input => isImmutable(input) ? input.get(idAttribute) : input[idAttribute];\n\nclass EntitySchema {\n  constructor(key, definition = {}, options = {}) {\n    if (!key || typeof key !== 'string') {\n      throw new Error(\"Expected a string key for Entity, but found \" + key + \".\");\n    }\n\n    const {\n      idAttribute = 'id',\n      mergeStrategy = (entityA, entityB) => {\n        return Object.assign({}, entityA, {}, entityB);\n      },\n      processStrategy = input => Object.assign({}, input)\n    } = options;\n    this._key = key;\n    this._getId = typeof idAttribute === 'function' ? idAttribute : getDefaultGetId(idAttribute);\n    this._idAttribute = idAttribute;\n    this._mergeStrategy = mergeStrategy;\n    this._processStrategy = processStrategy;\n    this.define(definition);\n  }\n\n  get key() {\n    return this._key;\n  }\n\n  get idAttribute() {\n    return this._idAttribute;\n  }\n\n  define(definition) {\n    this.schema = Object.keys(definition).reduce((entitySchema, key) => {\n      const schema = definition[key];\n      return Object.assign({}, entitySchema, {\n        [key]: schema\n      });\n    }, this.schema || {});\n  }\n\n  getId(input, parent, key) {\n    return this._getId(input, parent, key);\n  }\n\n  merge(entityA, entityB) {\n    return this._mergeStrategy(entityA, entityB);\n  }\n\n  normalize(input, parent, key, visit, addEntity, visitedEntities) {\n    const id = this.getId(input, parent, key);\n    const entityType = this.key;\n\n    if (!(entityType in visitedEntities)) {\n      visitedEntities[entityType] = {};\n    }\n\n    if (!(id in visitedEntities[entityType])) {\n      visitedEntities[entityType][id] = [];\n    }\n\n    if (visitedEntities[entityType][id].some(entity => entity === input)) {\n      return id;\n    }\n\n    visitedEntities[entityType][id].push(input);\n\n    const processedEntity = this._processStrategy(input, parent, key);\n\n    Object.keys(this.schema).forEach(key => {\n      if (processedEntity.hasOwnProperty(key) && typeof processedEntity[key] === 'object') {\n        const schema = this.schema[key];\n        processedEntity[key] = visit(processedEntity[key], processedEntity, key, schema, addEntity, visitedEntities);\n      }\n    });\n    addEntity(this, processedEntity, input, parent, key);\n    return id;\n  }\n\n  denormalize(entity, unvisit) {\n    if (isImmutable(entity)) {\n      return denormalizeImmutable(this.schema, entity, unvisit);\n    }\n\n    let found = true;\n    Object.keys(this.schema).forEach(key => {\n      const schema = this.schema[key];\n      const [value, foundItem] = unvisit(entity[key], schema);\n\n      if (!foundItem) {\n        found = false;\n      }\n\n      if (entity.hasOwnProperty(key)) {\n        entity[key] = value;\n      }\n    });\n    return [entity, found];\n  }\n\n}\n\nclass PolymorphicSchema {\n  constructor(definition, schemaAttribute) {\n    if (schemaAttribute) {\n      this._schemaAttribute = typeof schemaAttribute === 'string' ? input => input[schemaAttribute] : schemaAttribute;\n    }\n\n    this.define(definition);\n  }\n\n  get isSingleSchema() {\n    return !this._schemaAttribute;\n  }\n\n  define(definition) {\n    this.schema = definition;\n  }\n\n  getSchemaAttribute(input, parent, key) {\n    return !this.isSingleSchema && this._schemaAttribute(input, parent, key);\n  }\n\n  inferSchema(input, parent, key) {\n    if (this.isSingleSchema) {\n      return this.schema;\n    }\n\n    const attr = this.getSchemaAttribute(input, parent, key);\n    return this.schema[attr];\n  }\n\n  normalizeValue(value, parent, key, visit, addEntity, visitedEntities) {\n    const schema = this.inferSchema(value, parent, key);\n\n    if (!schema) {\n      return value;\n    }\n\n    const normalizedValue = visit(value, parent, key, schema, addEntity, visitedEntities);\n    return this.isSingleSchema || normalizedValue === undefined || normalizedValue === null ? normalizedValue : {\n      id: normalizedValue,\n      schema: this.getSchemaAttribute(value, parent, key)\n    };\n  }\n\n  denormalizeValue(value, unvisit) {\n    const schemaKey = isImmutable(value) ? value.get('schema') : value.schema;\n\n    if (!this.isSingleSchema && !schemaKey) {\n      return [value, true];\n    }\n\n    const id = isImmutable(value) ? value.get('id') : value.id;\n    const schema = this.isSingleSchema ? this.schema : this.schema[schemaKey];\n    return unvisit(id || value, schema);\n  }\n\n}\n\nclass UnionSchema extends PolymorphicSchema {\n  constructor(definition, schemaAttribute) {\n    if (!schemaAttribute) {\n      throw new Error('Expected option \"schemaAttribute\" not found on UnionSchema.');\n    }\n\n    super(definition, schemaAttribute);\n  }\n\n  normalize(input, parent, key, visit, addEntity, visitedEntities) {\n    return this.normalizeValue(input, parent, key, visit, addEntity, visitedEntities);\n  }\n\n  denormalize(input, unvisit) {\n    return this.denormalizeValue(input, unvisit);\n  }\n\n}\n\nclass ValuesSchema extends PolymorphicSchema {\n  normalize(input, parent, key, visit, addEntity, visitedEntities) {\n    return Object.keys(input).reduce((output, key, index) => {\n      const value = input[key];\n      return value !== undefined && value !== null ? Object.assign({}, output, {\n        [key]: this.normalizeValue(value, input, key, visit, addEntity, visitedEntities)\n      }) : output;\n    }, {});\n  }\n\n  denormalize(input, unvisit) {\n    let found = true;\n    return [Object.keys(input).reduce((output, key) => {\n      const entityOrId = input[key];\n      const [value, foundItem] = this.denormalizeValue(entityOrId, unvisit);\n\n      if (!foundItem) {\n        found = false;\n      }\n\n      return Object.assign({}, output, {\n        [key]: value\n      });\n    }, {}), found];\n  }\n\n}\n\nconst validateSchema = definition => {\n  const isArray = Array.isArray(definition);\n\n  if (isArray && definition.length > 1) {\n    throw new Error(\"Expected schema definition to be a single schema, but found \" + definition.length + \".\");\n  }\n\n  return definition[0];\n};\n\nconst getValues = input => Array.isArray(input) ? input : Object.keys(input).map(key => input[key]);\n\nconst normalize = (schema, input, parent, key, visit, addEntity, visitedEntities) => {\n  schema = validateSchema(schema);\n  const values = getValues(input); // Special case: Arrays pass *their* parent on to their children, since there\n  // is not any special information that can be gathered from themselves directly\n\n  return values.map((value, index) => visit(value, parent, key, schema, addEntity, visitedEntities));\n};\nconst denormalize = (schema, input, unvisit) => {\n  schema = validateSchema(schema);\n  let found = true;\n\n  if (input === undefined && schema) {\n    [, found] = unvisit(undefined, schema);\n  }\n\n  return [input && input.map ? input.map(entityOrId => unvisit(entityOrId, schema)).filter(([, foundItem]) => foundItem).map(([value]) => value) : input, found];\n};\nclass ArraySchema extends PolymorphicSchema {\n  normalize(input, parent, key, visit, addEntity, visitedEntities) {\n    const values = getValues(input);\n    return values.map((value, index) => this.normalizeValue(value, parent, key, visit, addEntity, visitedEntities)).filter(value => value !== undefined && value !== null);\n  }\n\n  denormalize(input, unvisit) {\n    let found = true;\n\n    if (input === undefined && this.schema) {\n      [, found] = unvisit(undefined, this.schema);\n    }\n\n    return [input && input.map ? input.map(entityOrId => this.denormalizeValue(entityOrId, unvisit)).filter(([, foundItem]) => foundItem).map(([value]) => value) : input, found];\n  }\n\n}\n\nconst normalize$1 = (schema, input, parent, key, visit, addEntity, visitedEntities) => {\n  const object = Object.assign({}, input);\n  Object.keys(schema).forEach(key => {\n    const localSchema = schema[key];\n    const value = visit(input[key], input, key, localSchema, addEntity, visitedEntities);\n\n    if (value === undefined || value === null) {\n      delete object[key];\n    } else {\n      object[key] = value;\n    }\n  });\n  return object;\n};\nconst denormalize$1 = (schema, input, unvisit) => {\n  if (isImmutable(input)) {\n    return denormalizeImmutable(schema, input, unvisit);\n  }\n\n  const object = Object.assign({}, input);\n  let found = true;\n  Object.keys(schema).forEach(key => {\n    const [item, foundItem] = unvisit(object[key], schema[key]);\n\n    if (object[key] != null) {\n      object[key] = item;\n    }\n\n    if (!foundItem) {\n      found = false;\n    }\n  });\n  return [object, found];\n};\nclass ObjectSchema {\n  constructor(definition) {\n    this.define(definition);\n  }\n\n  define(definition) {\n    this.schema = Object.keys(definition).reduce((entitySchema, key) => {\n      const schema = definition[key];\n      return Object.assign({}, entitySchema, {\n        [key]: schema\n      });\n    }, this.schema || {});\n  }\n\n  normalize(...args) {\n    return normalize$1(this.schema, ...args);\n  }\n\n  denormalize(...args) {\n    return denormalize$1(this.schema, ...args);\n  }\n\n}\n\nconst visit = (value, parent, key, schema, addEntity, visitedEntities) => {\n  if (typeof value !== 'object' || !value) {\n    return value;\n  }\n\n  if (typeof schema === 'object' && (!schema.normalize || typeof schema.normalize !== 'function')) {\n    const method = Array.isArray(schema) ? normalize : normalize$1;\n    return method(schema, value, parent, key, visit, addEntity, visitedEntities);\n  }\n\n  return schema.normalize(value, parent, key, visit, addEntity, visitedEntities);\n};\n\nconst addEntities = entities => (schema, processedEntity, value, parent, key) => {\n  const schemaKey = schema.key;\n  const id = schema.getId(value, parent, key);\n\n  if (!(schemaKey in entities)) {\n    entities[schemaKey] = {};\n  }\n\n  const existingEntity = entities[schemaKey][id];\n\n  if (existingEntity) {\n    entities[schemaKey][id] = schema.merge(existingEntity, processedEntity);\n  } else {\n    entities[schemaKey][id] = processedEntity;\n  }\n};\n\nconst schema = {\n  Array: ArraySchema,\n  Entity: EntitySchema,\n  Object: ObjectSchema,\n  Union: UnionSchema,\n  Values: ValuesSchema\n};\nconst normalize$2 = (input, schema) => {\n  if (!input || typeof input !== 'object') {\n    throw new Error(\"Unexpected input given to normalize. Expected type to be \\\"object\\\", found \\\"\" + (input === null ? 'null' : typeof input) + \"\\\".\");\n  }\n\n  const entities = {};\n  const addEntity = addEntities(entities);\n  const visitedEntities = {};\n  const result = visit(input, input, null, schema, addEntity, visitedEntities);\n  return {\n    entities,\n    result\n  };\n};\n\nconst unvisitEntity = (id, schema, unvisit, getEntity, cache) => {\n  const entity = getEntity(id, schema);\n\n  if (typeof entity !== 'object' || entity === null) {\n    return [entity, false];\n  }\n\n  if (!cache[schema.key]) {\n    cache[schema.key] = {};\n  }\n\n  let found = true;\n\n  if (!cache[schema.key][id]) {\n    // Ensure we don't mutate it non-immutable objects\n    const entityCopy = isImmutable(entity) ? entity : Object.assign({}, entity); // Need to set this first so that if it is referenced further within the\n    // denormalization the reference will already exist.\n\n    cache[schema.key][id] = entityCopy;\n    [cache[schema.key][id], found] = schema.denormalize(entityCopy, unvisit);\n  }\n\n  return [cache[schema.key][id], found];\n};\n\nconst getUnvisit = entities => {\n  const cache = {};\n  const getEntity = getEntities(entities);\n  return function unvisit(input, schema) {\n    if (typeof schema === 'object' && (!schema.denormalize || typeof schema.denormalize !== 'function')) {\n      const method = Array.isArray(schema) ? denormalize : denormalize$1;\n      return method(schema, input, unvisit);\n    } // null is considered intentional, thus always 'found' as true\n\n\n    if (input === null) {\n      return [input, true];\n    }\n\n    if (schema instanceof EntitySchema) {\n      // unvisitEntity just can't handle undefined\n      if (input === undefined) {\n        return [input, false];\n      }\n\n      return unvisitEntity(input, schema, unvisit, getEntity, cache);\n    }\n\n    if (typeof schema.denormalize === 'function') {\n      return schema.denormalize(input, unvisit);\n    }\n\n    return [input, true];\n  };\n};\n\nconst getEntities = entities => {\n  const isImmutable$1 = isImmutable(entities);\n  return (entityOrId, schema) => {\n    const schemaKey = schema.key;\n\n    if (typeof entityOrId === 'object') {\n      return entityOrId;\n    }\n\n    if (isImmutable$1) {\n      return entities.getIn([schemaKey, entityOrId.toString()]);\n    }\n\n    return entities[schemaKey] && entities[schemaKey][entityOrId];\n  };\n};\n\nconst denormalize$2 = (input, schema, entities) => {\n  if (typeof input !== 'undefined') {\n    return getUnvisit(entities)(input, schema);\n  }\n\n  return [undefined, false];\n};\n\nexport { denormalize$2 as denormalize, normalize$2 as normalize, schema };\n"]},"metadata":{},"sourceType":"module"}