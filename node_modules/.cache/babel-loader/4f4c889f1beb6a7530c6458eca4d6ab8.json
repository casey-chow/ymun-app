{"ast":null,"code":"export function isDeleteShape(shape) {\n  return shape.type === 'delete';\n}\nexport function isEntity(schema) {\n  return schema.key !== undefined;\n} // Legacy:","map":{"version":3,"sources":["../../src/resource/types.ts"],"names":["shape","schema"],"mappings":"AAiEA,OAAO,SAAA,aAAA,CAAA,KAAA,EAE2B;AAChC,SAAOA,KAAK,CAALA,IAAAA,KAAP,QAAA;AACD;AAqBD,OAAO,SAAA,QAAA,CAAA,MAAA,EAA4D;AACjE,SAAQC,MAAD,CAAA,GAACA,KAAR,SAAA;EAGF","sourcesContent":["import { schemas, Schema } from './normal';\nimport {\n  SchemaList as SchemaListLegacy,\n  SchemaDetail as SchemaDetailLegacy,\n} from './schemaLegacy';\nimport { FetchOptions } from '~/types';\n\n/** Defines the shape of a network request */\nexport interface FetchShape<\n  S extends Schema,\n  Params extends Readonly<object> = Readonly<object>,\n  Body extends Readonly<object | string> | void =\n    | Readonly<object | string>\n    | undefined\n> {\n  readonly type: 'read' | 'mutate' | 'delete';\n  fetch(params: Params, body: Body): Promise<any>;\n  getFetchKey(params: Params): string;\n  readonly schema: S;\n  readonly options?: FetchOptions;\n}\n\nexport type SchemaFromShape<\n  F extends FetchShape<any, any, any>\n> = F extends FetchShape<infer S, any, any> ? S : never;\nexport type ParamsFromShape<\n  F extends FetchShape<any, any, any>\n> = F extends FetchShape<any, infer P, any> ? P : never;\nexport type BodyFromShape<\n  F extends FetchShape<any, any, any>\n> = F extends FetchShape<any, any, infer B> ? B : never;\n\n/** Purges a value from the server */\nexport interface DeleteShape<\n  S extends schemas.Entity,\n  Params extends Readonly<object> = Readonly<object>,\n  Body extends Readonly<object | string> | void = undefined\n> extends FetchShape<S, Params, Body> {\n  readonly type: 'delete';\n}\n\n/** To change values on the server */\nexport interface MutateShape<\n  S extends Schema,\n  Params extends Readonly<object> = Readonly<object>,\n  Body extends Readonly<object | string> | void =\n    | Readonly<object | string>\n    | undefined\n> extends FetchShape<S, Params, Body> {\n  readonly type: 'mutate';\n  fetch(\n    params: Params,\n    body: Body,\n  ): Promise<object | string | number | boolean>;\n}\n\n/** For retrieval requests */\nexport interface ReadShape<\n  S extends Schema,\n  Params extends Readonly<object> = Readonly<object>\n> extends FetchShape<S, Params, undefined> {\n  readonly type: 'read';\n  fetch(params: Params): Promise<object | string | number | boolean>;\n}\n\nexport function isDeleteShape(\n  shape: FetchShape<any, any, any>,\n): shape is DeleteShape<any, any> {\n  return shape.type === 'delete';\n}\n\nexport type ResultShape<RS> = RS extends { schema: infer U } ? U : never;\nexport type SelectReturn<RS> = RS extends {\n  select: (...args: any[]) => infer U;\n}\n  ? U\n  : never;\nexport type AlwaysSelect<RS> = NonNullable<SelectReturn<RS>>;\nexport type ParamArg<RS> = RS extends {\n  getFetchKey: (params: infer U) => any;\n}\n  ? U\n  : never;\nexport type BodyArg<RS> = RS extends {\n  fetch: (url: any, body: infer U) => any;\n}\n  ? U\n  : never;\nexport type RequestResource<RS> = SchemaOf<ResultShape<RS>>;\n\nexport function isEntity(schema: Schema): schema is schemas.Entity {\n  return (schema as any).key !== undefined;\n}\n\n// Legacy:\nexport type SchemaOfCore<T> = T extends SchemaListLegacy<infer R>\n  ? R[]\n  : T extends SchemaDetailLegacy<infer R>\n  ? R\n  : never;\n\nexport type SchemaOf<S> = Extract<S, schemas.Entity> extends never\n  ? (Extract<S, schemas.Entity[]> extends never\n      ? SchemaOfCore<S>\n      : SchemaOfCore<Extract<S, schemas.Entity[]>>)\n  : SchemaOfCore<Extract<S, schemas.Entity>>;\n"]},"metadata":{},"sourceType":"module"}