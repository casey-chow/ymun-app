{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport { schemas } from \"../../resource\";\nimport { isEntity } from \"../../resource/types\";\n/**\n * Build the result parameter to denormalize from schema alone.\n * Tries to compute the entity ids from params.\n */\n\nexport default function buildInferredResults(schema, params) {\n  if (isEntity(schema)) {\n    var id = schema.getId(params, undefined, ''); // Was unable to infer the entity's primary key from params\n\n    if (id === undefined || id === '') return null;\n    return id;\n  }\n\n  if (schema instanceof schemas.Array || Array.isArray(schema) || schema instanceof schemas.Values) {\n    // array schemas should not be inferred because they're likely to be missing many members\n    // Values cannot be inferred because they have aribtrary keys\n    return null;\n  }\n\n  if (schema instanceof schemas.Union) {\n    var discriminatedSchema = schema.inferSchema(params, undefined, ''); // Was unable to infer the entity's schema from params\n\n    if (discriminatedSchema === undefined) return null;\n    return {\n      id: buildInferredResults(discriminatedSchema, params),\n      schema: schema.getSchemaAttribute(params, parent, '')\n    };\n  }\n\n  var o = schema instanceof schemas.Object ? schema.schema : schema;\n  var resultObject = {};\n\n  for (var k in o) {\n    if (!isSchema(o[k])) {\n      resultObject[k] = o[k];\n    } else {\n      var results = buildInferredResults(o[k], params);\n      if (!results) return null;\n      resultObject[k] = results;\n    }\n  }\n\n  return resultObject;\n}\n\nfunction isSchema(candidate) {\n  // TODO: improve detection\n  return _typeof(candidate) === 'object' && candidate !== null;\n}","map":{"version":3,"sources":["../../../src/state/selectors/buildInferredResultsLegacy.ts"],"names":["isEntity","id","schema","schemas","Array","discriminatedSchema","buildInferredResults","o","resultObject","isSchema","results","candidate"],"mappings":";AAAA,SAAA,OAAA,QAAA,gBAAA;AACA,SAAA,QAAA,QAAA,sBAAA;AAEA;;;;;AAIA,eAAe,SAAA,oBAAA,CAAA,MAAA,EAAA,MAAA,EAGmC;AAChD,MAAIA,QAAQ,CAAZ,MAAY,CAAZ,EAAsB;AACpB,QAAMC,EAAE,GAAGC,MAAM,CAANA,KAAAA,CAAAA,MAAAA,EAAAA,SAAAA,EADS,EACTA,CAAX,CADoB,CAEpB;;AACA,QAAID,EAAE,KAAFA,SAAAA,IAAoBA,EAAE,KAA1B,EAAA,EAAmC,OAAA,IAAA;AACnC,WAAA,EAAA;AACD;;AACD,MACEC,MAAM,YAAYC,OAAO,CAAzBD,KAAAA,IACAE,KAAK,CAALA,OAAAA,CADAF,MACAE,CADAF,IAEAA,MAAM,YAAYC,OAAO,CAH3B,MAAA,EAIE;AACA;AACA;AACA,WAAA,IAAA;AACD;;AACD,MAAID,MAAM,YAAYC,OAAO,CAA7B,KAAA,EAAqC;AACnC,QAAME,mBAAmB,GAAGH,MAAM,CAANA,WAAAA,CAAAA,MAAAA,EAAAA,SAAAA,EADO,EACPA,CAA5B,CADmC,CAEnC;;AACA,QAAIG,mBAAmB,KAAvB,SAAA,EAAuC,OAAA,IAAA;AACvC,WAAO;AACLJ,MAAAA,EAAE,EAAEK,oBAAoB,CAAA,mBAAA,EADnB,MACmB,CADnB;AAELJ,MAAAA,MAAM,EAAEA,MAAM,CAANA,kBAAAA,CAAAA,MAAAA,EAAAA,MAAAA,EAAAA,EAAAA;AAFH,KAAP;AAID;;AACD,MAAMK,CAAC,GAAGL,MAAM,YAAYC,OAAO,CAAzBD,MAAAA,GAAoCA,MAAD,CAAnCA,MAAAA,GAAV,MAAA;AACA,MAAMM,YAAY,GAAlB,EAAA;;AACA,OAAK,IAAL,CAAA,IAAA,CAAA,EAAmB;AACjB,QAAI,CAACC,QAAQ,CAACF,CAAC,CAAf,CAAe,CAAF,CAAb,EAAqB;AACnBC,MAAAA,YAAY,CAAZA,CAAY,CAAZA,GAAkBD,CAAC,CAAnBC,CAAmB,CAAnBA;AADF,KAAA,MAEO;AACL,UAAME,OAAO,GAAGJ,oBAAoB,CAACC,CAAC,CAAF,CAAE,CAAF,EAApC,MAAoC,CAApC;AACA,UAAI,CAAJ,OAAA,EAAc,OAAA,IAAA;AACdC,MAAAA,YAAY,CAAZA,CAAY,CAAZA,GAAAA,OAAAA;AACD;AACF;;AACD,SAAA,YAAA;AACD;;AAED,SAAA,QAAA,CAAA,SAAA,EAAkC;AAChC;AACA,SAAO,OAAA,CAAA,SAAA,CAAA,KAAA,QAAA,IAAiCG,SAAS,KAAjD,IAAA;AACD","sourcesContent":["import { Normalize, Schema, schemas } from '~/resource';\nimport { isEntity } from '~/resource/types';\n\n/**\n * Build the result parameter to denormalize from schema alone.\n * Tries to compute the entity ids from params.\n */\nexport default function buildInferredResults<\n  Params extends Readonly<object>,\n  S extends Schema\n>(schema: S, params: Params): Normalize<S> | null {\n  if (isEntity(schema)) {\n    const id = schema.getId(params, undefined, '');\n    // Was unable to infer the entity's primary key from params\n    if (id === undefined || id === '') return null;\n    return id as any;\n  }\n  if (\n    schema instanceof schemas.Array ||\n    Array.isArray(schema) ||\n    schema instanceof schemas.Values\n  ) {\n    // array schemas should not be inferred because they're likely to be missing many members\n    // Values cannot be inferred because they have aribtrary keys\n    return null;\n  }\n  if (schema instanceof schemas.Union) {\n    const discriminatedSchema = schema.inferSchema(params, undefined, '');\n    // Was unable to infer the entity's schema from params\n    if (discriminatedSchema === undefined) return null;\n    return {\n      id: buildInferredResults(discriminatedSchema, params),\n      schema: schema.getSchemaAttribute(params, parent, ''),\n    } as any;\n  }\n  const o = schema instanceof schemas.Object ? (schema as any).schema : schema;\n  const resultObject = {} as any;\n  for (const k in o) {\n    if (!isSchema(o[k])) {\n      resultObject[k] = o[k];\n    } else {\n      const results = buildInferredResults(o[k], params);\n      if (!results) return null;\n      resultObject[k] = results;\n    }\n  }\n  return resultObject;\n}\n\nfunction isSchema(candidate: any) {\n  // TODO: improve detection\n  return typeof candidate === 'object' && candidate !== null;\n}\n"]},"metadata":{},"sourceType":"module"}