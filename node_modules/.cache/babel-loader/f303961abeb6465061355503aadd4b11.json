{"ast":null,"code":"import { useMemo } from 'react';\nimport getEntityPath from './getEntityPath';\nimport useDenormalizedLegacy from './useDenormalizedLegacy';\nexport default function useSchemaSelect(_ref, params, state) {\n  var schema = _ref.schema,\n      getFetchKey = _ref.getFetchKey;\n  var denormalized = useDenormalizedLegacy({\n    schema: schema,\n    getFetchKey: getFetchKey\n  }, params, state); // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  var getItemsFromResults = useMemo(function () {\n    return resultFinderFromSchema(schema);\n  }, []);\n  var output = useMemo(function () {\n    return getItemsFromResults && denormalized ? getItemsFromResults(denormalized) : denormalized;\n  }, [denormalized, getItemsFromResults]);\n  if (output === undefined) return null;\n  return output;\n} // TODO: there should honestly be a way to use the pre-existing normalizr object\n// to not even need this implementation\n\nexport function resultFinderFromSchema(schema) {\n  var path = getEntityPath(schema);\n  if (path === false) throw new Error('Schema invalid - no path to entity found');\n  if (path.length === 0) return null;\n  return function (results) {\n    var cur = results;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = path[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var p = _step.value;\n        cur = cur[p];\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return cur;\n  };\n}","map":{"version":3,"sources":["../../../src/state/selectors/useSchemaSelect.ts"],"names":["schema","getFetchKey","denormalized","useDenormalizedLegacy","getItemsFromResults","useMemo","resultFinderFromSchema","output","path","getEntityPath","cur","p"],"mappings":"AAAA,SAAA,OAAA,QAAA,OAAA;AAIA,OAAA,aAAA,MAAA,iBAAA;AACA,OAAA,qBAAA,MAAA,yBAAA;AAEA,eAAe,SAAA,eAAA,CAAA,IAAA,EAAA,MAAA,EAAA,KAAA,EAOyD;AAAA,MAHpEA,MAGoE,GAAA,IAAA,CAHpEA,MAGoE;AAAA,MAH5DC,WAG4D,GAAA,IAAA,CAH5DA,WAG4D;AACtE,MAAMC,YAAiB,GAAGC,qBAAqB,CAC7C;AAAEH,IAAAA,MAAM,EAAR,MAAA;AAAUC,IAAAA,WAAW,EAAXA;AAAV,GAD6C,EAAA,MAAA,EADuB,KACvB,CAA/C,CADsE,CAMtE;;AACA,MAAMG,mBAAmB,GAAGC,OAAO,CAAC,YAAA;AAAA,WAAMC,sBAAsB,CAA5B,MAA4B,CAA5B;AAAD,GAAA,EAAnC,EAAmC,CAAnC;AACA,MAAMC,MAAM,GAAGF,OAAO,CACpB,YAAA;AAAA,WACED,mBAAmB,IAAnBA,YAAAA,GACIA,mBAAmB,CADvBA,YACuB,CADvBA,GADF,YAAA;AADoB,GAAA,EAKpB,CAAA,YAAA,EALF,mBAKE,CALoB,CAAtB;AAOA,MAAIG,MAAM,KAAV,SAAA,EAA0B,OAAA,IAAA;AAC1B,SAAA,MAAA;EAGF;AACA;;AACA,OAAO,SAAA,sBAAA,CAAA,MAAA,EAEmC;AACxC,MAAMC,IAAI,GAAGC,aAAa,CAA1B,MAA0B,CAA1B;AACA,MAAID,IAAI,KAAR,KAAA,EACE,MAAM,IAAA,KAAA,CAAN,0CAAM,CAAN;AACF,MAAIA,IAAI,CAAJA,MAAAA,KAAJ,CAAA,EAAuB,OAAA,IAAA;AACvB,SAAO,UAAA,OAAA,EAAW;AAChB,QAAIE,GAAG,GAAP,OAAA;AADgB,QAAA,yBAAA,GAAA,IAAA;AAAA,QAAA,iBAAA,GAAA,KAAA;AAAA,QAAA,cAAA,GAAA,SAAA;;AAAA,QAAA;AAEhB,WAAA,IAAA,SAAA,GAAgBF,IAAhB,CAAA,MAAA,CAAA,QAAA,CAAgBA,EAAhB,EAAA,KAAA,EAAA,EAAA,yBAAA,GAAA,CAAA,KAAA,GAAA,SAAA,CAAA,IAAA,EAAA,EAAA,IAAA,CAAA,EAAA,yBAAA,GAAA,IAAA,EAAsB;AAAA,YAAXG,CAAW,GAAA,KAAA,CAAA,KAAA;AACpBD,QAAAA,GAAG,GAAGA,GAAG,CAATA,CAAS,CAATA;AACD;AAJe,KAAA,CAAA,OAAA,GAAA,EAAA;AAAA,MAAA,iBAAA,GAAA,IAAA;AAAA,MAAA,cAAA,GAAA,GAAA;AAAA,KAAA,SAAA;AAAA,UAAA;AAAA,YAAA,CAAA,yBAAA,IAAA,SAAA,CAAA,QAAA,CAAA,IAAA,IAAA,EAAA;AAAA,UAAA,SAAA,CAAA,QAAA,CAAA;AAAA;AAAA,OAAA,SAAA;AAAA,YAAA,iBAAA,EAAA;AAAA,gBAAA,cAAA;AAAA;AAAA;AAAA;;AAKhB,WAAA,GAAA;AALF,GAAA;AAOD","sourcesContent":["import { useMemo } from 'react';\nimport { State } from '~/types';\nimport { SchemaOf, ReadShape } from '~/resource/types';\nimport { Schema } from '~/resource/normal';\nimport getEntityPath from './getEntityPath';\nimport useDenormalizedLegacy from './useDenormalizedLegacy';\n\nexport default function useSchemaSelect<\n  Params extends Readonly<object>,\n  S extends Schema\n>(\n  { schema, getFetchKey }: Pick<ReadShape<S, Params>, 'schema' | 'getFetchKey'>,\n  params: Params | null,\n  state: State<any>,\n): typeof params extends null ? null : (SchemaOf<typeof schema> | null) {\n  const denormalized: any = useDenormalizedLegacy(\n    { schema, getFetchKey },\n    params,\n    state,\n  );\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const getItemsFromResults = useMemo(() => resultFinderFromSchema(schema), []);\n  const output = useMemo(\n    () =>\n      getItemsFromResults && denormalized\n        ? getItemsFromResults(denormalized)\n        : denormalized,\n    [denormalized, getItemsFromResults],\n  );\n  if (output === undefined) return null as any;\n  return output;\n}\n\n// TODO: there should honestly be a way to use the pre-existing normalizr object\n// to not even need this implementation\nexport function resultFinderFromSchema<S extends Schema>(\n  schema: S,\n): null | ((results: any) => SchemaOf<S>) {\n  const path = getEntityPath(schema);\n  if (path === false)\n    throw new Error('Schema invalid - no path to entity found');\n  if (path.length === 0) return null;\n  return results => {\n    let cur = results;\n    for (const p of path) {\n      cur = cur[p];\n    }\n    return cur;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}