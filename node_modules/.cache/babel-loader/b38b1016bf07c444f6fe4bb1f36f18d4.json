{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useContext, useRef, useCallback } from 'react';\nimport { isDeleteShape } from \"../../resource\";\nimport { DispatchContext } from \"../context\";\nvar SHAPE_TYPE_TO_RESPONSE_TYPE = {\n  read: 'rest-hooks/receive',\n  mutate: 'rest-hooks/rpc',\n  \"delete\": 'rest-hooks/purge'\n};\n/** Build an imperative dispatcher to issue network requests. */\n\nexport default function useFetcher(fetchShape) {\n  var throttle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var dispatch = useContext(DispatchContext); // we just want the current values when we dispatch, so\n  // box the shape in a ref to make react-hooks/exhaustive-deps happy\n\n  var shapeRef = useRef(fetchShape);\n  shapeRef.current = fetchShape;\n  var fetchDispatcher = useCallback(function (params, body, updateParams) {\n    var _shapeRef$current = shapeRef.current,\n        fetch = _shapeRef$current.fetch,\n        schema = _shapeRef$current.schema,\n        type = _shapeRef$current.type,\n        getFetchKey = _shapeRef$current.getFetchKey,\n        options = _shapeRef$current.options;\n    var responseType = SHAPE_TYPE_TO_RESPONSE_TYPE[type];\n    var key = getFetchKey(params);\n    var identifier = isDeleteShape(shapeRef.current) ? shapeRef.current.schema.getId(params) : key;\n    var resolve = 0;\n    var reject = 0;\n    var promise = new Promise(function (a, b) {\n      resolve = a;\n      reject = b;\n    });\n    var meta = {\n      schema: schema,\n      responseType: responseType,\n      url: identifier,\n      throttle: throttle,\n      options: options,\n      resolve: resolve,\n      reject: reject\n    };\n\n    if (updateParams) {\n      meta.updaters = updateParams.reduce(function (accumulator, _ref) {\n        var _ref2 = _slicedToArray(_ref, 3),\n            toShape = _ref2[0],\n            toParams = _ref2[1],\n            updateFn = _ref2[2];\n\n        return _objectSpread(_defineProperty({}, toShape.getFetchKey(toParams), updateFn), accumulator);\n      }, {});\n    }\n\n    dispatch({\n      type: 'rest-hooks/fetch',\n      payload: function payload() {\n        return fetch(params, body);\n      },\n      meta: meta\n    });\n    return promise;\n  }, [dispatch, throttle]); // any is due to the ternary that we don't want to deal with in our implementation\n\n  return fetchDispatcher;\n}","map":{"version":3,"sources":["../../../src/react-integration/hooks/useFetcher.ts"],"names":["SHAPE_TYPE_TO_RESPONSE_TYPE","read","mutate","throttle","dispatch","useContext","shapeRef","useRef","fetchDispatcher","useCallback","fetch","schema","type","getFetchKey","options","responseType","key","identifier","isDeleteShape","resolve","reject","promise","meta","url","toShape","toParams","updateFn","payload"],"mappings":"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","sourcesContent":["import { useContext, useRef, useCallback } from 'react';\n\nimport { FetchAction, UpdateFunction } from '~/types';\nimport {\n  FetchShape,\n  DeleteShape,\n  Schema,\n  isDeleteShape,\n  SchemaFromShape,\n  ParamsFromShape,\n  BodyFromShape,\n} from '~/resource';\nimport { DispatchContext } from '~/react-integration/context';\n\nconst SHAPE_TYPE_TO_RESPONSE_TYPE: Record<\n  FetchShape<any, any, any>['type'],\n  'rest-hooks/receive' | 'rest-hooks/rpc' | 'rest-hooks/purge'\n> = {\n  read: 'rest-hooks/receive',\n  mutate: 'rest-hooks/rpc',\n  delete: 'rest-hooks/purge',\n};\n\ntype OptimisticUpdateParams<\n  SourceSchema extends Schema,\n  DestShape extends FetchShape<any, any, any>\n> = [\n  DestShape,\n  ParamsFromShape<DestShape>,\n  UpdateFunction<SourceSchema, SchemaFromShape<DestShape>>,\n];\n\n/** Build an imperative dispatcher to issue network requests. */\nexport default function useFetcher<\n  Shape extends FetchShape<\n    Schema,\n    Readonly<object>,\n    Readonly<object | string> | void\n  >\n>(\n  fetchShape: Shape,\n  throttle = false,\n): Shape extends DeleteShape<any, any, any>\n  ? (params: ParamsFromShape<Shape>, body: BodyFromShape<Shape>) => Promise<any>\n  : <\n      UpdateParams extends OptimisticUpdateParams<\n        SchemaFromShape<Shape>,\n        FetchShape<any, any, any>\n      >[]\n    >(\n      params: ParamsFromShape<Shape>,\n      body: BodyFromShape<Shape>,\n      updateParams?: UpdateParams | undefined,\n    ) => Promise<any> {\n  const dispatch = useContext(DispatchContext);\n\n  // we just want the current values when we dispatch, so\n  // box the shape in a ref to make react-hooks/exhaustive-deps happy\n  const shapeRef = useRef(fetchShape);\n  shapeRef.current = fetchShape;\n\n  const fetchDispatcher = useCallback(\n    (\n      params: ParamsFromShape<Shape>,\n      body: BodyFromShape<Shape>,\n      updateParams?:\n        | OptimisticUpdateParams<\n            SchemaFromShape<Shape>,\n            FetchShape<any, any, any>\n          >[]\n        | undefined,\n    ) => {\n      const { fetch, schema, type, getFetchKey, options } = shapeRef.current;\n      const responseType = SHAPE_TYPE_TO_RESPONSE_TYPE[type];\n\n      const key = getFetchKey(params);\n      const identifier = isDeleteShape(shapeRef.current)\n        ? shapeRef.current.schema.getId(params)\n        : key;\n      let resolve: (value?: any | PromiseLike<any>) => void = 0 as any;\n      let reject: (reason?: any) => void = 0 as any;\n      const promise = new Promise<any>((a, b) => {\n        [resolve, reject] = [a, b];\n      });\n      const meta: FetchAction['meta'] = {\n        schema,\n        responseType,\n        url: identifier,\n        throttle,\n        options,\n        resolve,\n        reject,\n      };\n\n      if (updateParams) {\n        meta.updaters = updateParams.reduce(\n          (accumulator: object, [toShape, toParams, updateFn]) => ({\n            [toShape.getFetchKey(toParams)]: updateFn,\n            ...accumulator,\n          }),\n          {},\n        );\n      }\n\n      dispatch({\n        type: 'rest-hooks/fetch',\n        payload: () => fetch(params, body),\n        meta,\n      });\n      return promise;\n    },\n    [dispatch, throttle],\n  );\n  // any is due to the ternary that we don't want to deal with in our implementation\n  return fetchDispatcher as any;\n}\n"]},"metadata":{},"sourceType":"module"}