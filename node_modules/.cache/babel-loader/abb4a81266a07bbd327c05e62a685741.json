{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport isMergeableObject from './isMergeable'; // Note: the return types are technically not as strict as they could be; but this is sufficient for our local usage.\n\n/**\n * Deep merge two objects or arrays. Uses static merge function if exists.\n */\n\nexport default function mergeDeepCopy(target, source) {\n  var sourceIsArray = Array.isArray(source);\n  var targetIsArray = Array.isArray(target);\n  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n  var Static = source && source.constructor;\n\n  if (target && Static && isMergeable(Static)) {\n    if (isMergeable(target.constructor)) {\n      return Static.merge(target, source);\n    } else {\n      return source;\n    }\n  } else if (isMergeableObject(source)) {\n    // target and source are mergeable\n    if (isMergeableObject(target) && sourceAndTargetTypesMatch) {\n      var destination = targetIsArray ? _toConsumableArray(target) : _objectSpread({}, target);\n      Object.keys(source).forEach(function (key) {\n        destination[key] = mergeDeepCopy(destination[key], source[key]);\n      });\n      return destination; // not mergeable, but still need to clone source\n    } else {\n      return mergeDeepCopy(sourceIsArray ? [] : {}, source);\n    }\n  } else if (source === undefined) {\n    return target;\n  }\n\n  return source;\n}\n\nfunction isMergeable(constructor) {\n  return constructor && typeof constructor.merge === 'function';\n}","map":{"version":3,"sources":["../../../src/state/merge/mergeDeepCopy.ts"],"names":["sourceIsArray","Array","targetIsArray","sourceAndTargetTypesMatch","Static","source","target","isMergeable","isMergeableObject","destination","Object","mergeDeepCopy","constructor"],"mappings":";;AAAA,OAAA,iBAAA,MAAA,eAAA,C,CAEA;;AAEA;;;;AAGA,eAAe,SAAA,aAAA,CAAA,MAAA,EAAA,MAAA,EAAgE;AAC7E,MAAMA,aAAa,GAAGC,KAAK,CAALA,OAAAA,CAAtB,MAAsBA,CAAtB;AACA,MAAMC,aAAa,GAAGD,KAAK,CAALA,OAAAA,CAAtB,MAAsBA,CAAtB;AACA,MAAME,yBAAyB,GAAGH,aAAa,KAA/C,aAAA;AACA,MAAMI,MAAsB,GAAGC,MAAM,IAAKA,MAAD,CAAzC,WAAA;;AAEA,MAAIC,MAAM,IAANA,MAAAA,IAAoBC,WAAW,CAAnC,MAAmC,CAAnC,EAA6C;AAC3C,QAAIA,WAAW,CAAED,MAAD,CAAhB,WAAe,CAAf,EAA8C;AAC5C,aAAOF,MAAM,CAANA,KAAAA,CAAAA,MAAAA,EAAP,MAAOA,CAAP;AADF,KAAA,MAEO;AACL,aAAA,MAAA;AACD;AALH,GAAA,MAMO,IAAII,iBAAiB,CAArB,MAAqB,CAArB,EAA+B;AACpC;AACA,QAAIA,iBAAiB,CAAjBA,MAAiB,CAAjBA,IAAJ,yBAAA,EAA4D;AAC1D,UAAMC,WAAgB,GAAGP,aAAa,GAAA,kBAAA,CAAA,MAAA,CAAA,GAAA,aAAA,CAAA,EAAA,EAAtC,MAAsC,CAAtC;AAGAQ,MAAAA,MAAM,CAANA,IAAAA,CAAAA,MAAAA,EAAAA,OAAAA,CAA4B,UAAA,GAAA,EAAO;AACjCD,QAAAA,WAAW,CAAXA,GAAW,CAAXA,GAAmBE,aAAa,CAC9BF,WAAW,CADmB,GACnB,CADmB,EAE7BJ,MAAD,CAFFI,GAEE,CAF8B,CAAhCA;AADFC,OAAAA;AAMA,aAV0D,WAU1D,CAV0D,CAW1D;AAXF,KAAA,MAYO;AACL,aAAOC,aAAa,CAACX,aAAa,GAAA,EAAA,GAAd,EAAA,EAApB,MAAoB,CAApB;AACD;AAhBI,GAAA,MAiBA,IAAIK,MAAM,KAAV,SAAA,EAA0B;AAC/B,WAAA,MAAA;AACD;;AACD,SAAA,MAAA;AACD;;AASD,SAAA,WAAA,CAAA,WAAA,EAA6E;AAC3E,SAAOO,WAAW,IAAI,OAAOA,WAAW,CAAlB,KAAA,KAAtB,UAAA;AACD","sourcesContent":["import isMergeableObject from './isMergeable';\n\n// Note: the return types are technically not as strict as they could be; but this is sufficient for our local usage.\n\n/**\n * Deep merge two objects or arrays. Uses static merge function if exists.\n */\nexport default function mergeDeepCopy<T1, T2>(target: T1, source: T2): T1 & T2 {\n  const sourceIsArray = Array.isArray(source);\n  const targetIsArray = Array.isArray(target);\n  const sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n  const Static: StaticType<T2> = source && (source as any).constructor;\n\n  if (target && Static && isMergeable(Static)) {\n    if (isMergeable((target as any).constructor)) {\n      return Static.merge(target, source) as any;\n    } else {\n      return source as any;\n    }\n  } else if (isMergeableObject(source)) {\n    // target and source are mergeable\n    if (isMergeableObject(target) && sourceAndTargetTypesMatch) {\n      const destination: any = targetIsArray\n        ? [...(target as any)]\n        : { ...target };\n      Object.keys(source).forEach(key => {\n        destination[key] = mergeDeepCopy(\n          destination[key],\n          (source as any)[key],\n        );\n      });\n      return destination;\n      // not mergeable, but still need to clone source\n    } else {\n      return mergeDeepCopy(sourceIsArray ? [] : ({} as any), source as any);\n    }\n  } else if (source === undefined) {\n    return target as any;\n  }\n  return source as any;\n}\n\ntype StaticType<T> = T extends { constructor: infer U } ? U : undefined;\n\ninterface MergeableStatic<T> {\n  new (): T;\n  merge(a: T, b: T): T;\n}\n\nfunction isMergeable<T>(constructor: any): constructor is MergeableStatic<T> {\n  return constructor && typeof constructor.merge === 'function';\n}\n"]},"metadata":{},"sourceType":"module"}