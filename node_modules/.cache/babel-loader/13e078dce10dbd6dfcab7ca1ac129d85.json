{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _memoize from \"lodash/memoize\";\nimport RIC from './RIC';\n/** Handles all async network dispatches\n *\n * Dedupes concurrent requests by keeping track of all fetches in flight\n * and returning existing promises for requests already in flight.\n *\n * Interfaces with store via a redux-compatible middleware.\n */\n\nvar NetworkManager =\n/*#__PURE__*/\nfunction () {\n  function NetworkManager() {\n    var dataExpiryLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 60000;\n    var errorExpiryLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n\n    _classCallCheck(this, NetworkManager);\n\n    _defineProperty(this, \"fetched\", {});\n\n    _defineProperty(this, \"resolvers\", {});\n\n    _defineProperty(this, \"rejectors\", {});\n\n    _defineProperty(this, \"dataExpiryLength\", void 0);\n\n    _defineProperty(this, \"errorExpiryLength\", void 0);\n\n    _defineProperty(this, \"getMiddleware\", _memoize(function () {\n      var _this = this;\n\n      return function (_ref) {\n        var dispatch = _ref.dispatch;\n        return function (next) {\n          return function (action) {\n            switch (action.type) {\n              case 'rest-hooks/fetch':\n                _this.handleFetch(action, dispatch);\n\n                return Promise.resolve();\n\n              case 'rest-hooks/purge':\n              case 'rest-hooks/rpc':\n              case 'rest-hooks/receive':\n                // only receive after new state is computed\n                return next(action).then(function () {\n                  if (action.meta.url in _this.fetched) {\n                    _this.handleReceive(action);\n                  }\n                });\n\n              case 'rest-hooks/reset':\n                _this.cleanup();\n\n                return next(action);\n\n              default:\n                return next(action);\n            }\n          };\n        };\n      };\n    }));\n\n    this.dataExpiryLength = dataExpiryLength;\n    this.errorExpiryLength = errorExpiryLength;\n  }\n  /** Ensures all promises are completed by rejecting remaining. */\n\n\n  _createClass(NetworkManager, [{\n    key: \"cleanup\",\n    value: function cleanup() {\n      for (var _k in this.rejectors) {\n        var error = new Error('Cleaning up Network Manager');\n        error.name = 'CLEANUP';\n\n        this.rejectors[_k](error);\n      }\n    }\n    /** Clear promise state for a given url */\n\n  }, {\n    key: \"clear\",\n    value: function clear(url) {\n      delete this.resolvers[url];\n      delete this.rejectors[url];\n      delete this.fetched[url];\n    }\n    /** Called when middleware intercepts 'rest-hooks/fetch' action.\n     *\n     * Will then start a promise for a url and potentially start the network\n     * fetch.\n     *\n     * Uses throttle only when instructed by action meta. This is valuable\n     * for ensures mutation requests always go through.\n     */\n\n  }, {\n    key: \"handleFetch\",\n    value: function handleFetch(action, dispatch) {\n      var fetch = action.payload;\n      var _action$meta = action.meta,\n          schema = _action$meta.schema,\n          url = _action$meta.url,\n          responseType = _action$meta.responseType,\n          throttle = _action$meta.throttle,\n          resolve = _action$meta.resolve,\n          updaters = _action$meta.updaters,\n          reject = _action$meta.reject,\n          _action$meta$options = _action$meta.options,\n          options = _action$meta$options === void 0 ? {} : _action$meta$options;\n      var _options$dataExpiryLe = options.dataExpiryLength,\n          dataExpiryLength = _options$dataExpiryLe === void 0 ? this.dataExpiryLength : _options$dataExpiryLe,\n          _options$errorExpiryL = options.errorExpiryLength,\n          errorExpiryLength = _options$errorExpiryL === void 0 ? this.errorExpiryLength : _options$errorExpiryL;\n\n      var deferedFetch = function deferedFetch() {\n        return fetch().then(function (data) {\n          var now = Date.now();\n          var meta = {\n            schema: schema,\n            url: url,\n            date: now,\n            expiresAt: now + dataExpiryLength\n          };\n\n          if (['rest-hooks/receive', 'rest-hooks/rpc'].includes(responseType)) {\n            meta.updaters = updaters;\n          }\n\n          dispatch({\n            type: responseType,\n            payload: data,\n            meta: meta\n          });\n          return data;\n        })[\"catch\"](function (error) {\n          if (error.name === 'CLEANUP') return;\n          var now = Date.now();\n          dispatch({\n            type: responseType,\n            payload: error,\n            meta: {\n              schema: schema,\n              url: url,\n              date: now,\n              expiresAt: now + errorExpiryLength\n            },\n            error: true\n          });\n          throw error;\n        });\n      };\n\n      var promise;\n\n      if (throttle) {\n        promise = this.throttle(url, deferedFetch);\n      } else {\n        promise = deferedFetch();\n      }\n\n      promise.then(function (data) {\n        return resolve(data);\n      })[\"catch\"](function (error) {\n        return reject(error);\n      });\n      return promise;\n    }\n    /** Called when middleware intercepts a receive action.\n     *\n     * Will resolve the promise associated with receive url.\n     */\n\n  }, {\n    key: \"handleReceive\",\n    value: function handleReceive(action) {\n      // this can still turn out to be untrue since this is async\n      if (action.meta.url in this.fetched) {\n        var promiseHandler;\n\n        if (action.error) {\n          promiseHandler = this.rejectors[action.meta.url];\n        } else {\n          promiseHandler = this.resolvers[action.meta.url];\n        }\n\n        promiseHandler(action.payload); // since we're resolved we no longer need to keep track of this promise\n\n        this.clear(action.meta.url);\n      }\n    }\n    /** Attaches NetworkManager to store\n     *\n     * Intercepts 'rest-hooks/fetch' actions to start requests.\n     *\n     * Resolve/rejects a request when matching 'rest-hooks/receive' event\n     * is seen.\n     */\n\n  }, {\n    key: \"throttle\",\n\n    /** Ensures only one request for a given url is in flight at any time\n     *\n     * Uses url as key to either retrieve in-flight promise, or if not\n     * create a new promise and call fetch.\n     *\n     * Note: The new promise is not actually tied to fetch at all,\n     * but is resolved when the expected 'recieve' action is processed.\n     * This ensures promises are resolved only once their data is processed\n     * by the reducer.\n     */\n    value: function throttle(url, fetch) {\n      var _this2 = this; // we're already fetching so reuse the promise\n\n\n      if (url in this.fetched) {\n        return this.fetched[url];\n      }\n\n      this.fetched[url] = new Promise(function (resolve, reject) {\n        _this2.resolvers[url] = resolve;\n        _this2.rejectors[url] = reject;\n      }); // since our real promise is resolved via the wrapReducer(),\n      // we should just stop all errors here.\n      // TODO: decouple this from useFetcher() (that's what's dispatching the error the resolves in here)\n\n      RIC(function () {\n        fetch()[\"catch\"](function () {\n          return null;\n        });\n      }, {\n        timeout: 500\n      });\n      return this.fetched[url];\n    }\n  }]);\n\n  return NetworkManager;\n}();\n\nexport { NetworkManager as default };","map":{"version":3,"sources":["../../src/state/NetworkManager.ts"],"names":["NetworkManager","dataExpiryLength","errorExpiryLength","error","url","action","dispatch","fetch","schema","responseType","throttle","resolve","updaters","reject","options","deferedFetch","now","Date","meta","date","expiresAt","type","payload","promise","promiseHandler","Promise","next","RIC","timeout"],"mappings":"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","sourcesContent":["import { memoize } from 'lodash';\nimport {\n  FetchAction,\n  ReceiveAction,\n  MiddlewareAPI,\n  Manager,\n  PurgeAction,\n  Dispatch,\n} from '~/types';\nimport { RPCAction } from '..';\nimport RIC from './RIC';\n\n/** Handles all async network dispatches\n *\n * Dedupes concurrent requests by keeping track of all fetches in flight\n * and returning existing promises for requests already in flight.\n *\n * Interfaces with store via a redux-compatible middleware.\n */\nexport default class NetworkManager implements Manager {\n  protected fetched: { [k: string]: Promise<any> } = {};\n  protected resolvers: { [k: string]: (value?: any) => void } = {};\n  protected rejectors: { [k: string]: (value?: any) => void } = {};\n  readonly dataExpiryLength: number;\n  readonly errorExpiryLength: number;\n  constructor(dataExpiryLength = 60000, errorExpiryLength = 1000) {\n    this.dataExpiryLength = dataExpiryLength;\n    this.errorExpiryLength = errorExpiryLength;\n  }\n\n  /** Ensures all promises are completed by rejecting remaining. */\n  cleanup() {\n    for (const k in this.rejectors) {\n      const error = new Error('Cleaning up Network Manager');\n      error.name = 'CLEANUP';\n      this.rejectors[k](error);\n    }\n  }\n\n  /** Clear promise state for a given url */\n  protected clear(url: string) {\n    delete this.resolvers[url];\n    delete this.rejectors[url];\n    delete this.fetched[url];\n  }\n\n  /** Called when middleware intercepts 'rest-hooks/fetch' action.\n   *\n   * Will then start a promise for a url and potentially start the network\n   * fetch.\n   *\n   * Uses throttle only when instructed by action meta. This is valuable\n   * for ensures mutation requests always go through.\n   */\n  protected handleFetch(action: FetchAction, dispatch: Dispatch<any>) {\n    const fetch = action.payload;\n    const {\n      schema,\n      url,\n      responseType,\n      throttle,\n      resolve,\n      updaters,\n      reject,\n      options = {},\n    } = action.meta;\n    const {\n      dataExpiryLength = this.dataExpiryLength,\n      errorExpiryLength = this.errorExpiryLength,\n    } = options;\n\n    const deferedFetch = () =>\n      fetch()\n        .then(data => {\n          const now = Date.now();\n          const meta:\n            | ReceiveAction['meta']\n            | RPCAction['meta']\n            | PurgeAction['meta'] = {\n            schema,\n            url,\n            date: now,\n            expiresAt: now + dataExpiryLength,\n          };\n          if (['rest-hooks/receive', 'rest-hooks/rpc'].includes(responseType)) {\n            meta.updaters = updaters;\n          }\n          dispatch({\n            type: responseType,\n            payload: data,\n            meta,\n          });\n          return data;\n        })\n        .catch(error => {\n          if (error.name === 'CLEANUP') return;\n          const now = Date.now();\n          dispatch({\n            type: responseType,\n            payload: error,\n            meta: {\n              schema,\n              url,\n              date: now,\n              expiresAt: now + errorExpiryLength,\n            },\n            error: true,\n          });\n          throw error;\n        });\n    let promise;\n    if (throttle) {\n      promise = this.throttle(url, deferedFetch);\n    } else {\n      promise = deferedFetch();\n    }\n    promise.then(data => resolve(data)).catch(error => reject(error));\n    return promise;\n  }\n\n  /** Called when middleware intercepts a receive action.\n   *\n   * Will resolve the promise associated with receive url.\n   */\n  protected handleReceive(action: ReceiveAction) {\n    // this can still turn out to be untrue since this is async\n    if (action.meta.url in this.fetched) {\n      let promiseHandler: (value?: any) => void;\n      if (action.error) {\n        promiseHandler = this.rejectors[action.meta.url];\n      } else {\n        promiseHandler = this.resolvers[action.meta.url];\n      }\n      promiseHandler(action.payload);\n      // since we're resolved we no longer need to keep track of this promise\n      this.clear(action.meta.url);\n    }\n  }\n\n  /** Attaches NetworkManager to store\n   *\n   * Intercepts 'rest-hooks/fetch' actions to start requests.\n   *\n   * Resolve/rejects a request when matching 'rest-hooks/receive' event\n   * is seen.\n   */\n  getMiddleware = memoize(function<T extends NetworkManager>(this: T) {\n    return <R extends React.Reducer<any, any>>({\n      dispatch,\n    }: MiddlewareAPI<R>) => {\n      return (next: Dispatch<R>) => (\n        action: React.ReducerAction<R>,\n      ): Promise<void> => {\n        switch (action.type) {\n          case 'rest-hooks/fetch':\n            this.handleFetch(action, dispatch);\n            return Promise.resolve();\n          case 'rest-hooks/purge':\n          case 'rest-hooks/rpc':\n          case 'rest-hooks/receive':\n            // only receive after new state is computed\n            return next(action).then(() => {\n              if (action.meta.url in this.fetched) {\n                this.handleReceive(action);\n              }\n            });\n          case 'rest-hooks/reset':\n            this.cleanup();\n            return next(action);\n          default:\n            return next(action);\n        }\n      };\n    };\n  });\n\n  /** Ensures only one request for a given url is in flight at any time\n   *\n   * Uses url as key to either retrieve in-flight promise, or if not\n   * create a new promise and call fetch.\n   *\n   * Note: The new promise is not actually tied to fetch at all,\n   * but is resolved when the expected 'recieve' action is processed.\n   * This ensures promises are resolved only once their data is processed\n   * by the reducer.\n   */\n  protected throttle(url: string, fetch: () => Promise<any>) {\n    // we're already fetching so reuse the promise\n    if (url in this.fetched) {\n      return this.fetched[url];\n    }\n\n    this.fetched[url] = new Promise((resolve, reject) => {\n      this.resolvers[url] = resolve;\n      this.rejectors[url] = reject;\n    });\n\n    // since our real promise is resolved via the wrapReducer(),\n    // we should just stop all errors here.\n    // TODO: decouple this from useFetcher() (that's what's dispatching the error the resolves in here)\n    RIC(\n      () => {\n        fetch().catch(() => null);\n      },\n      { timeout: 500 },\n    );\n\n    return this.fetched[url];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}