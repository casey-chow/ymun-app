{"ast":null,"code":"import _jsx from \"@babel/runtime/helpers/esm/jsx\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport React, { useEffect, useState } from 'react';\nimport { StateContext, DispatchContext } from \"../context\";\nimport usePromisifiedDispatch from './usePromisifiedDispatch';\nexport default function ExternalCacheProvider(_ref) {\n  var children = _ref.children,\n      store = _ref.store,\n      selector = _ref.selector;\n\n  var _useState = useState(function () {\n    return selector(store.getState());\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      state = _useState2[0],\n      setState = _useState2[1];\n\n  useEffect(function () {\n    var unsubscribe = store.subscribe(function () {\n      setState(selector(store.getState()));\n    });\n    return unsubscribe; // we don't care to recompute if they change selector - only when store updates\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [store]);\n  var dispatch = usePromisifiedDispatch(store.dispatch, state);\n  return _jsx(DispatchContext.Provider, {\n    value: dispatch\n  }, void 0, _jsx(StateContext.Provider, {\n    value: state\n  }, void 0, children));\n}","map":{"version":3,"sources":["../../../src/react-integration/provider/ExternalCacheProvider.tsx"],"names":["children","store","selector","state","setState","useState","useEffect","unsubscribe","dispatch","usePromisifiedDispatch"],"mappings":";;AAAA,OAAA,KAAA,IAAA,SAAA,EAAA,QAAA,QAAA,OAAA;AACA,SAAA,YAAA,EAAA,eAAA,QAAA,YAAA;AAEA,OAAA,sBAAA,MAAA,0BAAA;AAaA,eAAe,SAAA,qBAAA,CAAA,IAAA,EAIF;AAAA,MAHXA,QAGW,GAAA,IAAA,CAHXA,QAGW;AAAA,MAFXC,KAEW,GAAA,IAAA,CAFXA,KAEW;AAAA,MADXC,QACW,GAAA,IAAA,CADXA,QACW;;AAAA,MAAA,SAAA,GACeG,QAAQ,CAAC,YAAA;AAAA,WAAMH,QAAQ,CAACD,KAAK,CAApB,QAAeA,EAAD,CAAd;AADxB,GACuB,CADvB;AAAA,MAAA,UAAA,GAAA,cAAA,CAAA,SAAA,EAAA,CAAA,CAAA;AAAA,MACJE,KADI,GAAA,UAAA,CAAA,CAAA,CAAA;AAAA,MACGC,QADH,GAAA,UAAA,CAAA,CAAA,CAAA;;AAGXE,EAAAA,SAAS,CAAC,YAAM;AACd,QAAMC,WAAW,GAAG,KAAK,CAAL,SAAA,CAAgB,YAAM;AACxCH,MAAAA,QAAQ,CAACF,QAAQ,CAACD,KAAK,CAAvBG,QAAkBH,EAAD,CAAT,CAARG;AADF,KAAoB,CAApB;AAGA,WAJc,WAId,CAJc,CAKd;AACA;AANO,GAAA,EAON,CAPHE,KAOG,CAPM,CAATA;AASA,MAAME,QAAQ,GAAGC,sBAAsB,CAACR,KAAK,CAAN,QAAA,EAAvC,KAAuC,CAAvC;AAEA,SACE,IAAA,CAAC,eAAD,CAAA,QAAA,EAAA;AAA0B,IAAA,KAAK,EAAEO;AAAjC,GAAA,EAAA,KAAA,CAAA,EACE,IAAA,CAAC,YAAD,CAAA,QAAA,EAAA;AAAuB,IAAA,KAAK,EAAEL;AAA9B,GAAA,EAAA,KAAA,CAAA,EAFJ,QAEI,CADF,CADF;AAKD","sourcesContent":["import React, { ReactNode, useEffect, useState } from 'react';\nimport { StateContext, DispatchContext } from '~/react-integration/context';\nimport { State, ActionTypes } from '~/types';\nimport usePromisifiedDispatch from './usePromisifiedDispatch';\n\ninterface Store<S> {\n  subscribe(listener: () => void): () => void;\n  dispatch: React.Dispatch<ActionTypes>;\n  getState(): S;\n}\ninterface Props<S> {\n  children: ReactNode;\n  store: Store<S>;\n  selector: (state: S) => State<unknown>;\n}\n\nexport default function ExternalCacheProvider<S>({\n  children,\n  store,\n  selector,\n}: Props<S>) {\n  const [state, setState] = useState(() => selector(store.getState()));\n\n  useEffect(() => {\n    const unsubscribe = store.subscribe(() => {\n      setState(selector(store.getState()));\n    });\n    return unsubscribe;\n    // we don't care to recompute if they change selector - only when store updates\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [store]);\n\n  const dispatch = usePromisifiedDispatch(store.dispatch, state);\n\n  return (\n    <DispatchContext.Provider value={dispatch}>\n      <StateContext.Provider value={state}>{children}</StateContext.Provider>\n    </DispatchContext.Provider>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}