{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _memoize from \"lodash/memoize\";\nimport { schemas } from './normal';\nvar DefinedMembersKey = Symbol('Defined Members');\n/** Represents an entity to be retrieved from a server. Typically 1:1 with a url endpoint. */\n\nvar SimpleResource =\n/*#__PURE__*/\nfunction () {\n  function SimpleResource() {\n    _classCallCheck(this, SimpleResource);\n\n    _defineProperty(this, \"__url\", void 0);\n  }\n\n  _createClass(SimpleResource, [{\n    key: \"url\",\n\n    /** URL to find this SimpleResource */\n    get: function get() {\n      if (this.__url !== undefined) return this.__url; // typescript thinks constructor is just a function\n\n      var Static = this.constructor;\n      return Static.url(this);\n    }\n  }], [{\n    key: \"fromJS\",\n\n    /** SimpleResource factory. Takes an object of properties to assign to SimpleResource. */\n    value: function fromJS(props) {\n      // we type guarded abstract case above, so ok to force typescript to allow constructor call\n      var instance = new this(props);\n      if (instance.pk === undefined) throw new Error('cannot construct on abstract types');\n      Object.defineProperty(instance, DefinedMembersKey, {\n        value: Object.keys(props),\n        writable: false\n      });\n      Object.assign(instance, props); // to trick normalizr into thinking we're Immutable.js does it doesn't copy\n\n      Object.defineProperty(instance, '__ownerID', {\n        value: 1337,\n        writable: false\n      });\n      return instance;\n    }\n    /** Creates new instance copying over defined values of arguments */\n\n  }, {\n    key: \"merge\",\n    value: function merge(first, second) {\n      var props = Object.assign({}, this.toObjectDefined(first), this.toObjectDefined(second));\n      return this.fromJS(props);\n    }\n    /** Whether key is non-default */\n\n  }, {\n    key: \"hasDefined\",\n    value: function hasDefined(instance, key) {\n      return instance[DefinedMembersKey].includes(key);\n    }\n    /** Returns simple object with all the non-default members */\n\n  }, {\n    key: \"toObjectDefined\",\n    value: function toObjectDefined(instance) {\n      var defined = {};\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = instance[DefinedMembersKey][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var member = _step.value;\n          defined[member] = instance[member];\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return defined;\n    }\n    /** Returns array of all keys that have values defined in instance */\n\n  }, {\n    key: \"keysDefined\",\n    value: function keysDefined(instance) {\n      return instance[DefinedMembersKey];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.name, \"::\").concat(this.urlRoot);\n    }\n    /** Returns the globally unique identifier for this SimpleResource */\n\n  }, {\n    key: \"getKey\",\n    value: function getKey() {\n      return this.urlRoot;\n    }\n    /** A unique identifier for this SimpleResource */\n\n  }, {\n    key: \"pk\",\n    value: function pk(params) {\n      return this.prototype.pk.call(params);\n    }\n  }, {\n    key: \"url\",\n\n    /** Get the url for a SimpleResource\n     *\n     * Default implementation conforms to common REST patterns\n     */\n    value: function url(urlParams) {\n      if (urlParams) {\n        if (Object.prototype.hasOwnProperty.call(urlParams, 'url') && urlParams.url && typeof urlParams.url === 'string') {\n          return urlParams.url;\n        }\n\n        if (this.pk(urlParams) !== null) {\n          if (this.urlRoot.endsWith('/')) {\n            return \"\".concat(this.urlRoot).concat(this.pk(urlParams));\n          }\n\n          return \"\".concat(this.urlRoot, \"/\").concat(this.pk(urlParams));\n        }\n      }\n\n      return this.urlRoot;\n    }\n    /** Get the url for many SimpleResources\n     *\n     * Default implementation conforms to common REST patterns\n     */\n\n  }, {\n    key: \"listUrl\",\n    value: function listUrl(searchParams) {\n      if (searchParams && Object.keys(searchParams).length) {\n        var params = new URLSearchParams(searchParams);\n        params.sort();\n        return \"\".concat(this.urlRoot, \"?\").concat(params.toString());\n      }\n\n      return this.urlRoot;\n    }\n    /** Perform network request and resolve with json body */\n\n  }, {\n    key: \"fetch\",\n    value: function fetch(method, url, body) {\n      // typescript currently doesn't allow abstract static methods\n      throw new Error('not implemented');\n    }\n    /** Get the entity schema defining  */\n\n  }, {\n    key: \"getEntitySchema\",\n    value: function getEntitySchema() {\n      return _getEntitySchema(this);\n    }\n    /** Get the request options for this SimpleResource  */\n\n  }, {\n    key: \"getFetchOptions\",\n    value: function getFetchOptions() {\n      return;\n    } // TODO: memoize these so they can be referentially compared\n\n    /** Shape to get a single entity */\n\n  }, {\n    key: \"detailShape\",\n    value: function detailShape() {\n      var _this = this;\n\n      var getFetchKey = function getFetchKey(params) {\n        return 'GET ' + _this.url(params);\n      };\n\n      var schema = this.getEntitySchema();\n      var options = this.getFetchOptions();\n      return {\n        type: 'read',\n        schema: schema,\n        options: options,\n        getFetchKey: getFetchKey,\n        fetch: function fetch(params) {\n          return _this.fetch('get', _this.url(params));\n        }\n      };\n    }\n    /** Shape to get a list of entities */\n\n  }, {\n    key: \"listShape\",\n    value: function listShape() {\n      var _this2 = this;\n\n      var getFetchKey = function getFetchKey(params) {\n        return 'GET ' + _this2.listUrl(params);\n      };\n\n      var schema = [this.getEntitySchema()];\n      var options = this.getFetchOptions();\n      return {\n        type: 'read',\n        schema: schema,\n        options: options,\n        getFetchKey: getFetchKey,\n        fetch: function fetch(params) {\n          return _this2.fetch('get', _this2.listUrl(params));\n        }\n      };\n    }\n    /** Shape to create a new entity (post) */\n\n  }, {\n    key: \"createShape\",\n    value: function createShape() {\n      var _this3 = this;\n\n      var options = this.getFetchOptions();\n      return {\n        type: 'mutate',\n        schema: this.getEntitySchema(),\n        options: options,\n        getFetchKey: function getFetchKey(params) {\n          return 'POST ' + _this3.listUrl(params);\n        },\n        fetch: function fetch(params, body) {\n          return _this3.fetch('post', _this3.listUrl(params), body);\n        }\n      };\n    }\n    /** Shape to update an existing entity (put) */\n\n  }, {\n    key: \"updateShape\",\n    value: function updateShape() {\n      var _this4 = this;\n\n      var options = this.getFetchOptions();\n      return {\n        type: 'mutate',\n        schema: this.getEntitySchema(),\n        options: options,\n        getFetchKey: function getFetchKey(params) {\n          return 'PUT ' + _this4.url(params);\n        },\n        fetch: function fetch(params, body) {\n          return _this4.fetch('put', _this4.url(params), body);\n        }\n      };\n    }\n    /** Shape to update a subset of fields of an existing entity (patch) */\n\n  }, {\n    key: \"partialUpdateShape\",\n    value: function partialUpdateShape() {\n      var _this5 = this;\n\n      var options = this.getFetchOptions();\n      return {\n        type: 'mutate',\n        schema: this.getEntitySchema(),\n        //TODO: change merge strategy in case we want to handle partial returns\n        options: options,\n        getFetchKey: function getFetchKey(params) {\n          return 'PATCH ' + _this5.url(params);\n        },\n        fetch: function fetch(params, body) {\n          return _this5.fetch('patch', _this5.url(params), body);\n        }\n      };\n    }\n    /** Shape to delete an entity (delete) */\n\n  }, {\n    key: \"deleteShape\",\n    value: function deleteShape() {\n      var _this6 = this;\n\n      var options = this.getFetchOptions();\n      return {\n        type: 'delete',\n        schema: this.getEntitySchema(),\n        options: options,\n        getFetchKey: function getFetchKey(params) {\n          return 'DELETE ' + _this6.url(params);\n        },\n        fetch: function fetch(params) {\n          return _this6.fetch('delete', _this6.url(params));\n        }\n      };\n    }\n  }]);\n\n  return SimpleResource;\n}(); // We're only allowing this to get set for descendants but\n// by default we want Typescript to treat it as readonly.\n\n\n_defineProperty(SimpleResource, \"urlRoot\", void 0);\n\nexport { SimpleResource as default };\nObject.defineProperty(SimpleResource.prototype, 'url', {\n  set: function set(url) {\n    this.__url = url;\n  }\n});\n\nvar _getEntitySchema = _memoize(function (ResourceClass) {\n  var e = new schemas.Entity(ResourceClass.getKey(), {}, {\n    idAttribute: function idAttribute(value, parent, key) {\n      var id = ResourceClass.pk(value) || key;\n\n      if (process.env.NODE_ENV !== 'production' && id === null) {\n        throw new Error(\"Missing usable resource key when normalizing response.\\n\\nThis is likely due to a malformed response.\\nTry inspecting the network response or fetch() return value.\\n\");\n      }\n\n      return id.toString();\n    },\n    processStrategy: function processStrategy(value) {\n      return ResourceClass.fromJS(value);\n    },\n    mergeStrategy: function mergeStrategy(a, b) {\n      return a.constructor.merge(a, b);\n    }\n  }); // TODO: long term figure out a plan to actually denormalize\n\n  e.denormalize = function denormalize(entity) {\n    return [entity, true];\n  };\n\n  return e;\n});","map":{"version":3,"sources":["../../src/resource/SimpleResource.ts"],"names":["DefinedMembersKey","Symbol","SimpleResource","props","instance","Object","value","writable","first","second","key","defined","member","params","Static","urlParams","searchParams","method","url","body","getEntitySchema","getFetchKey","schema","options","type","fetch","set","e","schemas","ResourceClass","idAttribute","id","process","processStrategy","mergeStrategy","a"],"mappings":"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","sourcesContent":["import { memoize } from 'lodash';\nimport { AbstractInstanceType, Method, FetchOptions } from '~/types';\n\nimport { ReadShape, MutateShape, DeleteShape } from './types';\nimport { schemas, SchemaDetail, SchemaList } from './normal';\n\nconst DefinedMembersKey = Symbol('Defined Members');\ntype Filter<T, U> = T extends U ? T : never;\ninterface SimpleResourceMembers<T extends typeof SimpleResource> {\n  [DefinedMembersKey]: (Filter<keyof AbstractInstanceType<T>, string>)[];\n}\n\n/** Represents an entity to be retrieved from a server. Typically 1:1 with a url endpoint. */\nexport default abstract class SimpleResource {\n  // typescript todo: require subclasses to implement\n  /** Used as base of url construction */\n  static readonly urlRoot: string;\n  /** A unique identifier for this SimpleResource */\n  abstract pk(): string | number | undefined;\n\n  /** SimpleResource factory. Takes an object of properties to assign to SimpleResource. */\n  static fromJS<T extends typeof SimpleResource>(\n    this: T,\n    props: Partial<AbstractInstanceType<T>>,\n  ) {\n    // we type guarded abstract case above, so ok to force typescript to allow constructor call\n    const instance = new (this as any)(props) as Readonly<\n      AbstractInstanceType<T>\n    >;\n\n    if (instance.pk === undefined)\n      throw new Error('cannot construct on abstract types');\n\n    Object.defineProperty(instance, DefinedMembersKey, {\n      value: Object.keys(props),\n      writable: false,\n    });\n\n    Object.assign(instance, props);\n\n    // to trick normalizr into thinking we're Immutable.js does it doesn't copy\n    Object.defineProperty(instance, '__ownerID', {\n      value: 1337,\n      writable: false,\n    });\n    return instance;\n  }\n\n  /** Creates new instance copying over defined values of arguments */\n  static merge<T extends typeof SimpleResource>(\n    this: T,\n    first: AbstractInstanceType<T>,\n    second: AbstractInstanceType<T>,\n  ) {\n    const props = Object.assign(\n      {},\n      this.toObjectDefined(first),\n      this.toObjectDefined(second),\n    );\n    return this.fromJS(props);\n  }\n\n  /** Whether key is non-default */\n  static hasDefined<T extends typeof SimpleResource>(\n    this: T,\n    instance: AbstractInstanceType<T>,\n    key: Filter<keyof AbstractInstanceType<T>, string>,\n  ) {\n    return ((instance as any) as SimpleResourceMembers<T>)[\n      DefinedMembersKey\n    ].includes(key);\n  }\n\n  /** Returns simple object with all the non-default members */\n  static toObjectDefined<T extends typeof SimpleResource>(\n    this: T,\n    instance: AbstractInstanceType<T>,\n  ) {\n    const defined: Partial<AbstractInstanceType<T>> = {};\n    for (const member of ((instance as any) as SimpleResourceMembers<T>)[\n      DefinedMembersKey\n    ]) {\n      defined[member] = instance[member];\n    }\n    return defined;\n  }\n\n  /** Returns array of all keys that have values defined in instance */\n  static keysDefined<T extends typeof SimpleResource>(\n    this: T,\n    instance: AbstractInstanceType<T>,\n  ) {\n    return ((instance as any) as SimpleResourceMembers<T>)[DefinedMembersKey];\n  }\n\n  static toString<T extends typeof SimpleResource>(this: T) {\n    return `${this.name}::${this.urlRoot}`;\n  }\n\n  /** Returns the globally unique identifier for this SimpleResource */\n  static getKey<T extends typeof SimpleResource>(this: T) {\n    return this.urlRoot;\n  }\n\n  /** A unique identifier for this SimpleResource */\n  static pk<T extends typeof SimpleResource>(\n    this: T,\n    params: Partial<AbstractInstanceType<T>>,\n  ): string | number | undefined {\n    return this.prototype.pk.call(params);\n  }\n\n  /** URL to find this SimpleResource */\n  get url(): string {\n    if (this.__url !== undefined) return this.__url;\n    // typescript thinks constructor is just a function\n    const Static = this.constructor as typeof SimpleResource;\n    return Static.url(this);\n  }\n  private __url?: string;\n\n  /** Get the url for a SimpleResource\n   *\n   * Default implementation conforms to common REST patterns\n   */\n  static url<T extends typeof SimpleResource>(\n    this: T,\n    urlParams?: Partial<AbstractInstanceType<T>>,\n  ): string {\n    if (urlParams) {\n      if (\n        Object.prototype.hasOwnProperty.call(urlParams, 'url') &&\n        urlParams.url &&\n        typeof urlParams.url === 'string'\n      ) {\n        return urlParams.url;\n      }\n      if (this.pk(urlParams) !== null) {\n        if (this.urlRoot.endsWith('/')) {\n          return `${this.urlRoot}${this.pk(urlParams)}`;\n        }\n        return `${this.urlRoot}/${this.pk(urlParams)}`;\n      }\n    }\n    return this.urlRoot;\n  }\n\n  /** Get the url for many SimpleResources\n   *\n   * Default implementation conforms to common REST patterns\n   */\n  static listUrl<T extends typeof SimpleResource>(\n    this: T,\n    searchParams?: Readonly<Record<string, string | number>>,\n  ): string {\n    if (searchParams && Object.keys(searchParams).length) {\n      const params = new URLSearchParams(searchParams as any);\n      params.sort();\n      return `${this.urlRoot}?${params.toString()}`;\n    }\n    return this.urlRoot;\n  }\n\n  /** Perform network request and resolve with json body */\n  static fetch<T extends typeof SimpleResource>(\n    this: T,\n    method: Method,\n    url: string,\n    body?: Readonly<object | string>,\n  ): Promise<any> {\n    // typescript currently doesn't allow abstract static methods\n    throw new Error('not implemented');\n  }\n\n  /** Get the entity schema defining  */\n  static getEntitySchema<T extends typeof SimpleResource>(this: T) {\n    return getEntitySchema(this);\n  }\n\n  /** Get the request options for this SimpleResource  */\n  static getFetchOptions<T extends typeof SimpleResource>(\n    this: T,\n  ): FetchOptions | undefined {\n    return;\n  }\n\n  // TODO: memoize these so they can be referentially compared\n  /** Shape to get a single entity */\n  static detailShape<T extends typeof SimpleResource>(\n    this: T,\n  ): ReadShape<SchemaDetail<Readonly<AbstractInstanceType<T>>>> {\n    const getFetchKey = (params: Readonly<object>) => {\n      return 'GET ' + this.url(params);\n    };\n    const schema = this.getEntitySchema();\n    const options = this.getFetchOptions();\n    return {\n      type: 'read',\n      schema,\n      options,\n      getFetchKey,\n      fetch: (params: Readonly<object>) => {\n        return this.fetch('get', this.url(params));\n      },\n    };\n  }\n\n  /** Shape to get a list of entities */\n  static listShape<T extends typeof SimpleResource>(\n    this: T,\n  ): ReadShape<SchemaList<Readonly<AbstractInstanceType<T>>>> {\n    const getFetchKey = (params: Readonly<Record<string, string>>) => {\n      return 'GET ' + this.listUrl(params);\n    };\n    const schema = [this.getEntitySchema()];\n    const options = this.getFetchOptions();\n    return {\n      type: 'read',\n      schema,\n      options,\n      getFetchKey,\n      fetch: (params: Readonly<Record<string, string | number>>) => {\n        return this.fetch('get', this.listUrl(params));\n      },\n    };\n  }\n\n  /** Shape to create a new entity (post) */\n  static createShape<T extends typeof SimpleResource>(\n    this: T,\n  ): MutateShape<\n    SchemaDetail<Readonly<AbstractInstanceType<T>>>,\n    Readonly<object>,\n    Partial<AbstractInstanceType<T>>\n  > {\n    const options = this.getFetchOptions();\n    return {\n      type: 'mutate',\n      schema: this.getEntitySchema(),\n      options,\n      getFetchKey: (params: Readonly<Record<string, string>>) => {\n        return 'POST ' + this.listUrl(params);\n      },\n      fetch: (\n        params: Readonly<Record<string, string | number>>,\n        body: Partial<AbstractInstanceType<T>>,\n      ) => {\n        return this.fetch('post', this.listUrl(params), body);\n      },\n    };\n  }\n\n  /** Shape to update an existing entity (put) */\n  static updateShape<T extends typeof SimpleResource>(\n    this: T,\n  ): MutateShape<\n    SchemaDetail<Readonly<AbstractInstanceType<T>>>,\n    Readonly<object>,\n    Partial<AbstractInstanceType<T>>\n  > {\n    const options = this.getFetchOptions();\n    return {\n      type: 'mutate',\n      schema: this.getEntitySchema(),\n      options,\n      getFetchKey: (params: object) => {\n        return 'PUT ' + this.url(params);\n      },\n      fetch: (\n        params: Readonly<object>,\n        body: Partial<AbstractInstanceType<T>>,\n      ) => {\n        return this.fetch('put', this.url(params), body);\n      },\n    };\n  }\n\n  /** Shape to update a subset of fields of an existing entity (patch) */\n  static partialUpdateShape<T extends typeof SimpleResource>(\n    this: T,\n  ): MutateShape<\n    SchemaDetail<Readonly<AbstractInstanceType<T>>>,\n    Readonly<object>,\n    Partial<AbstractInstanceType<T>>\n  > {\n    const options = this.getFetchOptions();\n    return {\n      type: 'mutate',\n      schema: this.getEntitySchema(), //TODO: change merge strategy in case we want to handle partial returns\n      options,\n      getFetchKey: (params: Readonly<object>) => {\n        return 'PATCH ' + this.url(params);\n      },\n      fetch: (\n        params: Readonly<object>,\n        body: Partial<AbstractInstanceType<T>>,\n      ) => {\n        return this.fetch('patch', this.url(params), body);\n      },\n    };\n  }\n\n  /** Shape to delete an entity (delete) */\n  static deleteShape<T extends typeof SimpleResource>(\n    this: T,\n  ): DeleteShape<any, Readonly<object>> {\n    const options = this.getFetchOptions();\n    return {\n      type: 'delete',\n      schema: this.getEntitySchema(),\n      options,\n      getFetchKey: (params: object) => {\n        return 'DELETE ' + this.url(params);\n      },\n      fetch: (params: Readonly<object>) => {\n        return this.fetch('delete', this.url(params));\n      },\n    };\n  }\n}\n\n// We're only allowing this to get set for descendants but\n// by default we want Typescript to treat it as readonly.\nObject.defineProperty(SimpleResource.prototype, 'url', {\n  set(url: string) {\n    this.__url = url;\n  },\n});\n\ntype GetEntitySchema = <T extends typeof SimpleResource>(\n  ResourceClass: T,\n) => schemas.Entity<Readonly<AbstractInstanceType<T>>>;\n\nconst getEntitySchema: GetEntitySchema = memoize(\n  <T extends typeof SimpleResource>(ResourceClass: T) => {\n    const e = new schemas.Entity(\n      ResourceClass.getKey(),\n      {},\n      {\n        idAttribute: (value, parent, key) => {\n          const id = ResourceClass.pk(value) || key;\n          if (process.env.NODE_ENV !== 'production' && id === null) {\n            throw new Error(\n              `Missing usable resource key when normalizing response.\n\nThis is likely due to a malformed response.\nTry inspecting the network response or fetch() return value.\n`,\n            );\n          }\n          return id.toString();\n        },\n        processStrategy: value => {\n          return ResourceClass.fromJS(value);\n        },\n        mergeStrategy: (\n          a: AbstractInstanceType<T>,\n          b: AbstractInstanceType<T>,\n        ) => (a.constructor as T).merge(a, b),\n      },\n    );\n    // TODO: long term figure out a plan to actually denormalize\n    (e as any).denormalize = function denormalize(entity: any) {\n      return [entity, true];\n    };\n    return e;\n  },\n) as any;\n"]},"metadata":{},"sourceType":"module"}