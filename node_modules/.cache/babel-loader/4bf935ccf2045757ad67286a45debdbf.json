{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport useCacheLegacy from './useCacheLegacy';\nimport useRetrieve from './useRetrieve';\nimport useError from './useError';\nimport { useMemo } from 'react';\nimport hasUsableData from './hasUsableData';\n/** single form resource */\n\nfunction useOneResource(fetchShape, params) {\n  // maybePromise is undefined when data is stale or params is null\n  var maybePromise = useRetrieve(fetchShape, params); // resource is null when it is not in cache or params is null\n\n  var resource = useCacheLegacy(fetchShape, params);\n  var error = useError(fetchShape, params, !!resource);\n  if (!hasUsableData(!!resource, fetchShape) && maybePromise) throw maybePromise;\n  if (error) throw error;\n  return resource;\n}\n/** many form resource */\n\n\nfunction useManyResources() {\n  for (var _len = arguments.length, resourceList = new Array(_len), _key = 0; _key < _len; _key++) {\n    resourceList[_key] = arguments[_key];\n  }\n\n  var resources = resourceList.map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        fetchShape = _ref2[0],\n        params = _ref2[1];\n\n    return (// eslint-disable-next-line react-hooks/rules-of-hooks\n      useCacheLegacy(fetchShape, params)\n    );\n  });\n  var promises = resourceList.map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        fetchShape = _ref4[0],\n        params = _ref4[1];\n\n    return (// eslint-disable-next-line react-hooks/rules-of-hooks\n      useRetrieve(fetchShape, params)\n    );\n  }) // only wait on promises without results\n  .map(function (p, i) {\n    return !hasUsableData(!!resources[i], resourceList[i][0]) && p;\n  }); // throw first valid error\n\n  for (var i = 0; i < resourceList.length; i++) {\n    var _resourceList$i = _slicedToArray(resourceList[i], 2),\n        _fetchShape = _resourceList$i[0],\n        _params = _resourceList$i[1];\n\n    var resource = resources[i]; // eslint-disable-next-line react-hooks/rules-of-hooks\n\n    var error = useError(_fetchShape, _params, !!resource);\n    if (error && !promises[i]) throw error;\n  }\n\n  var promise = useMemo(function () {\n    var activePromises = promises.filter(function (p) {\n      return p;\n    });\n\n    if (activePromises.length) {\n      return Promise.all(activePromises);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, promises);\n  if (promise) throw promise;\n  return resources;\n}\n\nexport default function useResourceLegacy() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  } // this conditional use of hooks is ok as long as the structure of the arguments don't change\n\n\n  if (Array.isArray(args[0])) {\n    // TODO: provide type guard function to detect this\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return useManyResources.apply(void 0, _toConsumableArray(args));\n  }\n\n  args = args; // TODO: make return types match up with the branching logic we put in here.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n\n  return useOneResource(args[0], args[1]);\n}","map":{"version":3,"sources":["../../../src/react-integration/hooks/useResourceLegacy.ts"],"names":["maybePromise","useRetrieve","resource","useCacheLegacy","error","useError","hasUsableData","resourceList","resources","fetchShape","params","promises","i","promise","useMemo","activePromises","Promise","args","Array","useManyResources","useOneResource"],"mappings":"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","sourcesContent":["import { ReadShape, Schema, SchemaOf } from '~/resource';\nimport useCacheLegacy from './useCacheLegacy';\nimport useRetrieve from './useRetrieve';\nimport useError from './useError';\nimport { useMemo } from 'react';\n\nimport hasUsableData from './hasUsableData';\n\ntype ResourceArgs<S extends Schema, Params extends Readonly<object>> = [\n  ReadShape<S, Params>,\n  Params | null,\n];\n\n/** single form resource */\nfunction useOneResource<Params extends Readonly<object>, S extends Schema>(\n  fetchShape: ReadShape<S, Params>,\n  params: Params | null,\n): CondNull<typeof params, NonNullable<SchemaOf<S>>> {\n  // maybePromise is undefined when data is stale or params is null\n  const maybePromise = useRetrieve(fetchShape, params);\n  // resource is null when it is not in cache or params is null\n  const resource = useCacheLegacy(fetchShape, params);\n  const error = useError(fetchShape, params, !!resource);\n\n  if (!hasUsableData(!!resource, fetchShape) && maybePromise)\n    throw maybePromise;\n  if (error) throw error;\n\n  return resource as any;\n}\n\n/** many form resource */\nfunction useManyResources<A extends ResourceArgs<any, any>[]>(\n  ...resourceList: A\n) {\n  const resources = resourceList.map(\n    <Params extends Readonly<object>, S extends Schema>([\n      fetchShape,\n      params,\n    ]: ResourceArgs<S, Params>) =>\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      useCacheLegacy(fetchShape, params),\n  );\n  const promises = resourceList\n    .map(([fetchShape, params]) =>\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      useRetrieve(fetchShape, params),\n    )\n    // only wait on promises without results\n    .map((p, i) => !hasUsableData(!!resources[i], resourceList[i][0]) && p);\n\n  // throw first valid error\n  for (let i = 0; i < resourceList.length; i++) {\n    const [fetchShape, params] = resourceList[i];\n    const resource = resources[i];\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const error = useError(fetchShape, params, !!resource);\n    if (error && !promises[i]) throw error;\n  }\n\n  const promise = useMemo(() => {\n    const activePromises = promises.filter(p => p);\n    if (activePromises.length) {\n      return Promise.all(activePromises);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, promises);\n\n  if (promise) throw promise;\n\n  return resources;\n}\n\ntype CondNull<P, R> = P extends null ? null : R;\n\n/** Ensure a resource is available; suspending to React until it is. */\nexport default function useResourceLegacy<\n  P extends Readonly<object> | null,\n  S extends Schema\n>(\n  fetchShape: ReadShape<S, NonNullable<P>>,\n  params: P,\n): CondNull<P, SchemaOf<S>>;\nexport default function useResourceLegacy<\n  P1 extends Readonly<object> | null,\n  S1 extends Schema\n>(v1: [ReadShape<S1, NonNullable<P1>>, P1]): [CondNull<P1, SchemaOf<S1>>];\nexport default function useResourceLegacy<\n  P1 extends Readonly<object> | null,\n  S1 extends Schema,\n  P2 extends Readonly<object> | null,\n  S2 extends Schema\n>(\n  v1: [ReadShape<S1, NonNullable<P1>>, P1],\n  v2: [ReadShape<S2, NonNullable<P2>>, P2],\n): [CondNull<P1, SchemaOf<S1>>, CondNull<P2, SchemaOf<S2>>];\nexport default function useResourceLegacy<\n  P1 extends Readonly<object> | null,\n  S1 extends Schema,\n  P2 extends Readonly<object> | null,\n  S2 extends Schema,\n  P3 extends Readonly<object> | null,\n  S3 extends Schema\n>(\n  v1: [ReadShape<S1, NonNullable<P1>>, P1],\n  v2: [ReadShape<S2, NonNullable<P2>>, P2],\n  v3: [ReadShape<S3, NonNullable<P3>>, P3],\n): [\n  CondNull<P1, SchemaOf<S1>>,\n  CondNull<P2, SchemaOf<S2>>,\n  CondNull<P3, SchemaOf<S3>>,\n];\nexport default function useResourceLegacy<\n  P1 extends Readonly<object> | null,\n  S1 extends Schema,\n  P2 extends Readonly<object> | null,\n  S2 extends Schema,\n  P3 extends Readonly<object> | null,\n  S3 extends Schema,\n  P4 extends Readonly<object> | null,\n  S4 extends Schema\n>(\n  v1: [ReadShape<S1, NonNullable<P1>>, P1],\n  v2: [ReadShape<S2, NonNullable<P2>>, P2],\n  v3: [ReadShape<S3, NonNullable<P3>>, P3],\n  v4: [ReadShape<S4, NonNullable<P4>>, P4],\n): [\n  CondNull<P1, SchemaOf<S1>>,\n  CondNull<P2, SchemaOf<S2>>,\n  CondNull<P3, SchemaOf<S3>>,\n  CondNull<P4, SchemaOf<S4>>,\n];\nexport default function useResourceLegacy<\n  P1 extends Readonly<object> | null,\n  S1 extends Schema,\n  P2 extends Readonly<object> | null,\n  S2 extends Schema,\n  P3 extends Readonly<object> | null,\n  S3 extends Schema,\n  P4 extends Readonly<object> | null,\n  S4 extends Schema,\n  P5 extends Readonly<object> | null,\n  S5 extends Schema\n>(\n  v1: [ReadShape<S1, NonNullable<P1>>, P1],\n  v2: [ReadShape<S2, NonNullable<P2>>, P2],\n  v3: [ReadShape<S3, NonNullable<P3>>, P3],\n  v4: [ReadShape<S4, NonNullable<P4>>, P4],\n  v5: [ReadShape<S5, NonNullable<P5>>, P5],\n): [\n  CondNull<P1, SchemaOf<S1>>,\n  CondNull<P2, SchemaOf<S2>>,\n  CondNull<P3, SchemaOf<S3>>,\n  CondNull<P4, SchemaOf<S4>>,\n  CondNull<P5, SchemaOf<S5>>,\n];\nexport default function useResourceLegacy<\n  Params extends Readonly<object>,\n  S extends Schema\n>(...args: ResourceArgs<S, Params> | ResourceArgs<S, Params>[]) {\n  // this conditional use of hooks is ok as long as the structure of the arguments don't change\n  if (Array.isArray(args[0])) {\n    // TODO: provide type guard function to detect this\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return useManyResources(...(args as ResourceArgs<S, Params>[]));\n  }\n  args = args as ResourceArgs<S, Params>;\n  // TODO: make return types match up with the branching logic we put in here.\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return useOneResource(args[0], args[1]);\n}\n"]},"metadata":{},"sourceType":"module"}