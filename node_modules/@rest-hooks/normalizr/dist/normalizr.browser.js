var rest_hooks_normalizr = (function (exports) {
  'use strict';

  /**
   * Helpers to enable Immutable compatibility *without* bringing in
   * the 'immutable' package as a dependency.
   */

  /**
   * Check if an object is immutable by checking if it has a key specific
   * to the immutable library.
   *
   * @param  {any} object
   * @return {bool}
   */
  function isImmutable(object) {
    return !!(object && typeof object.hasOwnProperty === 'function' && (object.hasOwnProperty('__ownerID') || // Immutable.Map
    object._map && object._map.hasOwnProperty('__ownerID'))); // Immutable.Record
  }
  /**
   * Denormalize an immutable entity.
   *
   * @param  {Schema} schema
   * @param  {Immutable.Map|Immutable.Record} input
   * @param  {function} unvisit
   * @param  {function} getDenormalizedEntity
   * @return {Immutable.Map|Immutable.Record}
   */

  function denormalizeImmutable(schema, input, unvisit) {
    let found = true;
    return [Object.keys(schema).reduce((object, key) => {
      // Immutable maps cast keys to strings on write so we need to ensure
      // we're accessing them using string keys.
      const stringKey = "" + key;
      const [item, foundItem] = unvisit(object.get(stringKey), schema[stringKey]);

      if (!foundItem) {
        found = false;
      }

      if (object.has(stringKey)) {
        return object.set(stringKey, item);
      } else {
        return object;
      }
    }, input), found];
  }

  const getDefaultGetId = idAttribute => input => isImmutable(input) ? input.get(idAttribute) : input[idAttribute];

  class EntitySchema {
    constructor(key, definition = {}, options = {}) {
      if (!key || typeof key !== 'string') {
        throw new Error("Expected a string key for Entity, but found " + key + ".");
      }

      const {
        idAttribute = 'id',
        mergeStrategy = (entityA, entityB) => {
          return Object.assign({}, entityA, {}, entityB);
        },
        processStrategy = input => Object.assign({}, input)
      } = options;
      this._key = key;
      this._getId = typeof idAttribute === 'function' ? idAttribute : getDefaultGetId(idAttribute);
      this._idAttribute = idAttribute;
      this._mergeStrategy = mergeStrategy;
      this._processStrategy = processStrategy;
      this.define(definition);
    }

    get key() {
      return this._key;
    }

    get idAttribute() {
      return this._idAttribute;
    }

    define(definition) {
      this.schema = Object.keys(definition).reduce((entitySchema, key) => {
        const schema = definition[key];
        return Object.assign({}, entitySchema, {
          [key]: schema
        });
      }, this.schema || {});
    }

    getId(input, parent, key) {
      return this._getId(input, parent, key);
    }

    merge(entityA, entityB) {
      return this._mergeStrategy(entityA, entityB);
    }

    normalize(input, parent, key, visit, addEntity, visitedEntities) {
      const id = this.getId(input, parent, key);
      const entityType = this.key;

      if (!(entityType in visitedEntities)) {
        visitedEntities[entityType] = {};
      }

      if (!(id in visitedEntities[entityType])) {
        visitedEntities[entityType][id] = [];
      }

      if (visitedEntities[entityType][id].some(entity => entity === input)) {
        return id;
      }

      visitedEntities[entityType][id].push(input);

      const processedEntity = this._processStrategy(input, parent, key);

      Object.keys(this.schema).forEach(key => {
        if (processedEntity.hasOwnProperty(key) && typeof processedEntity[key] === 'object') {
          const schema = this.schema[key];
          processedEntity[key] = visit(processedEntity[key], processedEntity, key, schema, addEntity, visitedEntities);
        }
      });
      addEntity(this, processedEntity, input, parent, key);
      return id;
    }

    denormalize(entity, unvisit) {
      if (isImmutable(entity)) {
        return denormalizeImmutable(this.schema, entity, unvisit);
      }

      let found = true;
      Object.keys(this.schema).forEach(key => {
        const schema = this.schema[key];
        const [value, foundItem] = unvisit(entity[key], schema);

        if (!foundItem) {
          found = false;
        }

        if (entity.hasOwnProperty(key)) {
          entity[key] = value;
        }
      });
      return [entity, found];
    }

  }

  class PolymorphicSchema {
    constructor(definition, schemaAttribute) {
      if (schemaAttribute) {
        this._schemaAttribute = typeof schemaAttribute === 'string' ? input => input[schemaAttribute] : schemaAttribute;
      }

      this.define(definition);
    }

    get isSingleSchema() {
      return !this._schemaAttribute;
    }

    define(definition) {
      this.schema = definition;
    }

    getSchemaAttribute(input, parent, key) {
      return !this.isSingleSchema && this._schemaAttribute(input, parent, key);
    }

    inferSchema(input, parent, key) {
      if (this.isSingleSchema) {
        return this.schema;
      }

      const attr = this.getSchemaAttribute(input, parent, key);
      return this.schema[attr];
    }

    normalizeValue(value, parent, key, visit, addEntity, visitedEntities) {
      const schema = this.inferSchema(value, parent, key);

      if (!schema) {
        return value;
      }

      const normalizedValue = visit(value, parent, key, schema, addEntity, visitedEntities);
      return this.isSingleSchema || normalizedValue === undefined || normalizedValue === null ? normalizedValue : {
        id: normalizedValue,
        schema: this.getSchemaAttribute(value, parent, key)
      };
    }

    denormalizeValue(value, unvisit) {
      const schemaKey = isImmutable(value) ? value.get('schema') : value.schema;

      if (!this.isSingleSchema && !schemaKey) {
        return [value, true];
      }

      const id = isImmutable(value) ? value.get('id') : value.id;
      const schema = this.isSingleSchema ? this.schema : this.schema[schemaKey];
      return unvisit(id || value, schema);
    }

  }

  class UnionSchema extends PolymorphicSchema {
    constructor(definition, schemaAttribute) {
      if (!schemaAttribute) {
        throw new Error('Expected option "schemaAttribute" not found on UnionSchema.');
      }

      super(definition, schemaAttribute);
    }

    normalize(input, parent, key, visit, addEntity, visitedEntities) {
      return this.normalizeValue(input, parent, key, visit, addEntity, visitedEntities);
    }

    denormalize(input, unvisit) {
      return this.denormalizeValue(input, unvisit);
    }

  }

  class ValuesSchema extends PolymorphicSchema {
    normalize(input, parent, key, visit, addEntity, visitedEntities) {
      return Object.keys(input).reduce((output, key, index) => {
        const value = input[key];
        return value !== undefined && value !== null ? Object.assign({}, output, {
          [key]: this.normalizeValue(value, input, key, visit, addEntity, visitedEntities)
        }) : output;
      }, {});
    }

    denormalize(input, unvisit) {
      let found = true;
      return [Object.keys(input).reduce((output, key) => {
        const entityOrId = input[key];
        const [value, foundItem] = this.denormalizeValue(entityOrId, unvisit);

        if (!foundItem) {
          found = false;
        }

        return Object.assign({}, output, {
          [key]: value
        });
      }, {}), found];
    }

  }

  const validateSchema = definition => {
    const isArray = Array.isArray(definition);

    if (isArray && definition.length > 1) {
      throw new Error("Expected schema definition to be a single schema, but found " + definition.length + ".");
    }

    return definition[0];
  };

  const getValues = input => Array.isArray(input) ? input : Object.keys(input).map(key => input[key]);

  const normalize = (schema, input, parent, key, visit, addEntity, visitedEntities) => {
    schema = validateSchema(schema);
    const values = getValues(input); // Special case: Arrays pass *their* parent on to their children, since there
    // is not any special information that can be gathered from themselves directly

    return values.map((value, index) => visit(value, parent, key, schema, addEntity, visitedEntities));
  };
  const denormalize = (schema, input, unvisit) => {
    schema = validateSchema(schema);
    let found = true;

    if (input === undefined && schema) {
      [, found] = unvisit(undefined, schema);
    }

    return [input && input.map ? input.map(entityOrId => unvisit(entityOrId, schema)).filter(([, foundItem]) => foundItem).map(([value]) => value) : input, found];
  };
  class ArraySchema extends PolymorphicSchema {
    normalize(input, parent, key, visit, addEntity, visitedEntities) {
      const values = getValues(input);
      return values.map((value, index) => this.normalizeValue(value, parent, key, visit, addEntity, visitedEntities)).filter(value => value !== undefined && value !== null);
    }

    denormalize(input, unvisit) {
      let found = true;

      if (input === undefined && this.schema) {
        [, found] = unvisit(undefined, this.schema);
      }

      return [input && input.map ? input.map(entityOrId => this.denormalizeValue(entityOrId, unvisit)).filter(([, foundItem]) => foundItem).map(([value]) => value) : input, found];
    }

  }

  const normalize$1 = (schema, input, parent, key, visit, addEntity, visitedEntities) => {
    const object = Object.assign({}, input);
    Object.keys(schema).forEach(key => {
      const localSchema = schema[key];
      const value = visit(input[key], input, key, localSchema, addEntity, visitedEntities);

      if (value === undefined || value === null) {
        delete object[key];
      } else {
        object[key] = value;
      }
    });
    return object;
  };
  const denormalize$1 = (schema, input, unvisit) => {
    if (isImmutable(input)) {
      return denormalizeImmutable(schema, input, unvisit);
    }

    const object = Object.assign({}, input);
    let found = true;
    Object.keys(schema).forEach(key => {
      const [item, foundItem] = unvisit(object[key], schema[key]);

      if (object[key] != null) {
        object[key] = item;
      }

      if (!foundItem) {
        found = false;
      }
    });
    return [object, found];
  };
  class ObjectSchema {
    constructor(definition) {
      this.define(definition);
    }

    define(definition) {
      this.schema = Object.keys(definition).reduce((entitySchema, key) => {
        const schema = definition[key];
        return Object.assign({}, entitySchema, {
          [key]: schema
        });
      }, this.schema || {});
    }

    normalize(...args) {
      return normalize$1(this.schema, ...args);
    }

    denormalize(...args) {
      return denormalize$1(this.schema, ...args);
    }

  }

  const visit = (value, parent, key, schema, addEntity, visitedEntities) => {
    if (typeof value !== 'object' || !value) {
      return value;
    }

    if (typeof schema === 'object' && (!schema.normalize || typeof schema.normalize !== 'function')) {
      const method = Array.isArray(schema) ? normalize : normalize$1;
      return method(schema, value, parent, key, visit, addEntity, visitedEntities);
    }

    return schema.normalize(value, parent, key, visit, addEntity, visitedEntities);
  };

  const addEntities = entities => (schema, processedEntity, value, parent, key) => {
    const schemaKey = schema.key;
    const id = schema.getId(value, parent, key);

    if (!(schemaKey in entities)) {
      entities[schemaKey] = {};
    }

    const existingEntity = entities[schemaKey][id];

    if (existingEntity) {
      entities[schemaKey][id] = schema.merge(existingEntity, processedEntity);
    } else {
      entities[schemaKey][id] = processedEntity;
    }
  };

  const schema = {
    Array: ArraySchema,
    Entity: EntitySchema,
    Object: ObjectSchema,
    Union: UnionSchema,
    Values: ValuesSchema
  };
  const normalize$2 = (input, schema) => {
    if (!input || typeof input !== 'object') {
      throw new Error("Unexpected input given to normalize. Expected type to be \"object\", found \"" + (input === null ? 'null' : typeof input) + "\".");
    }

    const entities = {};
    const addEntity = addEntities(entities);
    const visitedEntities = {};
    const result = visit(input, input, null, schema, addEntity, visitedEntities);
    return {
      entities,
      result
    };
  };

  const unvisitEntity = (id, schema, unvisit, getEntity, cache) => {
    const entity = getEntity(id, schema);

    if (typeof entity !== 'object' || entity === null) {
      return [entity, false];
    }

    if (!cache[schema.key]) {
      cache[schema.key] = {};
    }

    let found = true;

    if (!cache[schema.key][id]) {
      // Ensure we don't mutate it non-immutable objects
      const entityCopy = isImmutable(entity) ? entity : Object.assign({}, entity); // Need to set this first so that if it is referenced further within the
      // denormalization the reference will already exist.

      cache[schema.key][id] = entityCopy;
      [cache[schema.key][id], found] = schema.denormalize(entityCopy, unvisit);
    }

    return [cache[schema.key][id], found];
  };

  const getUnvisit = entities => {
    const cache = {};
    const getEntity = getEntities(entities);
    return function unvisit(input, schema) {
      if (typeof schema === 'object' && (!schema.denormalize || typeof schema.denormalize !== 'function')) {
        const method = Array.isArray(schema) ? denormalize : denormalize$1;
        return method(schema, input, unvisit);
      } // null is considered intentional, thus always 'found' as true


      if (input === null) {
        return [input, true];
      }

      if (schema instanceof EntitySchema) {
        // unvisitEntity just can't handle undefined
        if (input === undefined) {
          return [input, false];
        }

        return unvisitEntity(input, schema, unvisit, getEntity, cache);
      }

      if (typeof schema.denormalize === 'function') {
        return schema.denormalize(input, unvisit);
      }

      return [input, true];
    };
  };

  const getEntities = entities => {
    const isImmutable$1 = isImmutable(entities);
    return (entityOrId, schema) => {
      const schemaKey = schema.key;

      if (typeof entityOrId === 'object') {
        return entityOrId;
      }

      if (isImmutable$1) {
        return entities.getIn([schemaKey, entityOrId.toString()]);
      }

      return entities[schemaKey] && entities[schemaKey][entityOrId];
    };
  };

  const denormalize$2 = (input, schema, entities) => {
    if (typeof input !== 'undefined') {
      return getUnvisit(entities)(input, schema);
    }

    return [undefined, false];
  };

  exports.denormalize = denormalize$2;
  exports.normalize = normalize$2;
  exports.schema = schema;

  return exports;

}({}));
