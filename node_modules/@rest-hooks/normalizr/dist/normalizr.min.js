"use strict";function isImmutable(e){return!(!e||"function"!=typeof e.hasOwnProperty||!(e.hasOwnProperty("__ownerID")||e._map&&e._map.hasOwnProperty("__ownerID")))}function denormalizeImmutable(e,t,r){let i=!0;return[Object.keys(e).reduce((t,n)=>{const s=""+n,[a,o]=r(t.get(s),e[s]);return o||(i=!1),t.has(s)?t.set(s,a):t},t),i]}Object.defineProperty(exports,"__esModule",{value:!0});const getDefaultGetId=e=>t=>isImmutable(t)?t.get(e):t[e];class EntitySchema{constructor(e,t={},r={}){if(!e||"string"!=typeof e)throw new Error("Expected a string key for Entity, but found "+e+".");const{idAttribute:i="id",mergeStrategy:n=((e,t)=>Object.assign({},e,{},t)),processStrategy:s=(e=>Object.assign({},e))}=r;this._key=e,this._getId="function"==typeof i?i:getDefaultGetId(i),this._idAttribute=i,this._mergeStrategy=n,this._processStrategy=s,this.define(t)}get key(){return this._key}get idAttribute(){return this._idAttribute}define(e){this.schema=Object.keys(e).reduce((t,r)=>{const i=e[r];return Object.assign({},t,{[r]:i})},this.schema||{})}getId(e,t,r){return this._getId(e,t,r)}merge(e,t){return this._mergeStrategy(e,t)}normalize(e,t,r,i,n,s){const a=this.getId(e,t,r),o=this.key;if(o in s||(s[o]={}),a in s[o]||(s[o][a]=[]),s[o][a].some(t=>t===e))return a;s[o][a].push(e);const c=this._processStrategy(e,t,r);return Object.keys(this.schema).forEach(e=>{if(c.hasOwnProperty(e)&&"object"==typeof c[e]){const t=this.schema[e];c[e]=i(c[e],c,e,t,n,s)}}),n(this,c,e,t,r),a}denormalize(e,t){if(isImmutable(e))return denormalizeImmutable(this.schema,e,t);let r=!0;return Object.keys(this.schema).forEach(i=>{const n=this.schema[i],[s,a]=t(e[i],n);a||(r=!1),e.hasOwnProperty(i)&&(e[i]=s)}),[e,r]}}class PolymorphicSchema{constructor(e,t){t&&(this._schemaAttribute="string"==typeof t?e=>e[t]:t),this.define(e)}get isSingleSchema(){return!this._schemaAttribute}define(e){this.schema=e}getSchemaAttribute(e,t,r){return!this.isSingleSchema&&this._schemaAttribute(e,t,r)}inferSchema(e,t,r){if(this.isSingleSchema)return this.schema;const i=this.getSchemaAttribute(e,t,r);return this.schema[i]}normalizeValue(e,t,r,i,n,s){const a=this.inferSchema(e,t,r);if(!a)return e;const o=i(e,t,r,a,n,s);return this.isSingleSchema||null==o?o:{id:o,schema:this.getSchemaAttribute(e,t,r)}}denormalizeValue(e,t){const r=isImmutable(e)?e.get("schema"):e.schema;return this.isSingleSchema||r?t((isImmutable(e)?e.get("id"):e.id)||e,this.isSingleSchema?this.schema:this.schema[r]):[e,!0]}}class UnionSchema extends PolymorphicSchema{constructor(e,t){if(!t)throw new Error('Expected option "schemaAttribute" not found on UnionSchema.');super(e,t)}normalize(e,t,r,i,n,s){return this.normalizeValue(e,t,r,i,n,s)}denormalize(e,t){return this.denormalizeValue(e,t)}}class ValuesSchema extends PolymorphicSchema{normalize(e,t,r,i,n,s){return Object.keys(e).reduce((t,r,a)=>{const o=e[r];return null!=o?Object.assign({},t,{[r]:this.normalizeValue(o,e,r,i,n,s)}):t},{})}denormalize(e,t){let r=!0;return[Object.keys(e).reduce((i,n)=>{const s=e[n],[a,o]=this.denormalizeValue(s,t);return o||(r=!1),Object.assign({},i,{[n]:a})},{}),r]}}const validateSchema=e=>{if(Array.isArray(e)&&e.length>1)throw new Error("Expected schema definition to be a single schema, but found "+e.length+".");return e[0]},getValues=e=>Array.isArray(e)?e:Object.keys(e).map(t=>e[t]),normalize=(e,t,r,i,n,s,a)=>{return e=validateSchema(e),getValues(t).map((t,o)=>n(t,r,i,e,s,a))},denormalize=(e,t,r)=>{e=validateSchema(e);let i=!0;return void 0===t&&e&&([,i]=r(void 0,e)),[t&&t.map?t.map(t=>r(t,e)).filter(([,e])=>e).map(([e])=>e):t,i]};class ArraySchema extends PolymorphicSchema{normalize(e,t,r,i,n,s){return getValues(e).map((e,a)=>this.normalizeValue(e,t,r,i,n,s)).filter(e=>null!=e)}denormalize(e,t){let r=!0;return void 0===e&&this.schema&&([,r]=t(void 0,this.schema)),[e&&e.map?e.map(e=>this.denormalizeValue(e,t)).filter(([,e])=>e).map(([e])=>e):e,r]}}const normalize$1=(e,t,r,i,n,s,a)=>{const o=Object.assign({},t);return Object.keys(e).forEach(r=>{const i=e[r],c=n(t[r],t,r,i,s,a);null==c?delete o[r]:o[r]=c}),o},denormalize$1=(e,t,r)=>{if(isImmutable(t))return denormalizeImmutable(e,t,r);const i=Object.assign({},t);let n=!0;return Object.keys(e).forEach(t=>{const[s,a]=r(i[t],e[t]);null!=i[t]&&(i[t]=s),a||(n=!1)}),[i,n]};class ObjectSchema{constructor(e){this.define(e)}define(e){this.schema=Object.keys(e).reduce((t,r)=>{const i=e[r];return Object.assign({},t,{[r]:i})},this.schema||{})}normalize(...e){return normalize$1(this.schema,...e)}denormalize(...e){return denormalize$1(this.schema,...e)}}const visit=(e,t,r,i,n,s)=>{if("object"!=typeof e||!e)return e;if("object"==typeof i&&(!i.normalize||"function"!=typeof i.normalize)){return(Array.isArray(i)?normalize:normalize$1)(i,e,t,r,visit,n,s)}return i.normalize(e,t,r,visit,n,s)},addEntities=e=>(t,r,i,n,s)=>{const a=t.key,o=t.getId(i,n,s);a in e||(e[a]={});const c=e[a][o];e[a][o]=c?t.merge(c,r):r},schema={Array:ArraySchema,Entity:EntitySchema,Object:ObjectSchema,Union:UnionSchema,Values:ValuesSchema},normalize$2=(e,t)=>{if(!e||"object"!=typeof e)throw new Error('Unexpected input given to normalize. Expected type to be "object", found "'+(null===e?"null":typeof e)+'".');const r={},i=addEntities(r);return{entities:r,result:visit(e,e,null,t,i,{})}},unvisitEntity=(e,t,r,i,n)=>{const s=i(e,t);if("object"!=typeof s||null===s)return[s,!1];n[t.key]||(n[t.key]={});let a=!0;if(!n[t.key][e]){const i=isImmutable(s)?s:Object.assign({},s);n[t.key][e]=i,[n[t.key][e],a]=t.denormalize(i,r)}return[n[t.key][e],a]},getUnvisit=e=>{const t={},r=getEntities(e);return function e(i,n){if("object"==typeof n&&(!n.denormalize||"function"!=typeof n.denormalize)){return(Array.isArray(n)?denormalize:denormalize$1)(n,i,e)}return null===i?[i,!0]:n instanceof EntitySchema?void 0===i?[i,!1]:unvisitEntity(i,n,e,r,t):"function"==typeof n.denormalize?n.denormalize(i,e):[i,!0]}},getEntities=e=>{const t=isImmutable(e);return(r,i)=>{const n=i.key;return"object"==typeof r?r:t?e.getIn([n,r.toString()]):e[n]&&e[n][r]}},denormalize$2=(e,t,r)=>void 0!==e?getUnvisit(r)(e,t):[void 0,!1];exports.denormalize=denormalize$2,exports.normalize=normalize$2,exports.schema=schema;
