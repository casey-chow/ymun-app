function e(e){return!(!e||"function"!=typeof e.hasOwnProperty||!(e.hasOwnProperty("__ownerID")||e._map&&e._map.hasOwnProperty("__ownerID")))}function t(e,t,r){let n=!0;return[Object.keys(e).reduce((t,s)=>{const i=""+s,[o,c]=r(t.get(i),e[i]);return c||(n=!1),t.has(i)?t.set(i,o):t},t),n]}const r=t=>r=>e(r)?r.get(t):r[t];class n{constructor(e,t={},n={}){if(!e||"string"!=typeof e)throw new Error("Expected a string key for Entity, but found "+e+".");const{idAttribute:s="id",mergeStrategy:i=((e,t)=>Object.assign({},e,{},t)),processStrategy:o=(e=>Object.assign({},e))}=n;this._key=e,this._getId="function"==typeof s?s:r(s),this._idAttribute=s,this._mergeStrategy=i,this._processStrategy=o,this.define(t)}get key(){return this._key}get idAttribute(){return this._idAttribute}define(e){this.schema=Object.keys(e).reduce((t,r)=>{const n=e[r];return Object.assign({},t,{[r]:n})},this.schema||{})}getId(e,t,r){return this._getId(e,t,r)}merge(e,t){return this._mergeStrategy(e,t)}normalize(e,t,r,n,s,i){const o=this.getId(e,t,r),c=this.key;if(c in i||(i[c]={}),o in i[c]||(i[c][o]=[]),i[c][o].some(t=>t===e))return o;i[c][o].push(e);const a=this._processStrategy(e,t,r);return Object.keys(this.schema).forEach(e=>{if(a.hasOwnProperty(e)&&"object"==typeof a[e]){const t=this.schema[e];a[e]=n(a[e],a,e,t,s,i)}}),s(this,a,e,t,r),o}denormalize(r,n){if(e(r))return t(this.schema,r,n);let s=!0;return Object.keys(this.schema).forEach(e=>{const t=this.schema[e],[i,o]=n(r[e],t);o||(s=!1),r.hasOwnProperty(e)&&(r[e]=i)}),[r,s]}}class s{constructor(e,t){t&&(this._schemaAttribute="string"==typeof t?e=>e[t]:t),this.define(e)}get isSingleSchema(){return!this._schemaAttribute}define(e){this.schema=e}getSchemaAttribute(e,t,r){return!this.isSingleSchema&&this._schemaAttribute(e,t,r)}inferSchema(e,t,r){if(this.isSingleSchema)return this.schema;const n=this.getSchemaAttribute(e,t,r);return this.schema[n]}normalizeValue(e,t,r,n,s,i){const o=this.inferSchema(e,t,r);if(!o)return e;const c=n(e,t,r,o,s,i);return this.isSingleSchema||null==c?c:{id:c,schema:this.getSchemaAttribute(e,t,r)}}denormalizeValue(t,r){const n=e(t)?t.get("schema"):t.schema;return this.isSingleSchema||n?r((e(t)?t.get("id"):t.id)||t,this.isSingleSchema?this.schema:this.schema[n]):[t,!0]}}const i=e=>{if(Array.isArray(e)&&e.length>1)throw new Error("Expected schema definition to be a single schema, but found "+e.length+".");return e[0]},o=e=>Array.isArray(e)?e:Object.keys(e).map(t=>e[t]),c=(e,t,r,n,s,c,a)=>{return e=i(e),o(t).map((t,i)=>s(t,r,n,e,c,a))},a=(e,t,r)=>{e=i(e);let n=!0;return void 0===t&&e&&([,n]=r(void 0,e)),[t&&t.map?t.map(t=>r(t,e)).filter(([,e])=>e).map(([e])=>e):t,n]};const h=(e,t,r,n,s,i,o)=>{const c=Object.assign({},t);return Object.keys(e).forEach(r=>{const n=e[r],a=s(t[r],t,r,n,i,o);null==a?delete c[r]:c[r]=a}),c},u=(r,n,s)=>{if(e(n))return t(r,n,s);const i=Object.assign({},n);let o=!0;return Object.keys(r).forEach(e=>{const[t,n]=s(i[e],r[e]);null!=i[e]&&(i[e]=t),n||(o=!1)}),[i,o]};const l=(e,t,r,n,s,i)=>{if("object"!=typeof e||!e)return e;if("object"==typeof n&&(!n.normalize||"function"!=typeof n.normalize)){return(Array.isArray(n)?c:h)(n,e,t,r,l,s,i)}return n.normalize(e,t,r,l,s,i)},m={Array:class extends s{normalize(e,t,r,n,s,i){return o(e).map((e,o)=>this.normalizeValue(e,t,r,n,s,i)).filter(e=>null!=e)}denormalize(e,t){let r=!0;return void 0===e&&this.schema&&([,r]=t(void 0,this.schema)),[e&&e.map?e.map(e=>this.denormalizeValue(e,t)).filter(([,e])=>e).map(([e])=>e):e,r]}},Entity:n,Object:class{constructor(e){this.define(e)}define(e){this.schema=Object.keys(e).reduce((t,r)=>{const n=e[r];return Object.assign({},t,{[r]:n})},this.schema||{})}normalize(...e){return h(this.schema,...e)}denormalize(...e){return u(this.schema,...e)}},Union:class extends s{constructor(e,t){if(!t)throw new Error('Expected option "schemaAttribute" not found on UnionSchema.');super(e,t)}normalize(e,t,r,n,s,i){return this.normalizeValue(e,t,r,n,s,i)}denormalize(e,t){return this.denormalizeValue(e,t)}},Values:class extends s{normalize(e,t,r,n,s,i){return Object.keys(e).reduce((t,r,o)=>{const c=e[r];return null!=c?Object.assign({},t,{[r]:this.normalizeValue(c,e,r,n,s,i)}):t},{})}denormalize(e,t){let r=!0;return[Object.keys(e).reduce((n,s)=>{const i=e[s],[o,c]=this.denormalizeValue(i,t);return c||(r=!1),Object.assign({},n,{[s]:o})},{}),r]}}},y=(e,t)=>{if(!e||"object"!=typeof e)throw new Error('Unexpected input given to normalize. Expected type to be "object", found "'+(null===e?"null":typeof e)+'".');const r={},n=(e=>(t,r,n,s,i)=>{const o=t.key,c=t.getId(n,s,i);o in e||(e[o]={});const a=e[o][c];e[o][c]=a?t.merge(a,r):r})(r);return{entities:r,result:l(e,e,null,t,n,{})}},d=t=>{const r={},s=f(t);return function t(i,o){if("object"==typeof o&&(!o.denormalize||"function"!=typeof o.denormalize)){return(Array.isArray(o)?a:u)(o,i,t)}return null===i?[i,!0]:o instanceof n?void 0===i?[i,!1]:((t,r,n,s,i)=>{const o=s(t,r);if("object"!=typeof o||null===o)return[o,!1];i[r.key]||(i[r.key]={});let c=!0;if(!i[r.key][t]){const s=e(o)?o:Object.assign({},o);i[r.key][t]=s,[i[r.key][t],c]=r.denormalize(s,n)}return[i[r.key][t],c]})(i,o,t,s,r):"function"==typeof o.denormalize?o.denormalize(i,t):[i,!0]}},f=t=>{const r=e(t);return(e,n)=>{const s=n.key;return"object"==typeof e?e:r?t.getIn([s,e.toString()]):t[s]&&t[s][e]}},g=(e,t,r)=>void 0!==e?d(r)(e,t):[void 0,!1];export{g as denormalize,y as normalize,m as schema};
