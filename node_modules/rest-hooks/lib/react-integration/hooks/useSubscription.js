import { useContext, useEffect, useRef } from 'react';
import { DispatchContext } from "../context";

/** Keeps a resource fresh by subscribing to updates. */
export default function useSubscription(fetchShape, params) {
  var dispatch = useContext(DispatchContext);
  /*
  we just want the current values when we dispatch, so
  box the shape in a ref to make react-hooks/exhaustive-deps happy
   "Although useEffect is deferred until after the browser has painted, it’s guaranteed to fire before any new renders.
  React will always flush a previous render’s effects before starting a new update." - https://reactjs.org/docs/hooks-reference.html#useeffect
  */

  var shapeRef = useRef(fetchShape);
  shapeRef.current = fetchShape;
  useEffect(function () {
    if (!params) return;
    var _shapeRef$current = shapeRef.current,
        _fetch = _shapeRef$current.fetch,
        schema = _shapeRef$current.schema,
        getFetchKey = _shapeRef$current.getFetchKey,
        options = _shapeRef$current.options;
    var url = getFetchKey(params);
    dispatch({
      type: 'rest-hooks/subscribe',
      meta: {
        schema: schema,
        fetch: function fetch() {
          return _fetch(params);
        },
        url: url,
        frequency: options && options.pollFrequency
      }
    });
    return function () {
      dispatch({
        type: 'rest-hooks/unsubscribe',
        meta: {
          url: url,
          frequency: options && options.pollFrequency
        }
      });
    }; // serialize params
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dispatch, params && fetchShape.getFetchKey(params)]);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFjdC1pbnRlZ3JhdGlvbi9ob29rcy91c2VTdWJzY3JpcHRpb24udHMiXSwibmFtZXMiOlsidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZVJlZiIsIkRpc3BhdGNoQ29udGV4dCIsInVzZVN1YnNjcmlwdGlvbiIsImZldGNoU2hhcGUiLCJwYXJhbXMiLCJkaXNwYXRjaCIsInNoYXBlUmVmIiwiY3VycmVudCIsImZldGNoIiwic2NoZW1hIiwiZ2V0RmV0Y2hLZXkiLCJvcHRpb25zIiwidXJsIiwidHlwZSIsIm1ldGEiLCJmcmVxdWVuY3kiLCJwb2xsRnJlcXVlbmN5Il0sIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxVQUFULEVBQXFCQyxTQUFyQixFQUFnQ0MsTUFBaEMsUUFBOEMsT0FBOUM7QUFFQSxTQUFTQyxlQUFULFFBQWdDLFlBQWhDOztBQUdBO0FBQ0EsZUFBZSxTQUFTQyxlQUFULENBR2JDLFVBSGEsRUFHcUJDLE1BSHJCLEVBRzRDO0FBQ3pELE1BQU1DLFFBQVEsR0FBR1AsVUFBVSxDQUFDRyxlQUFELENBQTNCO0FBQ0E7Ozs7Ozs7QUFPQSxNQUFNSyxRQUFRLEdBQUdOLE1BQU0sQ0FBQ0csVUFBRCxDQUF2QjtBQUNBRyxFQUFBQSxRQUFRLENBQUNDLE9BQVQsR0FBbUJKLFVBQW5CO0FBRUFKLEVBQUFBLFNBQVMsQ0FBQyxZQUFNO0FBQ2QsUUFBSSxDQUFDSyxNQUFMLEVBQWE7QUFEQyw0QkFFa0NFLFFBQVEsQ0FBQ0MsT0FGM0M7QUFBQSxRQUVOQyxNQUZNLHFCQUVOQSxLQUZNO0FBQUEsUUFFQ0MsTUFGRCxxQkFFQ0EsTUFGRDtBQUFBLFFBRVNDLFdBRlQscUJBRVNBLFdBRlQ7QUFBQSxRQUVzQkMsT0FGdEIscUJBRXNCQSxPQUZ0QjtBQUdkLFFBQU1DLEdBQUcsR0FBR0YsV0FBVyxDQUFDTixNQUFELENBQXZCO0FBRUFDLElBQUFBLFFBQVEsQ0FBQztBQUNQUSxNQUFBQSxJQUFJLEVBQUUsc0JBREM7QUFFUEMsTUFBQUEsSUFBSSxFQUFFO0FBQ0pMLFFBQUFBLE1BQU0sRUFBTkEsTUFESTtBQUVKRCxRQUFBQSxLQUFLLEVBQUU7QUFBQSxpQkFBTUEsTUFBSyxDQUFDSixNQUFELENBQVg7QUFBQSxTQUZIO0FBR0pRLFFBQUFBLEdBQUcsRUFBSEEsR0FISTtBQUlKRyxRQUFBQSxTQUFTLEVBQUVKLE9BQU8sSUFBSUEsT0FBTyxDQUFDSztBQUoxQjtBQUZDLEtBQUQsQ0FBUjtBQVNBLFdBQU8sWUFBTTtBQUNYWCxNQUFBQSxRQUFRLENBQUM7QUFDUFEsUUFBQUEsSUFBSSxFQUFFLHdCQURDO0FBRVBDLFFBQUFBLElBQUksRUFBRTtBQUNKRixVQUFBQSxHQUFHLEVBQUhBLEdBREk7QUFFSkcsVUFBQUEsU0FBUyxFQUFFSixPQUFPLElBQUlBLE9BQU8sQ0FBQ0s7QUFGMUI7QUFGQyxPQUFELENBQVI7QUFPRCxLQVJELENBZGMsQ0F1QmQ7QUFDQTtBQUNELEdBekJRLEVBeUJOLENBQUNYLFFBQUQsRUFBV0QsTUFBTSxJQUFJRCxVQUFVLENBQUNPLFdBQVgsQ0FBdUJOLE1BQXZCLENBQXJCLENBekJNLENBQVQ7QUEwQkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgRGlzcGF0Y2hDb250ZXh0IH0gZnJvbSAnfi9yZWFjdC1pbnRlZ3JhdGlvbi9jb250ZXh0JztcbmltcG9ydCB7IFJlYWRTaGFwZSwgU2NoZW1hIH0gZnJvbSAnfi9yZXNvdXJjZSc7XG5cbi8qKiBLZWVwcyBhIHJlc291cmNlIGZyZXNoIGJ5IHN1YnNjcmliaW5nIHRvIHVwZGF0ZXMuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VTdWJzY3JpcHRpb248XG4gIFBhcmFtcyBleHRlbmRzIFJlYWRvbmx5PG9iamVjdD4sXG4gIFMgZXh0ZW5kcyBTY2hlbWFcbj4oZmV0Y2hTaGFwZTogUmVhZFNoYXBlPFMsIFBhcmFtcz4sIHBhcmFtczogUGFyYW1zIHwgbnVsbCkge1xuICBjb25zdCBkaXNwYXRjaCA9IHVzZUNvbnRleHQoRGlzcGF0Y2hDb250ZXh0KTtcbiAgLypcbiAgd2UganVzdCB3YW50IHRoZSBjdXJyZW50IHZhbHVlcyB3aGVuIHdlIGRpc3BhdGNoLCBzb1xuICBib3ggdGhlIHNoYXBlIGluIGEgcmVmIHRvIG1ha2UgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzIGhhcHB5XG5cbiAgXCJBbHRob3VnaCB1c2VFZmZlY3QgaXMgZGVmZXJyZWQgdW50aWwgYWZ0ZXIgdGhlIGJyb3dzZXIgaGFzIHBhaW50ZWQsIGl04oCZcyBndWFyYW50ZWVkIHRvIGZpcmUgYmVmb3JlIGFueSBuZXcgcmVuZGVycy5cbiAgUmVhY3Qgd2lsbCBhbHdheXMgZmx1c2ggYSBwcmV2aW91cyByZW5kZXLigJlzIGVmZmVjdHMgYmVmb3JlIHN0YXJ0aW5nIGEgbmV3IHVwZGF0ZS5cIiAtIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9ob29rcy1yZWZlcmVuY2UuaHRtbCN1c2VlZmZlY3RcbiAgKi9cbiAgY29uc3Qgc2hhcGVSZWYgPSB1c2VSZWYoZmV0Y2hTaGFwZSk7XG4gIHNoYXBlUmVmLmN1cnJlbnQgPSBmZXRjaFNoYXBlO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFwYXJhbXMpIHJldHVybjtcbiAgICBjb25zdCB7IGZldGNoLCBzY2hlbWEsIGdldEZldGNoS2V5LCBvcHRpb25zIH0gPSBzaGFwZVJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHVybCA9IGdldEZldGNoS2V5KHBhcmFtcyk7XG5cbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiAncmVzdC1ob29rcy9zdWJzY3JpYmUnLFxuICAgICAgbWV0YToge1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGZldGNoOiAoKSA9PiBmZXRjaChwYXJhbXMpLFxuICAgICAgICB1cmwsXG4gICAgICAgIGZyZXF1ZW5jeTogb3B0aW9ucyAmJiBvcHRpb25zLnBvbGxGcmVxdWVuY3ksXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdyZXN0LWhvb2tzL3Vuc3Vic2NyaWJlJyxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBmcmVxdWVuY3k6IG9wdGlvbnMgJiYgb3B0aW9ucy5wb2xsRnJlcXVlbmN5LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBzZXJpYWxpemUgcGFyYW1zXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbZGlzcGF0Y2gsIHBhcmFtcyAmJiBmZXRjaFNoYXBlLmdldEZldGNoS2V5KHBhcmFtcyldKTtcbn1cbiJdfQ==