/// <reference types="react" />
import { MiddlewareAPI, SubscribeAction, UnsubscribeAction, Manager, Dispatch } from "../types";
import { Schema } from "../resource";
declare type Actions = UnsubscribeAction | SubscribeAction;
/** Properties sent to Subscription constructor */
export interface SubscriptionInit {
    schema: Schema;
    fetch: () => Promise<any>;
    url: string;
    frequency?: number;
}
/** Interface handling a single resource subscription */
export interface Subscription {
    add(frequency?: number): void;
    remove(frequency?: number): boolean;
    cleanup(): void;
}
/** The static class that constructs Subscription */
export interface SubscriptionConstructable {
    new (init: SubscriptionInit, dispatch: Dispatch<any>): Subscription;
}
/** Handles subscription actions -> fetch or receive actions
 *
 * Constructor takes a SubscriptionConstructable class to control how
 * subscriptions are handled. (e.g., polling, websockets)
 */
export default class SubscriptionManager<S extends SubscriptionConstructable> implements Manager {
    protected subscriptions: {
        [url: string]: InstanceType<S>;
    };
    protected readonly Subscription: S;
    constructor(Subscription: S);
    /** Ensures all subscriptions are cleaned up. */
    cleanup(): void;
    /** Called when middleware intercepts 'rest-hooks/subscribe' action.
     *
     */
    protected handleSubscribe(action: SubscribeAction, dispatch: Dispatch<any>): void;
    /** Called when middleware intercepts 'rest-hooks/unsubscribe' action.
     *
     */
    protected handleUnsubscribe(action: UnsubscribeAction, dispatch: Dispatch<any>): void;
    /** Attaches Manager to store
     *
     * Intercepts 'rest-hooks/subscribe'/'rest-hooks/unsubscribe' to register resources that
     * need to be kept up to date.
     *
     * Will possibly dispatch 'rest-hooks/fetch' or 'rest-hooks/receive' to keep resources fresh
     *
     */
    getMiddleware<T extends SubscriptionManager<S>>(this: T): <R extends import("react").Reducer<any, A>, A extends Actions>({ dispatch, }: MiddlewareAPI<R>) => (next: Dispatch<R>) => (action: Actions) => Promise<void>;
}
export {};
