import { useMemo } from 'react';
import getEntityPath from './getEntityPath';
import useDenormalizedLegacy from './useDenormalizedLegacy';
export default function useSchemaSelect(_ref, params, state) {
  var schema = _ref.schema,
      getFetchKey = _ref.getFetchKey;
  var denormalized = useDenormalizedLegacy({
    schema: schema,
    getFetchKey: getFetchKey
  }, params, state); // eslint-disable-next-line react-hooks/exhaustive-deps

  var getItemsFromResults = useMemo(function () {
    return resultFinderFromSchema(schema);
  }, []);
  var output = useMemo(function () {
    return getItemsFromResults && denormalized ? getItemsFromResults(denormalized) : denormalized;
  }, [denormalized, getItemsFromResults]);
  if (output === undefined) return null;
  return output;
} // TODO: there should honestly be a way to use the pre-existing normalizr object
// to not even need this implementation

export function resultFinderFromSchema(schema) {
  var path = getEntityPath(schema);
  if (path === false) throw new Error('Schema invalid - no path to entity found');
  if (path.length === 0) return null;
  return function (results) {
    var cur = results;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = path[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var p = _step.value;
        cur = cur[p];
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return cur;
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zdGF0ZS9zZWxlY3RvcnMvdXNlU2NoZW1hU2VsZWN0LnRzIl0sIm5hbWVzIjpbInVzZU1lbW8iLCJnZXRFbnRpdHlQYXRoIiwidXNlRGVub3JtYWxpemVkTGVnYWN5IiwidXNlU2NoZW1hU2VsZWN0IiwicGFyYW1zIiwic3RhdGUiLCJzY2hlbWEiLCJnZXRGZXRjaEtleSIsImRlbm9ybWFsaXplZCIsImdldEl0ZW1zRnJvbVJlc3VsdHMiLCJyZXN1bHRGaW5kZXJGcm9tU2NoZW1hIiwib3V0cHV0IiwidW5kZWZpbmVkIiwicGF0aCIsIkVycm9yIiwibGVuZ3RoIiwicmVzdWx0cyIsImN1ciIsInAiXSwibWFwcGluZ3MiOiJBQUFBLFNBQVNBLE9BQVQsUUFBd0IsT0FBeEI7QUFJQSxPQUFPQyxhQUFQLE1BQTBCLGlCQUExQjtBQUNBLE9BQU9DLHFCQUFQLE1BQWtDLHlCQUFsQztBQUVBLGVBQWUsU0FBU0MsZUFBVCxPQUtiQyxNQUxhLEVBTWJDLEtBTmEsRUFPeUQ7QUFBQSxNQUhwRUMsTUFHb0UsUUFIcEVBLE1BR29FO0FBQUEsTUFINURDLFdBRzRELFFBSDVEQSxXQUc0RDtBQUN0RSxNQUFNQyxZQUFpQixHQUFHTixxQkFBcUIsQ0FDN0M7QUFBRUksSUFBQUEsTUFBTSxFQUFOQSxNQUFGO0FBQVVDLElBQUFBLFdBQVcsRUFBWEE7QUFBVixHQUQ2QyxFQUU3Q0gsTUFGNkMsRUFHN0NDLEtBSDZDLENBQS9DLENBRHNFLENBTXRFOztBQUNBLE1BQU1JLG1CQUFtQixHQUFHVCxPQUFPLENBQUM7QUFBQSxXQUFNVSxzQkFBc0IsQ0FBQ0osTUFBRCxDQUE1QjtBQUFBLEdBQUQsRUFBdUMsRUFBdkMsQ0FBbkM7QUFDQSxNQUFNSyxNQUFNLEdBQUdYLE9BQU8sQ0FDcEI7QUFBQSxXQUNFUyxtQkFBbUIsSUFBSUQsWUFBdkIsR0FDSUMsbUJBQW1CLENBQUNELFlBQUQsQ0FEdkIsR0FFSUEsWUFITjtBQUFBLEdBRG9CLEVBS3BCLENBQUNBLFlBQUQsRUFBZUMsbUJBQWYsQ0FMb0IsQ0FBdEI7QUFPQSxNQUFJRSxNQUFNLEtBQUtDLFNBQWYsRUFBMEIsT0FBTyxJQUFQO0FBQzFCLFNBQU9ELE1BQVA7QUFDRCxDLENBRUQ7QUFDQTs7QUFDQSxPQUFPLFNBQVNELHNCQUFULENBQ0xKLE1BREssRUFFbUM7QUFDeEMsTUFBTU8sSUFBSSxHQUFHWixhQUFhLENBQUNLLE1BQUQsQ0FBMUI7QUFDQSxNQUFJTyxJQUFJLEtBQUssS0FBYixFQUNFLE1BQU0sSUFBSUMsS0FBSixDQUFVLDBDQUFWLENBQU47QUFDRixNQUFJRCxJQUFJLENBQUNFLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUIsT0FBTyxJQUFQO0FBQ3ZCLFNBQU8sVUFBQUMsT0FBTyxFQUFJO0FBQ2hCLFFBQUlDLEdBQUcsR0FBR0QsT0FBVjtBQURnQjtBQUFBO0FBQUE7O0FBQUE7QUFFaEIsMkJBQWdCSCxJQUFoQiw4SEFBc0I7QUFBQSxZQUFYSyxDQUFXO0FBQ3BCRCxRQUFBQSxHQUFHLEdBQUdBLEdBQUcsQ0FBQ0MsQ0FBRCxDQUFUO0FBQ0Q7QUFKZTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUtoQixXQUFPRCxHQUFQO0FBQ0QsR0FORDtBQU9EIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFN0YXRlIH0gZnJvbSAnfi90eXBlcyc7XG5pbXBvcnQgeyBTY2hlbWFPZiwgUmVhZFNoYXBlIH0gZnJvbSAnfi9yZXNvdXJjZS90eXBlcyc7XG5pbXBvcnQgeyBTY2hlbWEgfSBmcm9tICd+L3Jlc291cmNlL25vcm1hbCc7XG5pbXBvcnQgZ2V0RW50aXR5UGF0aCBmcm9tICcuL2dldEVudGl0eVBhdGgnO1xuaW1wb3J0IHVzZURlbm9ybWFsaXplZExlZ2FjeSBmcm9tICcuL3VzZURlbm9ybWFsaXplZExlZ2FjeSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZVNjaGVtYVNlbGVjdDxcbiAgUGFyYW1zIGV4dGVuZHMgUmVhZG9ubHk8b2JqZWN0PixcbiAgUyBleHRlbmRzIFNjaGVtYVxuPihcbiAgeyBzY2hlbWEsIGdldEZldGNoS2V5IH06IFBpY2s8UmVhZFNoYXBlPFMsIFBhcmFtcz4sICdzY2hlbWEnIHwgJ2dldEZldGNoS2V5Jz4sXG4gIHBhcmFtczogUGFyYW1zIHwgbnVsbCxcbiAgc3RhdGU6IFN0YXRlPGFueT4sXG4pOiB0eXBlb2YgcGFyYW1zIGV4dGVuZHMgbnVsbCA/IG51bGwgOiAoU2NoZW1hT2Y8dHlwZW9mIHNjaGVtYT4gfCBudWxsKSB7XG4gIGNvbnN0IGRlbm9ybWFsaXplZDogYW55ID0gdXNlRGVub3JtYWxpemVkTGVnYWN5KFxuICAgIHsgc2NoZW1hLCBnZXRGZXRjaEtleSB9LFxuICAgIHBhcmFtcyxcbiAgICBzdGF0ZSxcbiAgKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBjb25zdCBnZXRJdGVtc0Zyb21SZXN1bHRzID0gdXNlTWVtbygoKSA9PiByZXN1bHRGaW5kZXJGcm9tU2NoZW1hKHNjaGVtYSksIFtdKTtcbiAgY29uc3Qgb3V0cHV0ID0gdXNlTWVtbyhcbiAgICAoKSA9PlxuICAgICAgZ2V0SXRlbXNGcm9tUmVzdWx0cyAmJiBkZW5vcm1hbGl6ZWRcbiAgICAgICAgPyBnZXRJdGVtc0Zyb21SZXN1bHRzKGRlbm9ybWFsaXplZClcbiAgICAgICAgOiBkZW5vcm1hbGl6ZWQsXG4gICAgW2Rlbm9ybWFsaXplZCwgZ2V0SXRlbXNGcm9tUmVzdWx0c10sXG4gICk7XG4gIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGwgYXMgYW55O1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBUT0RPOiB0aGVyZSBzaG91bGQgaG9uZXN0bHkgYmUgYSB3YXkgdG8gdXNlIHRoZSBwcmUtZXhpc3Rpbmcgbm9ybWFsaXpyIG9iamVjdFxuLy8gdG8gbm90IGV2ZW4gbmVlZCB0aGlzIGltcGxlbWVudGF0aW9uXG5leHBvcnQgZnVuY3Rpb24gcmVzdWx0RmluZGVyRnJvbVNjaGVtYTxTIGV4dGVuZHMgU2NoZW1hPihcbiAgc2NoZW1hOiBTLFxuKTogbnVsbCB8ICgocmVzdWx0czogYW55KSA9PiBTY2hlbWFPZjxTPikge1xuICBjb25zdCBwYXRoID0gZ2V0RW50aXR5UGF0aChzY2hlbWEpO1xuICBpZiAocGF0aCA9PT0gZmFsc2UpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTY2hlbWEgaW52YWxpZCAtIG5vIHBhdGggdG8gZW50aXR5IGZvdW5kJyk7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiByZXN1bHRzID0+IHtcbiAgICBsZXQgY3VyID0gcmVzdWx0cztcbiAgICBmb3IgKGNvbnN0IHAgb2YgcGF0aCkge1xuICAgICAgY3VyID0gY3VyW3BdO1xuICAgIH1cbiAgICByZXR1cm4gY3VyO1xuICB9O1xufVxuIl19