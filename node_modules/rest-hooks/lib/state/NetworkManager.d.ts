/// <reference types="react" />
/// <reference types="lodash" />
import { FetchAction, ReceiveAction, MiddlewareAPI, Manager, Dispatch } from "../types";
/** Handles all async network dispatches
 *
 * Dedupes concurrent requests by keeping track of all fetches in flight
 * and returning existing promises for requests already in flight.
 *
 * Interfaces with store via a redux-compatible middleware.
 */
export default class NetworkManager implements Manager {
    protected fetched: {
        [k: string]: Promise<any>;
    };
    protected resolvers: {
        [k: string]: (value?: any) => void;
    };
    protected rejectors: {
        [k: string]: (value?: any) => void;
    };
    readonly dataExpiryLength: number;
    readonly errorExpiryLength: number;
    constructor(dataExpiryLength?: number, errorExpiryLength?: number);
    /** Ensures all promises are completed by rejecting remaining. */
    cleanup(): void;
    /** Clear promise state for a given url */
    protected clear(url: string): void;
    /** Called when middleware intercepts 'rest-hooks/fetch' action.
     *
     * Will then start a promise for a url and potentially start the network
     * fetch.
     *
     * Uses throttle only when instructed by action meta. This is valuable
     * for ensures mutation requests always go through.
     */
    protected handleFetch(action: FetchAction, dispatch: Dispatch<any>): Promise<any>;
    /** Called when middleware intercepts a receive action.
     *
     * Will resolve the promise associated with receive url.
     */
    protected handleReceive(action: ReceiveAction): void;
    /** Attaches NetworkManager to store
     *
     * Intercepts 'rest-hooks/fetch' actions to start requests.
     *
     * Resolve/rejects a request when matching 'rest-hooks/receive' event
     * is seen.
     */
    getMiddleware: ((this: NetworkManager) => <R extends import("react").Reducer<any, any>>({ dispatch, }: MiddlewareAPI<R>) => (next: Dispatch<R>) => (action: import("react").ReducerAction<R>) => Promise<void>) & import("lodash").MemoizedFunction;
    /** Ensures only one request for a given url is in flight at any time
     *
     * Uses url as key to either retrieve in-flight promise, or if not
     * create a new promise and call fetch.
     *
     * Note: The new promise is not actually tied to fetch at all,
     * but is resolved when the expected 'recieve' action is processed.
     * This ensures promises are resolved only once their data is processed
     * by the reducer.
     */
    protected throttle(url: string, fetch: () => Promise<any>): Promise<any>;
}
