import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _memoize from "lodash/memoize";
import RIC from './RIC';
/** Handles all async network dispatches
 *
 * Dedupes concurrent requests by keeping track of all fetches in flight
 * and returning existing promises for requests already in flight.
 *
 * Interfaces with store via a redux-compatible middleware.
 */

var NetworkManager =
/*#__PURE__*/
function () {
  function NetworkManager() {
    var dataExpiryLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 60000;
    var errorExpiryLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;

    _classCallCheck(this, NetworkManager);

    _defineProperty(this, "fetched", {});

    _defineProperty(this, "resolvers", {});

    _defineProperty(this, "rejectors", {});

    _defineProperty(this, "dataExpiryLength", void 0);

    _defineProperty(this, "errorExpiryLength", void 0);

    _defineProperty(this, "getMiddleware", _memoize(function () {
      var _this = this;

      return function (_ref) {
        var dispatch = _ref.dispatch;
        return function (next) {
          return function (action) {
            switch (action.type) {
              case 'rest-hooks/fetch':
                _this.handleFetch(action, dispatch);

                return Promise.resolve();

              case 'rest-hooks/purge':
              case 'rest-hooks/rpc':
              case 'rest-hooks/receive':
                // only receive after new state is computed
                return next(action).then(function () {
                  if (action.meta.url in _this.fetched) {
                    _this.handleReceive(action);
                  }
                });

              case 'rest-hooks/reset':
                _this.cleanup();

                return next(action);

              default:
                return next(action);
            }
          };
        };
      };
    }));

    this.dataExpiryLength = dataExpiryLength;
    this.errorExpiryLength = errorExpiryLength;
  }
  /** Ensures all promises are completed by rejecting remaining. */


  _createClass(NetworkManager, [{
    key: "cleanup",
    value: function cleanup() {
      for (var _k in this.rejectors) {
        var error = new Error('Cleaning up Network Manager');
        error.name = 'CLEANUP';

        this.rejectors[_k](error);
      }
    }
    /** Clear promise state for a given url */

  }, {
    key: "clear",
    value: function clear(url) {
      delete this.resolvers[url];
      delete this.rejectors[url];
      delete this.fetched[url];
    }
    /** Called when middleware intercepts 'rest-hooks/fetch' action.
     *
     * Will then start a promise for a url and potentially start the network
     * fetch.
     *
     * Uses throttle only when instructed by action meta. This is valuable
     * for ensures mutation requests always go through.
     */

  }, {
    key: "handleFetch",
    value: function handleFetch(action, dispatch) {
      var fetch = action.payload;
      var _action$meta = action.meta,
          schema = _action$meta.schema,
          url = _action$meta.url,
          responseType = _action$meta.responseType,
          throttle = _action$meta.throttle,
          resolve = _action$meta.resolve,
          updaters = _action$meta.updaters,
          reject = _action$meta.reject,
          _action$meta$options = _action$meta.options,
          options = _action$meta$options === void 0 ? {} : _action$meta$options;
      var _options$dataExpiryLe = options.dataExpiryLength,
          dataExpiryLength = _options$dataExpiryLe === void 0 ? this.dataExpiryLength : _options$dataExpiryLe,
          _options$errorExpiryL = options.errorExpiryLength,
          errorExpiryLength = _options$errorExpiryL === void 0 ? this.errorExpiryLength : _options$errorExpiryL;

      var deferedFetch = function deferedFetch() {
        return fetch().then(function (data) {
          var now = Date.now();
          var meta = {
            schema: schema,
            url: url,
            date: now,
            expiresAt: now + dataExpiryLength
          };

          if (['rest-hooks/receive', 'rest-hooks/rpc'].includes(responseType)) {
            meta.updaters = updaters;
          }

          dispatch({
            type: responseType,
            payload: data,
            meta: meta
          });
          return data;
        })["catch"](function (error) {
          if (error.name === 'CLEANUP') return;
          var now = Date.now();
          dispatch({
            type: responseType,
            payload: error,
            meta: {
              schema: schema,
              url: url,
              date: now,
              expiresAt: now + errorExpiryLength
            },
            error: true
          });
          throw error;
        });
      };

      var promise;

      if (throttle) {
        promise = this.throttle(url, deferedFetch);
      } else {
        promise = deferedFetch();
      }

      promise.then(function (data) {
        return resolve(data);
      })["catch"](function (error) {
        return reject(error);
      });
      return promise;
    }
    /** Called when middleware intercepts a receive action.
     *
     * Will resolve the promise associated with receive url.
     */

  }, {
    key: "handleReceive",
    value: function handleReceive(action) {
      // this can still turn out to be untrue since this is async
      if (action.meta.url in this.fetched) {
        var promiseHandler;

        if (action.error) {
          promiseHandler = this.rejectors[action.meta.url];
        } else {
          promiseHandler = this.resolvers[action.meta.url];
        }

        promiseHandler(action.payload); // since we're resolved we no longer need to keep track of this promise

        this.clear(action.meta.url);
      }
    }
    /** Attaches NetworkManager to store
     *
     * Intercepts 'rest-hooks/fetch' actions to start requests.
     *
     * Resolve/rejects a request when matching 'rest-hooks/receive' event
     * is seen.
     */

  }, {
    key: "throttle",

    /** Ensures only one request for a given url is in flight at any time
     *
     * Uses url as key to either retrieve in-flight promise, or if not
     * create a new promise and call fetch.
     *
     * Note: The new promise is not actually tied to fetch at all,
     * but is resolved when the expected 'recieve' action is processed.
     * This ensures promises are resolved only once their data is processed
     * by the reducer.
     */
    value: function throttle(url, fetch) {
      var _this2 = this;

      // we're already fetching so reuse the promise
      if (url in this.fetched) {
        return this.fetched[url];
      }

      this.fetched[url] = new Promise(function (resolve, reject) {
        _this2.resolvers[url] = resolve;
        _this2.rejectors[url] = reject;
      }); // since our real promise is resolved via the wrapReducer(),
      // we should just stop all errors here.
      // TODO: decouple this from useFetcher() (that's what's dispatching the error the resolves in here)

      RIC(function () {
        fetch()["catch"](function () {
          return null;
        });
      }, {
        timeout: 500
      });
      return this.fetched[url];
    }
  }]);

  return NetworkManager;
}();

export { NetworkManager as default };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdGF0ZS9OZXR3b3JrTWFuYWdlci50cyJdLCJuYW1lcyI6WyJSSUMiLCJOZXR3b3JrTWFuYWdlciIsImRhdGFFeHBpcnlMZW5ndGgiLCJlcnJvckV4cGlyeUxlbmd0aCIsImRpc3BhdGNoIiwibmV4dCIsImFjdGlvbiIsInR5cGUiLCJoYW5kbGVGZXRjaCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsIm1ldGEiLCJ1cmwiLCJmZXRjaGVkIiwiaGFuZGxlUmVjZWl2ZSIsImNsZWFudXAiLCJrIiwicmVqZWN0b3JzIiwiZXJyb3IiLCJFcnJvciIsIm5hbWUiLCJyZXNvbHZlcnMiLCJmZXRjaCIsInBheWxvYWQiLCJzY2hlbWEiLCJyZXNwb25zZVR5cGUiLCJ0aHJvdHRsZSIsInVwZGF0ZXJzIiwicmVqZWN0Iiwib3B0aW9ucyIsImRlZmVyZWRGZXRjaCIsImRhdGEiLCJub3ciLCJEYXRlIiwiZGF0ZSIsImV4cGlyZXNBdCIsImluY2x1ZGVzIiwicHJvbWlzZSIsInByb21pc2VIYW5kbGVyIiwiY2xlYXIiLCJ0aW1lb3V0Il0sIm1hcHBpbmdzIjoiOzs7O0FBVUEsT0FBT0EsR0FBUCxNQUFnQixPQUFoQjtBQUVBOzs7Ozs7OztJQU9xQkMsYzs7O0FBTW5CLDRCQUFnRTtBQUFBLFFBQXBEQyxnQkFBb0QsdUVBQWpDLEtBQWlDO0FBQUEsUUFBMUJDLGlCQUEwQix1RUFBTixJQUFNOztBQUFBOztBQUFBLHFDQUxiLEVBS2E7O0FBQUEsdUNBSkYsRUFJRTs7QUFBQSx1Q0FIRixFQUdFOztBQUFBOztBQUFBOztBQUFBLDJDQXlIaEQsU0FBUSxZQUE0QztBQUFBOztBQUNsRSxhQUFPLGdCQUVpQjtBQUFBLFlBRHRCQyxRQUNzQixRQUR0QkEsUUFDc0I7QUFDdEIsZUFBTyxVQUFDQyxJQUFEO0FBQUEsaUJBQXVCLFVBQzVCQyxNQUQ0QixFQUVWO0FBQ2xCLG9CQUFRQSxNQUFNLENBQUNDLElBQWY7QUFDRSxtQkFBSyxrQkFBTDtBQUNFLGdCQUFB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QUFDSnVCLFFBQUFBLEtBQUssV0FBTCxDQUFjO0FBQUEsaUJBQU0sSUFBTjtBQUFBLFNBQWQ7QUFDRCxPQUhBLEVBSUQ7QUFBRWtCLFFBQUFBLE9BQU8sRUFBRTtBQUFYLE9BSkMsQ0FBSDtBQU9BLGFBQU8sS0FBSzNCLE9BQUwsQ0FBYUQsR0FBYixDQUFQO0FBQ0Q7Ozs7OztTQTdMa0JaLGMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtZW1vaXplIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7XG4gIEZldGNoQWN0aW9uLFxuICBSZWNlaXZlQWN0aW9uLFxuICBNaWRkbGV3YXJlQVBJLFxuICBNYW5hZ2VyLFxuICBQdXJnZUFjdGlvbixcbiAgRGlzcGF0Y2gsXG59IGZyb20gJ34vdHlwZXMnO1xuaW1wb3J0IHsgUlBDQWN0aW9uIH0gZnJvbSAnLi4nO1xuaW1wb3J0IFJJQyBmcm9tICcuL1JJQyc7XG5cbi8qKiBIYW5kbGVzIGFsbCBhc3luYyBuZXR3b3JrIGRpc3BhdGNoZXNcbiAqXG4gKiBEZWR1cGVzIGNvbmN1cnJlbnQgcmVxdWVzdHMgYnkga2VlcGluZyB0cmFjayBvZiBhbGwgZmV0Y2hlcyBpbiBmbGlnaHRcbiAqIGFuZCByZXR1cm5pbmcgZXhpc3RpbmcgcHJvbWlzZXMgZm9yIHJlcXVlc3RzIGFscmVhZHkgaW4gZmxpZ2h0LlxuICpcbiAqIEludGVyZmFjZXMgd2l0aCBzdG9yZSB2aWEgYSByZWR1eC1jb21wYXRpYmxlIG1pZGRsZXdhcmUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5ldHdvcmtNYW5hZ2VyIGltcGxlbWVudHMgTWFuYWdlciB7XG4gIHByb3RlY3RlZCBmZXRjaGVkOiB7IFtrOiBzdHJpbmddOiBQcm9taXNlPGFueT4gfSA9IHt9O1xuICBwcm90ZWN0ZWQgcmVzb2x2ZXJzOiB7IFtrOiBzdHJpbmddOiAodmFsdWU/OiBhbnkpID0+IHZvaWQgfSA9IHt9O1xuICBwcm90ZWN0ZWQgcmVqZWN0b3JzOiB7IFtrOiBzdHJpbmddOiAodmFsdWU/OiBhbnkpID0+IHZvaWQgfSA9IHt9O1xuICByZWFkb25seSBkYXRhRXhwaXJ5TGVuZ3RoOiBudW1iZXI7XG4gIHJlYWRvbmx5IGVycm9yRXhwaXJ5TGVuZ3RoOiBudW1iZXI7XG4gIGNvbnN0cnVjdG9yKGRhdGFFeHBpcnlMZW5ndGggPSA2MDAwMCwgZXJyb3JFeHBpcnlMZW5ndGggPSAxMDAwKSB7XG4gICAgdGhpcy5kYXRhRXhwaXJ5TGVuZ3RoID0gZGF0YUV4cGlyeUxlbmd0aDtcbiAgICB0aGlzLmVycm9yRXhwaXJ5TGVuZ3RoID0gZXJyb3JFeHBpcnlMZW5ndGg7XG4gIH1cblxuICAvKiogRW5zdXJlcyBhbGwgcHJvbWlzZXMgYXJlIGNvbXBsZXRlZCBieSByZWplY3RpbmcgcmVtYWluaW5nLiAqL1xuICBjbGVhbnVwKCkge1xuICAgIGZvciAoY29uc3QgayBpbiB0aGlzLnJlamVjdG9ycykge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0NsZWFuaW5nIHVwIE5ldHdvcmsgTWFuYWdlcicpO1xuICAgICAgZXJyb3IubmFtZSA9ICdDTEVBTlVQJztcbiAgICAgIHRoaXMucmVqZWN0b3JzW2tdKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKiogQ2xlYXIgcHJvbWlzZSBzdGF0ZSBmb3IgYSBnaXZlbiB1cmwgKi9cbiAgcHJvdGVjdGVkIGNsZWFyKHVybDogc3RyaW5nKSB7XG4gICAgZGVsZXRlIHRoaXMucmVzb2x2ZXJzW3VybF07XG4gICAgZGVsZXRlIHRoaXMucmVqZWN0b3JzW3VybF07XG4gICAgZGVsZXRlIHRoaXMuZmV0Y2hlZFt1cmxdO1xuICB9XG5cbiAgLyoqIENhbGxlZCB3aGVuIG1pZGRsZXdhcmUgaW50ZXJjZXB0cyAncmVzdC1ob29rcy9mZXRjaCcgYWN0aW9uLlxuICAgKlxuICAgKiBXaWxsIHRoZW4gc3RhcnQgYSBwcm9taXNlIGZvciBhIHVybCBhbmQgcG90ZW50aWFsbHkgc3RhcnQgdGhlIG5ldHdvcmtcbiAgICogZmV0Y2guXG4gICAqXG4gICAqIFVzZXMgdGhyb3R0bGUgb25seSB3aGVuIGluc3RydWN0ZWQgYnkgYWN0aW9uIG1ldGEuIFRoaXMgaXMgdmFsdWFibGVcbiAgICogZm9yIGVuc3VyZXMgbXV0YXRpb24gcmVxdWVzdHMgYWx3YXlzIGdvIHRocm91Z2guXG4gICAqL1xuICBwcm90ZWN0ZWQgaGFuZGxlRmV0Y2goYWN0aW9uOiBGZXRjaEFjdGlvbiwgZGlzcGF0Y2g6IERpc3BhdGNoPGFueT4pIHtcbiAgICBjb25zdCBmZXRjaCA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIGNvbnN0IHtcbiAgICAgIHNjaGVtYSxcbiAgICAgIHVybCxcbiAgICAgIHJlc3BvbnNlVHlwZSxcbiAgICAgIHRocm90dGxlLFxuICAgICAgcmVzb2x2ZSxcbiAgICAgIHVwZGF0ZXJzLFxuICAgICAgcmVqZWN0LFxuICAgICAgb3B0aW9ucyA9IHt9LFxuICAgIH0gPSBhY3Rpb24ubWV0YTtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhRXhwaXJ5TGVuZ3RoID0gdGhpcy5kYXRhRXhwaXJ5TGVuZ3RoLFxuICAgICAgZXJyb3JFeHBpcnlMZW5ndGggPSB0aGlzLmVycm9yRXhwaXJ5TGVuZ3RoLFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgZGVmZXJlZEZldGNoID0gKCkgPT5cbiAgICAgIGZldGNoKClcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICBjb25zdCBtZXRhOlxuICAgICAgICAgICAgfCBSZWNlaXZlQWN0aW9uWydtZXRhJ11cbiAgICAgICAgICAgIHwgUlBDQWN0aW9uWydtZXRhJ11cbiAgICAgICAgICAgIHwgUHVyZ2VBY3Rpb25bJ21ldGEnXSA9IHtcbiAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGRhdGU6IG5vdyxcbiAgICAgICAgICAgIGV4cGlyZXNBdDogbm93ICsgZGF0YUV4cGlyeUxlbmd0aCxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChbJ3Jlc3QtaG9va3MvcmVjZWl2ZScsICdyZXN0LWhvb2tzL3JwYyddLmluY2x1ZGVzKHJlc3BvbnNlVHlwZSkpIHtcbiAgICAgICAgICAgIG1ldGEudXBkYXRlcnMgPSB1cGRhdGVycztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogcmVzcG9uc2VUeXBlLFxuICAgICAgICAgICAgcGF5bG9hZDogZGF0YSxcbiAgICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdDTEVBTlVQJykgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogcmVzcG9uc2VUeXBlLFxuICAgICAgICAgICAgcGF5bG9hZDogZXJyb3IsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICBkYXRlOiBub3csXG4gICAgICAgICAgICAgIGV4cGlyZXNBdDogbm93ICsgZXJyb3JFeHBpcnlMZW5ndGgsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IHRydWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICh0aHJvdHRsZSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMudGhyb3R0bGUodXJsLCBkZWZlcmVkRmV0Y2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlID0gZGVmZXJlZEZldGNoKCk7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihkYXRhID0+IHJlc29sdmUoZGF0YSkpLmNhdGNoKGVycm9yID0+IHJlamVjdChlcnJvcikpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgLyoqIENhbGxlZCB3aGVuIG1pZGRsZXdhcmUgaW50ZXJjZXB0cyBhIHJlY2VpdmUgYWN0aW9uLlxuICAgKlxuICAgKiBXaWxsIHJlc29sdmUgdGhlIHByb21pc2UgYXNzb2NpYXRlZCB3aXRoIHJlY2VpdmUgdXJsLlxuICAgKi9cbiAgcHJvdGVjdGVkIGhhbmRsZVJlY2VpdmUoYWN0aW9uOiBSZWNlaXZlQWN0aW9uKSB7XG4gICAgLy8gdGhpcyBjYW4gc3RpbGwgdHVybiBvdXQgdG8gYmUgdW50cnVlIHNpbmNlIHRoaXMgaXMgYXN5bmNcbiAgICBpZiAoYWN0aW9uLm1ldGEudXJsIGluIHRoaXMuZmV0Y2hlZCkge1xuICAgICAgbGV0IHByb21pc2VIYW5kbGVyOiAodmFsdWU/OiBhbnkpID0+IHZvaWQ7XG4gICAgICBpZiAoYWN0aW9uLmVycm9yKSB7XG4gICAgICAgIHByb21pc2VIYW5kbGVyID0gdGhpcy5yZWplY3RvcnNbYWN0aW9uLm1ldGEudXJsXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VIYW5kbGVyID0gdGhpcy5yZXNvbHZlcnNbYWN0aW9uLm1ldGEudXJsXTtcbiAgICAgIH1cbiAgICAgIHByb21pc2VIYW5kbGVyKGFjdGlvbi5wYXlsb2FkKTtcbiAgICAgIC8vIHNpbmNlIHdlJ3JlIHJlc29sdmVkIHdlIG5vIGxvbmdlciBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgdGhpcyBwcm9taXNlXG4gICAgICB0aGlzLmNsZWFyKGFjdGlvbi5tZXRhLnVybCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEF0dGFjaGVzIE5ldHdvcmtNYW5hZ2VyIHRvIHN0b3JlXG4gICAqXG4gICAqIEludGVyY2VwdHMgJ3Jlc3QtaG9va3MvZmV0Y2gnIGFjdGlvbnMgdG8gc3RhcnQgcmVxdWVzdHMuXG4gICAqXG4gICAqIFJlc29sdmUvcmVqZWN0cyBhIHJlcXVlc3Qgd2hlbiBtYXRjaGluZyAncmVzdC1ob29rcy9yZWNlaXZlJyBldmVudFxuICAgKiBpcyBzZWVuLlxuICAgKi9cbiAgZ2V0TWlkZGxld2FyZSA9IG1lbW9pemUoZnVuY3Rpb248VCBleHRlbmRzIE5ldHdvcmtNYW5hZ2VyPih0aGlzOiBUKSB7XG4gICAgcmV0dXJuIDxSIGV4dGVuZHMgUmVhY3QuUmVkdWNlcjxhbnksIGFueT4+KHtcbiAgICAgIGRpc3BhdGNoLFxuICAgIH06IE1pZGRsZXdhcmVBUEk8Uj4pID0+IHtcbiAgICAgIHJldHVybiAobmV4dDogRGlzcGF0Y2g8Uj4pID0+IChcbiAgICAgICAgYWN0aW9uOiBSZWFjdC5SZWR1Y2VyQWN0aW9uPFI+LFxuICAgICAgKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdyZXN0LWhvb2tzL2ZldGNoJzpcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRmV0Y2goYWN0aW9uLCBkaXNwYXRjaCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgY2FzZSAncmVzdC1ob29rcy9wdXJnZSc6XG4gICAgICAgICAgY2FzZSAncmVzdC1ob29rcy9ycGMnOlxuICAgICAgICAgIGNhc2UgJ3Jlc3QtaG9va3MvcmVjZWl2ZSc6XG4gICAgICAgICAgICAvLyBvbmx5IHJlY2VpdmUgYWZ0ZXIgbmV3IHN0YXRlIGlzIGNvbXB1dGVkXG4gICAgICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoYWN0aW9uLm1ldGEudXJsIGluIHRoaXMuZmV0Y2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVjZWl2ZShhY3Rpb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjYXNlICdyZXN0LWhvb2tzL3Jlc2V0JzpcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9KTtcblxuICAvKiogRW5zdXJlcyBvbmx5IG9uZSByZXF1ZXN0IGZvciBhIGdpdmVuIHVybCBpcyBpbiBmbGlnaHQgYXQgYW55IHRpbWVcbiAgICpcbiAgICogVXNlcyB1cmwgYXMga2V5IHRvIGVpdGhlciByZXRyaWV2ZSBpbi1mbGlnaHQgcHJvbWlzZSwgb3IgaWYgbm90XG4gICAqIGNyZWF0ZSBhIG5ldyBwcm9taXNlIGFuZCBjYWxsIGZldGNoLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgbmV3IHByb21pc2UgaXMgbm90IGFjdHVhbGx5IHRpZWQgdG8gZmV0Y2ggYXQgYWxsLFxuICAgKiBidXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgZXhwZWN0ZWQgJ3JlY2lldmUnIGFjdGlvbiBpcyBwcm9jZXNzZWQuXG4gICAqIFRoaXMgZW5zdXJlcyBwcm9taXNlcyBhcmUgcmVzb2x2ZWQgb25seSBvbmNlIHRoZWlyIGRhdGEgaXMgcHJvY2Vzc2VkXG4gICAqIGJ5IHRoZSByZWR1Y2VyLlxuICAgKi9cbiAgcHJvdGVjdGVkIHRocm90dGxlKHVybDogc3RyaW5nLCBmZXRjaDogKCkgPT4gUHJvbWlzZTxhbnk+KSB7XG4gICAgLy8gd2UncmUgYWxyZWFkeSBmZXRjaGluZyBzbyByZXVzZSB0aGUgcHJvbWlzZVxuICAgIGlmICh1cmwgaW4gdGhpcy5mZXRjaGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaGVkW3VybF07XG4gICAgfVxuXG4gICAgdGhpcy5mZXRjaGVkW3VybF0gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmVyc1t1cmxdID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMucmVqZWN0b3JzW3VybF0gPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICAvLyBzaW5jZSBvdXIgcmVhbCBwcm9taXNlIGlzIHJlc29sdmVkIHZpYSB0aGUgd3JhcFJlZHVjZXIoKSxcbiAgICAvLyB3ZSBzaG91bGQganVzdCBzdG9wIGFsbCBlcnJvcnMgaGVyZS5cbiAgICAvLyBUT0RPOiBkZWNvdXBsZSB0aGlzIGZyb20gdXNlRmV0Y2hlcigpICh0aGF0J3Mgd2hhdCdzIGRpc3BhdGNoaW5nIHRoZSBlcnJvciB0aGUgcmVzb2x2ZXMgaW4gaGVyZSlcbiAgICBSSUMoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGZldGNoKCkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICB9LFxuICAgICAgeyB0aW1lb3V0OiA1MDAgfSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hlZFt1cmxdO1xuICB9XG59XG4iXX0=