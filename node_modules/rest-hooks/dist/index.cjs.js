'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var request = _interopDefault(require('superagent'));
var _memoize = _interopDefault(require('lodash/memoize'));
var React = require('react');
var React__default = _interopDefault(React);

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

/**
 * Helpers to enable Immutable compatibility *without* bringing in
 * the 'immutable' package as a dependency.
 */

/**
 * Check if an object is immutable by checking if it has a key specific
 * to the immutable library.
 *
 * @param  {any} object
 * @return {bool}
 */
function isImmutable(object) {
  return !!(object && typeof object.hasOwnProperty === 'function' && (object.hasOwnProperty('__ownerID') || // Immutable.Map
  object._map && object._map.hasOwnProperty('__ownerID'))); // Immutable.Record
}
/**
 * Denormalize an immutable entity.
 *
 * @param  {Schema} schema
 * @param  {Immutable.Map|Immutable.Record} input
 * @param  {function} unvisit
 * @param  {function} getDenormalizedEntity
 * @return {Immutable.Map|Immutable.Record}
 */

function denormalizeImmutable(schema, input, unvisit) {
  var found = true;
  return [Object.keys(schema).reduce(function (object, key) {
    // Immutable maps cast keys to strings on write so we need to ensure
    // we're accessing them using string keys.
    var stringKey = "" + key;

    var _unvisit = unvisit(object.get(stringKey), schema[stringKey]),
        item = _unvisit[0],
        foundItem = _unvisit[1];

    if (!foundItem) {
      found = false;
    }

    if (object.has(stringKey)) {
      return object.set(stringKey, item);
    } else {
      return object;
    }
  }, input), found];
}

var getDefaultGetId = function getDefaultGetId(idAttribute) {
  return function (input) {
    return isImmutable(input) ? input.get(idAttribute) : input[idAttribute];
  };
};

var EntitySchema =
/*#__PURE__*/
function () {
  function EntitySchema(key, definition, options) {
    if (definition === void 0) {
      definition = {};
    }

    if (options === void 0) {
      options = {};
    }

    if (!key || typeof key !== 'string') {
      throw new Error("Expected a string key for Entity, but found " + key + ".");
    }

    var _options = options,
        _options$idAttribute = _options.idAttribute,
        idAttribute = _options$idAttribute === void 0 ? 'id' : _options$idAttribute,
        _options$mergeStrateg = _options.mergeStrategy,
        mergeStrategy = _options$mergeStrateg === void 0 ? function (entityA, entityB) {
      return _objectSpread2({}, entityA, {}, entityB);
    } : _options$mergeStrateg,
        _options$processStrat = _options.processStrategy,
        processStrategy = _options$processStrat === void 0 ? function (input) {
      return _objectSpread2({}, input);
    } : _options$processStrat;
    this._key = key;
    this._getId = typeof idAttribute === 'function' ? idAttribute : getDefaultGetId(idAttribute);
    this._idAttribute = idAttribute;
    this._mergeStrategy = mergeStrategy;
    this._processStrategy = processStrategy;
    this.define(definition);
  }

  var _proto = EntitySchema.prototype;

  _proto.define = function define(definition) {
    this.schema = Object.keys(definition).reduce(function (entitySchema, key) {
      var _objectSpread2$1;

      var schema = definition[key];
      return _objectSpread2({}, entitySchema, (_objectSpread2$1 = {}, _objectSpread2$1[key] = schema, _objectSpread2$1));
    }, this.schema || {});
  };

  _proto.getId = function getId(input, parent, key) {
    return this._getId(input, parent, key);
  };

  _proto.merge = function merge(entityA, entityB) {
    return this._mergeStrategy(entityA, entityB);
  };

  _proto.normalize = function normalize(input, parent, key, visit, addEntity, visitedEntities) {
    var _this = this;

    var id = this.getId(input, parent, key);
    var entityType = this.key;

    if (!(entityType in visitedEntities)) {
      visitedEntities[entityType] = {};
    }

    if (!(id in visitedEntities[entityType])) {
      visitedEntities[entityType][id] = [];
    }

    if (visitedEntities[entityType][id].some(function (entity) {
      return entity === input;
    })) {
      return id;
    }

    visitedEntities[entityType][id].push(input);

    var processedEntity = this._processStrategy(input, parent, key);

    Object.keys(this.schema).forEach(function (key) {
      if (processedEntity.hasOwnProperty(key) && typeof processedEntity[key] === 'object') {
        var schema = _this.schema[key];
        processedEntity[key] = visit(processedEntity[key], processedEntity, key, schema, addEntity, visitedEntities);
      }
    });
    addEntity(this, processedEntity, input, parent, key);
    return id;
  };

  _proto.denormalize = function denormalize(entity, unvisit) {
    var _this2 = this;

    if (isImmutable(entity)) {
      return denormalizeImmutable(this.schema, entity, unvisit);
    }

    var found = true;
    Object.keys(this.schema).forEach(function (key) {
      var schema = _this2.schema[key];

      var _unvisit = unvisit(entity[key], schema),
          value = _unvisit[0],
          foundItem = _unvisit[1];

      if (!foundItem) {
        found = false;
      }

      if (entity.hasOwnProperty(key)) {
        entity[key] = value;
      }
    });
    return [entity, found];
  };

  _createClass(EntitySchema, [{
    key: "key",
    get: function get() {
      return this._key;
    }
  }, {
    key: "idAttribute",
    get: function get() {
      return this._idAttribute;
    }
  }]);

  return EntitySchema;
}();

var PolymorphicSchema =
/*#__PURE__*/
function () {
  function PolymorphicSchema(definition, schemaAttribute) {
    if (schemaAttribute) {
      this._schemaAttribute = typeof schemaAttribute === 'string' ? function (input) {
        return input[schemaAttribute];
      } : schemaAttribute;
    }

    this.define(definition);
  }

  var _proto = PolymorphicSchema.prototype;

  _proto.define = function define(definition) {
    this.schema = definition;
  };

  _proto.getSchemaAttribute = function getSchemaAttribute(input, parent, key) {
    return !this.isSingleSchema && this._schemaAttribute(input, parent, key);
  };

  _proto.inferSchema = function inferSchema(input, parent, key) {
    if (this.isSingleSchema) {
      return this.schema;
    }

    var attr = this.getSchemaAttribute(input, parent, key);
    return this.schema[attr];
  };

  _proto.normalizeValue = function normalizeValue(value, parent, key, visit, addEntity, visitedEntities) {
    var schema = this.inferSchema(value, parent, key);

    if (!schema) {
      return value;
    }

    var normalizedValue = visit(value, parent, key, schema, addEntity, visitedEntities);
    return this.isSingleSchema || normalizedValue === undefined || normalizedValue === null ? normalizedValue : {
      id: normalizedValue,
      schema: this.getSchemaAttribute(value, parent, key)
    };
  };

  _proto.denormalizeValue = function denormalizeValue(value, unvisit) {
    var schemaKey = isImmutable(value) ? value.get('schema') : value.schema;

    if (!this.isSingleSchema && !schemaKey) {
      return [value, true];
    }

    var id = isImmutable(value) ? value.get('id') : value.id;
    var schema = this.isSingleSchema ? this.schema : this.schema[schemaKey];
    return unvisit(id || value, schema);
  };

  _createClass(PolymorphicSchema, [{
    key: "isSingleSchema",
    get: function get() {
      return !this._schemaAttribute;
    }
  }]);

  return PolymorphicSchema;
}();

var UnionSchema =
/*#__PURE__*/
function (_PolymorphicSchema) {
  _inheritsLoose(UnionSchema, _PolymorphicSchema);

  function UnionSchema(definition, schemaAttribute) {
    if (!schemaAttribute) {
      throw new Error('Expected option "schemaAttribute" not found on UnionSchema.');
    }

    return _PolymorphicSchema.call(this, definition, schemaAttribute) || this;
  }

  var _proto = UnionSchema.prototype;

  _proto.normalize = function normalize(input, parent, key, visit, addEntity, visitedEntities) {
    return this.normalizeValue(input, parent, key, visit, addEntity, visitedEntities);
  };

  _proto.denormalize = function denormalize(input, unvisit) {
    return this.denormalizeValue(input, unvisit);
  };

  return UnionSchema;
}(PolymorphicSchema);

var ValuesSchema =
/*#__PURE__*/
function (_PolymorphicSchema) {
  _inheritsLoose(ValuesSchema, _PolymorphicSchema);

  function ValuesSchema() {
    return _PolymorphicSchema.apply(this, arguments) || this;
  }

  var _proto = ValuesSchema.prototype;

  _proto.normalize = function normalize(input, parent, key, visit, addEntity, visitedEntities) {
    var _this = this;

    return Object.keys(input).reduce(function (output, key, index) {
      var _objectSpread2$1;

      var value = input[key];
      return value !== undefined && value !== null ? _objectSpread2({}, output, (_objectSpread2$1 = {}, _objectSpread2$1[key] = _this.normalizeValue(value, input, key, visit, addEntity, visitedEntities), _objectSpread2$1)) : output;
    }, {});
  };

  _proto.denormalize = function denormalize(input, unvisit) {
    var _this2 = this;

    var found = true;
    return [Object.keys(input).reduce(function (output, key) {
      var _objectSpread3;

      var entityOrId = input[key];

      var _this2$denormalizeVal = _this2.denormalizeValue(entityOrId, unvisit),
          value = _this2$denormalizeVal[0],
          foundItem = _this2$denormalizeVal[1];

      if (!foundItem) {
        found = false;
      }

      return _objectSpread2({}, output, (_objectSpread3 = {}, _objectSpread3[key] = value, _objectSpread3));
    }, {}), found];
  };

  return ValuesSchema;
}(PolymorphicSchema);

var validateSchema = function validateSchema(definition) {
  var isArray = Array.isArray(definition);

  if (isArray && definition.length > 1) {
    throw new Error("Expected schema definition to be a single schema, but found " + definition.length + ".");
  }

  return definition[0];
};

var getValues = function getValues(input) {
  return Array.isArray(input) ? input : Object.keys(input).map(function (key) {
    return input[key];
  });
};

var normalize = function normalize(schema, input, parent, key, visit, addEntity, visitedEntities) {
  schema = validateSchema(schema);
  var values = getValues(input); // Special case: Arrays pass *their* parent on to their children, since there
  // is not any special information that can be gathered from themselves directly

  return values.map(function (value, index) {
    return visit(value, parent, key, schema, addEntity, visitedEntities);
  });
};
var denormalize = function denormalize(schema, input, unvisit) {
  schema = validateSchema(schema);
  var found = true;

  if (input === undefined && schema) {
    var _unvisit = unvisit(undefined, schema);

    found = _unvisit[1];
  }

  return [input && input.map ? input.map(function (entityOrId) {
    return unvisit(entityOrId, schema);
  }).filter(function (_ref) {
    var foundItem = _ref[1];
    return foundItem;
  }).map(function (_ref2) {
    var value = _ref2[0];
    return value;
  }) : input, found];
};

var ArraySchema =
/*#__PURE__*/
function (_PolymorphicSchema) {
  _inheritsLoose(ArraySchema, _PolymorphicSchema);

  function ArraySchema() {
    return _PolymorphicSchema.apply(this, arguments) || this;
  }

  var _proto = ArraySchema.prototype;

  _proto.normalize = function normalize(input, parent, key, visit, addEntity, visitedEntities) {
    var _this = this;

    var values = getValues(input);
    return values.map(function (value, index) {
      return _this.normalizeValue(value, parent, key, visit, addEntity, visitedEntities);
    }).filter(function (value) {
      return value !== undefined && value !== null;
    });
  };

  _proto.denormalize = function denormalize(input, unvisit) {
    var _this2 = this;

    var found = true;

    if (input === undefined && this.schema) {
      var _unvisit2 = unvisit(undefined, this.schema);

      found = _unvisit2[1];
    }

    return [input && input.map ? input.map(function (entityOrId) {
      return _this2.denormalizeValue(entityOrId, unvisit);
    }).filter(function (_ref3) {
      var foundItem = _ref3[1];
      return foundItem;
    }).map(function (_ref4) {
      var value = _ref4[0];
      return value;
    }) : input, found];
  };

  return ArraySchema;
}(PolymorphicSchema);

var _normalize = function normalize(schema, input, parent, key, visit, addEntity, visitedEntities) {
  var object = _objectSpread2({}, input);

  Object.keys(schema).forEach(function (key) {
    var localSchema = schema[key];
    var value = visit(input[key], input, key, localSchema, addEntity, visitedEntities);

    if (value === undefined || value === null) {
      delete object[key];
    } else {
      object[key] = value;
    }
  });
  return object;
};

var _denormalize = function denormalize(schema, input, unvisit) {
  if (isImmutable(input)) {
    return denormalizeImmutable(schema, input, unvisit);
  }

  var object = _objectSpread2({}, input);

  var found = true;
  Object.keys(schema).forEach(function (key) {
    var _unvisit = unvisit(object[key], schema[key]),
        item = _unvisit[0],
        foundItem = _unvisit[1];

    if (object[key] != null) {
      object[key] = item;
    }

    if (!foundItem) {
      found = false;
    }
  });
  return [object, found];
};

var ObjectSchema =
/*#__PURE__*/
function () {
  function ObjectSchema(definition) {
    this.define(definition);
  }

  var _proto = ObjectSchema.prototype;

  _proto.define = function define(definition) {
    this.schema = Object.keys(definition).reduce(function (entitySchema, key) {
      var _objectSpread2$1;

      var schema = definition[key];
      return _objectSpread2({}, entitySchema, (_objectSpread2$1 = {}, _objectSpread2$1[key] = schema, _objectSpread2$1));
    }, this.schema || {});
  };

  _proto.normalize = function normalize() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _normalize.apply(void 0, [this.schema].concat(args));
  };

  _proto.denormalize = function denormalize() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return _denormalize.apply(void 0, [this.schema].concat(args));
  };

  return ObjectSchema;
}();

var visit = function visit(value, parent, key, schema, addEntity, visitedEntities) {
  if (typeof value !== 'object' || !value) {
    return value;
  }

  if (typeof schema === 'object' && (!schema.normalize || typeof schema.normalize !== 'function')) {
    var method = Array.isArray(schema) ? normalize : _normalize;
    return method(schema, value, parent, key, visit, addEntity, visitedEntities);
  }

  return schema.normalize(value, parent, key, visit, addEntity, visitedEntities);
};

var addEntities = function addEntities(entities) {
  return function (schema, processedEntity, value, parent, key) {
    var schemaKey = schema.key;
    var id = schema.getId(value, parent, key);

    if (!(schemaKey in entities)) {
      entities[schemaKey] = {};
    }

    var existingEntity = entities[schemaKey][id];

    if (existingEntity) {
      entities[schemaKey][id] = schema.merge(existingEntity, processedEntity);
    } else {
      entities[schemaKey][id] = processedEntity;
    }
  };
};

var schema = {
  Array: ArraySchema,
  Entity: EntitySchema,
  Object: ObjectSchema,
  Union: UnionSchema,
  Values: ValuesSchema
};
var normalize$1 = function normalize(input, schema) {
  if (!input || typeof input !== 'object') {
    throw new Error("Unexpected input given to normalize. Expected type to be \"object\", found \"" + (input === null ? 'null' : typeof input) + "\".");
  }

  var entities = {};
  var addEntity = addEntities(entities);
  var visitedEntities = {};
  var result = visit(input, input, null, schema, addEntity, visitedEntities);
  return {
    entities: entities,
    result: result
  };
};

var unvisitEntity = function unvisitEntity(id, schema, unvisit, getEntity, cache) {
  var entity = getEntity(id, schema);

  if (typeof entity !== 'object' || entity === null) {
    return [entity, false];
  }

  if (!cache[schema.key]) {
    cache[schema.key] = {};
  }

  var found = true;

  if (!cache[schema.key][id]) {
    // Ensure we don't mutate it non-immutable objects
    var entityCopy = isImmutable(entity) ? entity : _objectSpread2({}, entity); // Need to set this first so that if it is referenced further within the
    // denormalization the reference will already exist.

    cache[schema.key][id] = entityCopy;

    var _schema$denormalize = schema.denormalize(entityCopy, unvisit);

    cache[schema.key][id] = _schema$denormalize[0];
    found = _schema$denormalize[1];
  }

  return [cache[schema.key][id], found];
};

var getUnvisit = function getUnvisit(entities) {
  var cache = {};
  var getEntity = getEntities(entities);
  return function unvisit(input, schema) {
    if (typeof schema === 'object' && (!schema.denormalize || typeof schema.denormalize !== 'function')) {
      var method = Array.isArray(schema) ? denormalize : _denormalize;
      return method(schema, input, unvisit);
    } // null is considered intentional, thus always 'found' as true


    if (input === null) {
      return [input, true];
    }

    if (schema instanceof EntitySchema) {
      // unvisitEntity just can't handle undefined
      if (input === undefined) {
        return [input, false];
      }

      return unvisitEntity(input, schema, unvisit, getEntity, cache);
    }

    if (typeof schema.denormalize === 'function') {
      return schema.denormalize(input, unvisit);
    }

    return [input, true];
  };
};

var getEntities = function getEntities(entities) {
  var isImmutable$1 = isImmutable(entities);
  return function (entityOrId, schema) {
    var schemaKey = schema.key;

    if (typeof entityOrId === 'object') {
      return entityOrId;
    }

    if (isImmutable$1) {
      return entities.getIn([schemaKey, entityOrId.toString()]);
    }

    return entities[schemaKey] && entities[schemaKey][entityOrId];
  };
};

var denormalize$1 = function denormalize(input, schema, entities) {
  if (typeof input !== 'undefined') {
    return getUnvisit(entities)(input, schema);
  }

  return [undefined, false];
};

var DefinedMembersKey = Symbol('Defined Members');

/** Represents an entity to be retrieved from a server. Typically 1:1 with a url endpoint. */
var SimpleResource =
/*#__PURE__*/
function () {
  function SimpleResource() {
    _classCallCheck(this, SimpleResource);

    _defineProperty(this, "__url", void 0);
  }

  _createClass(SimpleResource, [{
    key: "url",

    /** URL to find this SimpleResource */
    get: function get() {
      if (this.__url !== undefined) return this.__url; // typescript thinks constructor is just a function

      var Static = this.constructor;
      return Static.url(this);
    }
  }], [{
    key: "fromJS",

    /** SimpleResource factory. Takes an object of properties to assign to SimpleResource. */
    value: function fromJS(props) {
      // we type guarded abstract case above, so ok to force typescript to allow constructor call
      var instance = new this(props);
      if (instance.pk === undefined) throw new Error('cannot construct on abstract types');
      Object.defineProperty(instance, DefinedMembersKey, {
        value: Object.keys(props),
        writable: false
      });
      Object.assign(instance, props); // to trick normalizr into thinking we're Immutable.js does it doesn't copy

      Object.defineProperty(instance, '__ownerID', {
        value: 1337,
        writable: false
      });
      return instance;
    }
    /** Creates new instance copying over defined values of arguments */

  }, {
    key: "merge",
    value: function merge(first, second) {
      var props = Object.assign({}, this.toObjectDefined(first), this.toObjectDefined(second));
      return this.fromJS(props);
    }
    /** Whether key is non-default */

  }, {
    key: "hasDefined",
    value: function hasDefined(instance, key) {
      return instance[DefinedMembersKey].includes(key);
    }
    /** Returns simple object with all the non-default members */

  }, {
    key: "toObjectDefined",
    value: function toObjectDefined(instance) {
      var defined = {};
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = instance[DefinedMembersKey][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var member = _step.value;
          defined[member] = instance[member];
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return defined;
    }
    /** Returns array of all keys that have values defined in instance */

  }, {
    key: "keysDefined",
    value: function keysDefined(instance) {
      return instance[DefinedMembersKey];
    }
  }, {
    key: "toString",
    value: function toString() {
      return "".concat(this.name, "::").concat(this.urlRoot);
    }
    /** Returns the globally unique identifier for this SimpleResource */

  }, {
    key: "getKey",
    value: function getKey() {
      return this.urlRoot;
    }
    /** A unique identifier for this SimpleResource */

  }, {
    key: "pk",
    value: function pk(params) {
      return this.prototype.pk.call(params);
    }
  }, {
    key: "url",

    /** Get the url for a SimpleResource
     *
     * Default implementation conforms to common REST patterns
     */
    value: function url(urlParams) {
      if (urlParams) {
        if (Object.prototype.hasOwnProperty.call(urlParams, 'url') && urlParams.url && typeof urlParams.url === 'string') {
          return urlParams.url;
        }

        if (this.pk(urlParams) !== null) {
          if (this.urlRoot.endsWith('/')) {
            return "".concat(this.urlRoot).concat(this.pk(urlParams));
          }

          return "".concat(this.urlRoot, "/").concat(this.pk(urlParams));
        }
      }

      return this.urlRoot;
    }
    /** Get the url for many SimpleResources
     *
     * Default implementation conforms to common REST patterns
     */

  }, {
    key: "listUrl",
    value: function listUrl(searchParams) {
      if (searchParams && Object.keys(searchParams).length) {
        var params = new URLSearchParams(searchParams);
        params.sort();
        return "".concat(this.urlRoot, "?").concat(params.toString());
      }

      return this.urlRoot;
    }
    /** Perform network request and resolve with json body */

  }, {
    key: "fetch",
    value: function fetch(method, url, body) {
      // typescript currently doesn't allow abstract static methods
      throw new Error('not implemented');
    }
    /** Get the entity schema defining  */

  }, {
    key: "getEntitySchema",
    value: function getEntitySchema() {
      return _getEntitySchema(this);
    }
    /** Get the request options for this SimpleResource  */

  }, {
    key: "getFetchOptions",
    value: function getFetchOptions() {
      return;
    } // TODO: memoize these so they can be referentially compared

    /** Shape to get a single entity */

  }, {
    key: "detailShape",
    value: function detailShape() {
      var _this = this;

      var getFetchKey = function getFetchKey(params) {
        return 'GET ' + _this.url(params);
      };

      var schema = this.getEntitySchema();
      var options = this.getFetchOptions();
      return {
        type: 'read',
        schema: schema,
        options: options,
        getFetchKey: getFetchKey,
        fetch: function fetch(params) {
          return _this.fetch('get', _this.url(params));
        }
      };
    }
    /** Shape to get a list of entities */

  }, {
    key: "listShape",
    value: function listShape() {
      var _this2 = this;

      var getFetchKey = function getFetchKey(params) {
        return 'GET ' + _this2.listUrl(params);
      };

      var schema = [this.getEntitySchema()];
      var options = this.getFetchOptions();
      return {
        type: 'read',
        schema: schema,
        options: options,
        getFetchKey: getFetchKey,
        fetch: function fetch(params) {
          return _this2.fetch('get', _this2.listUrl(params));
        }
      };
    }
    /** Shape to create a new entity (post) */

  }, {
    key: "createShape",
    value: function createShape() {
      var _this3 = this;

      var options = this.getFetchOptions();
      return {
        type: 'mutate',
        schema: this.getEntitySchema(),
        options: options,
        getFetchKey: function getFetchKey(params) {
          return 'POST ' + _this3.listUrl(params);
        },
        fetch: function fetch(params, body) {
          return _this3.fetch('post', _this3.listUrl(params), body);
        }
      };
    }
    /** Shape to update an existing entity (put) */

  }, {
    key: "updateShape",
    value: function updateShape() {
      var _this4 = this;

      var options = this.getFetchOptions();
      return {
        type: 'mutate',
        schema: this.getEntitySchema(),
        options: options,
        getFetchKey: function getFetchKey(params) {
          return 'PUT ' + _this4.url(params);
        },
        fetch: function fetch(params, body) {
          return _this4.fetch('put', _this4.url(params), body);
        }
      };
    }
    /** Shape to update a subset of fields of an existing entity (patch) */

  }, {
    key: "partialUpdateShape",
    value: function partialUpdateShape() {
      var _this5 = this;

      var options = this.getFetchOptions();
      return {
        type: 'mutate',
        schema: this.getEntitySchema(),
        //TODO: change merge strategy in case we want to handle partial returns
        options: options,
        getFetchKey: function getFetchKey(params) {
          return 'PATCH ' + _this5.url(params);
        },
        fetch: function fetch(params, body) {
          return _this5.fetch('patch', _this5.url(params), body);
        }
      };
    }
    /** Shape to delete an entity (delete) */

  }, {
    key: "deleteShape",
    value: function deleteShape() {
      var _this6 = this;

      var options = this.getFetchOptions();
      return {
        type: 'delete',
        schema: this.getEntitySchema(),
        options: options,
        getFetchKey: function getFetchKey(params) {
          return 'DELETE ' + _this6.url(params);
        },
        fetch: function fetch(params) {
          return _this6.fetch('delete', _this6.url(params));
        }
      };
    }
  }]);

  return SimpleResource;
}(); // We're only allowing this to get set for descendants but
// by default we want Typescript to treat it as readonly.


_defineProperty(SimpleResource, "urlRoot", void 0);
Object.defineProperty(SimpleResource.prototype, 'url', {
  set: function set(url) {
    this.__url = url;
  }
});

var _getEntitySchema = _memoize(function (ResourceClass) {
  var e = new schema.Entity(ResourceClass.getKey(), {}, {
    idAttribute: function idAttribute(value, parent, key) {
      var id = ResourceClass.pk(value) || key;

      if (process.env.NODE_ENV !== 'production' && id === null) {
        throw new Error("Missing usable resource key when normalizing response.\n\nThis is likely due to a malformed response.\nTry inspecting the network response or fetch() return value.\n");
      }

      return id.toString();
    },
    processStrategy: function processStrategy(value) {
      return ResourceClass.fromJS(value);
    },
    mergeStrategy: function mergeStrategy(a, b) {
      return a.constructor.merge(a, b);
    }
  }); // TODO: long term figure out a plan to actually denormalize

  e.denormalize = function denormalize(entity) {
    return [entity, true];
  };

  return e;
});

var ResourceError = "JSON expected but not returned from API";
/**
 * Represents an entity to be retrieved from a server.
 * Typically 1:1 with a url endpoint.
 */

var Resource =
/*#__PURE__*/
function (_SimpleResource) {
  _inherits(Resource, _SimpleResource);

  function Resource() {
    _classCallCheck(this, Resource);

    return _possibleConstructorReturn(this, _getPrototypeOf(Resource).apply(this, arguments));
  }

  _createClass(Resource, null, [{
    key: "fetch",

    /** A function to mutate all requests for fetch */

    /** Perform network request and resolve with json body */
    value: function fetch(method, url, body) {
      var req = request[method](url).on('error', function () {});
      if (this.fetchPlugin) req = req.use(this.fetchPlugin);
      if (body) req = req.send(body);
      return req.then(function (res) {
        if (isInvalidResponse(res)) {
          throw new Error(ResourceError);
        }

        return res.body;
      });
    }
  }]);

  return Resource;
}(SimpleResource);

_defineProperty(Resource, "fetchPlugin", void 0);
var isInvalidResponse = function isInvalidResponse(res) {
  // Empty is only valid when no response is expect (204)
  var resEmptyIsExpected = res.text === '' && res.status === 204;
  var resBodyEmpty = Object.keys(res.body).length === 0;
  return !(res.type.includes('json') || resEmptyIsExpected) && resBodyEmpty;
};

function isDeleteShape(shape) {
  return shape.type === 'delete';
}
function isEntity(schema) {
  return schema.key !== undefined;
} // Legacy:

var SuperagentResource = Resource;

var RIC = typeof global.requestIdleCallback === 'function' ? global.requestIdleCallback : function (cb) {
  return global.setTimeout(cb, 0);
};

/** Handles all async network dispatches
 *
 * Dedupes concurrent requests by keeping track of all fetches in flight
 * and returning existing promises for requests already in flight.
 *
 * Interfaces with store via a redux-compatible middleware.
 */

var NetworkManager =
/*#__PURE__*/
function () {
  function NetworkManager() {
    var dataExpiryLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 60000;
    var errorExpiryLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;

    _classCallCheck(this, NetworkManager);

    _defineProperty(this, "fetched", {});

    _defineProperty(this, "resolvers", {});

    _defineProperty(this, "rejectors", {});

    _defineProperty(this, "dataExpiryLength", void 0);

    _defineProperty(this, "errorExpiryLength", void 0);

    _defineProperty(this, "getMiddleware", _memoize(function () {
      var _this = this;

      return function (_ref) {
        var dispatch = _ref.dispatch;
        return function (next) {
          return function (action) {
            switch (action.type) {
              case 'rest-hooks/fetch':
                _this.handleFetch(action, dispatch);

                return Promise.resolve();

              case 'rest-hooks/purge':
              case 'rest-hooks/rpc':
              case 'rest-hooks/receive':
                // only receive after new state is computed
                return next(action).then(function () {
                  if (action.meta.url in _this.fetched) {
                    _this.handleReceive(action);
                  }
                });

              case 'rest-hooks/reset':
                _this.cleanup();

                return next(action);

              default:
                return next(action);
            }
          };
        };
      };
    }));

    this.dataExpiryLength = dataExpiryLength;
    this.errorExpiryLength = errorExpiryLength;
  }
  /** Ensures all promises are completed by rejecting remaining. */


  _createClass(NetworkManager, [{
    key: "cleanup",
    value: function cleanup() {
      for (var _k in this.rejectors) {
        var error = new Error('Cleaning up Network Manager');
        error.name = 'CLEANUP';

        this.rejectors[_k](error);
      }
    }
    /** Clear promise state for a given url */

  }, {
    key: "clear",
    value: function clear(url) {
      delete this.resolvers[url];
      delete this.rejectors[url];
      delete this.fetched[url];
    }
    /** Called when middleware intercepts 'rest-hooks/fetch' action.
     *
     * Will then start a promise for a url and potentially start the network
     * fetch.
     *
     * Uses throttle only when instructed by action meta. This is valuable
     * for ensures mutation requests always go through.
     */

  }, {
    key: "handleFetch",
    value: function handleFetch(action, dispatch) {
      var fetch = action.payload;
      var _action$meta = action.meta,
          schema = _action$meta.schema,
          url = _action$meta.url,
          responseType = _action$meta.responseType,
          throttle = _action$meta.throttle,
          resolve = _action$meta.resolve,
          updaters = _action$meta.updaters,
          reject = _action$meta.reject,
          _action$meta$options = _action$meta.options,
          options = _action$meta$options === void 0 ? {} : _action$meta$options;
      var _options$dataExpiryLe = options.dataExpiryLength,
          dataExpiryLength = _options$dataExpiryLe === void 0 ? this.dataExpiryLength : _options$dataExpiryLe,
          _options$errorExpiryL = options.errorExpiryLength,
          errorExpiryLength = _options$errorExpiryL === void 0 ? this.errorExpiryLength : _options$errorExpiryL;

      var deferedFetch = function deferedFetch() {
        return fetch().then(function (data) {
          var now = Date.now();
          var meta = {
            schema: schema,
            url: url,
            date: now,
            expiresAt: now + dataExpiryLength
          };

          if (['rest-hooks/receive', 'rest-hooks/rpc'].includes(responseType)) {
            meta.updaters = updaters;
          }

          dispatch({
            type: responseType,
            payload: data,
            meta: meta
          });
          return data;
        })["catch"](function (error) {
          if (error.name === 'CLEANUP') return;
          var now = Date.now();
          dispatch({
            type: responseType,
            payload: error,
            meta: {
              schema: schema,
              url: url,
              date: now,
              expiresAt: now + errorExpiryLength
            },
            error: true
          });
          throw error;
        });
      };

      var promise;

      if (throttle) {
        promise = this.throttle(url, deferedFetch);
      } else {
        promise = deferedFetch();
      }

      promise.then(function (data) {
        return resolve(data);
      })["catch"](function (error) {
        return reject(error);
      });
      return promise;
    }
    /** Called when middleware intercepts a receive action.
     *
     * Will resolve the promise associated with receive url.
     */

  }, {
    key: "handleReceive",
    value: function handleReceive(action) {
      // this can still turn out to be untrue since this is async
      if (action.meta.url in this.fetched) {
        var promiseHandler;

        if (action.error) {
          promiseHandler = this.rejectors[action.meta.url];
        } else {
          promiseHandler = this.resolvers[action.meta.url];
        }

        promiseHandler(action.payload); // since we're resolved we no longer need to keep track of this promise

        this.clear(action.meta.url);
      }
    }
    /** Attaches NetworkManager to store
     *
     * Intercepts 'rest-hooks/fetch' actions to start requests.
     *
     * Resolve/rejects a request when matching 'rest-hooks/receive' event
     * is seen.
     */

  }, {
    key: "throttle",

    /** Ensures only one request for a given url is in flight at any time
     *
     * Uses url as key to either retrieve in-flight promise, or if not
     * create a new promise and call fetch.
     *
     * Note: The new promise is not actually tied to fetch at all,
     * but is resolved when the expected 'recieve' action is processed.
     * This ensures promises are resolved only once their data is processed
     * by the reducer.
     */
    value: function throttle(url, fetch) {
      var _this2 = this;

      // we're already fetching so reuse the promise
      if (url in this.fetched) {
        return this.fetched[url];
      }

      this.fetched[url] = new Promise(function (resolve, reject) {
        _this2.resolvers[url] = resolve;
        _this2.rejectors[url] = reject;
      }); // since our real promise is resolved via the wrapReducer(),
      // we should just stop all errors here.
      // TODO: decouple this from useFetcher() (that's what's dispatching the error the resolves in here)

      RIC(function () {
        fetch()["catch"](function () {
          return null;
        });
      }, {
        timeout: 500
      });
      return this.fetched[url];
    }
  }]);

  return NetworkManager;
}();

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

/**
 * PollingSubscription keeps a given resource updated by
 * dispatching a fetch at a rate equal to the minimum update
 * interval requested.
 */
var PollingSubscription =
/*#__PURE__*/
function () {
  function PollingSubscription(_ref, dispatch) {
    var url = _ref.url,
        schema = _ref.schema,
        fetch = _ref.fetch,
        frequency = _ref.frequency;

    _classCallCheck(this, PollingSubscription);

    _defineProperty(this, "schema", void 0);

    _defineProperty(this, "fetch", void 0);

    _defineProperty(this, "url", void 0);

    _defineProperty(this, "frequency", void 0);

    _defineProperty(this, "frequencyHistogram", new Map());

    _defineProperty(this, "dispatch", void 0);

    _defineProperty(this, "intervalId", void 0);

    _defineProperty(this, "lastIntervalId", void 0);

    if (frequency === undefined) throw new Error('frequency needed for polling subscription');
    this.schema = schema;
    this.fetch = fetch;
    this.frequency = frequency;
    this.url = url;
    this.frequencyHistogram.set(this.frequency, 1);
    this.dispatch = dispatch;
    this.run();
  }
  /** Subscribe to a frequency */


  _createClass(PollingSubscription, [{
    key: "add",
    value: function add(frequency) {
      if (frequency === undefined) return;

      if (this.frequencyHistogram.has(frequency)) {
        this.frequencyHistogram.set(frequency, this.frequencyHistogram.get(frequency) + 1);
      } else {
        this.frequencyHistogram.set(frequency, 1); // new min so restart service

        if (frequency < this.frequency) {
          this.frequency = frequency;
          this.run();
        }
      }
    }
    /** Unsubscribe from a frequency */

  }, {
    key: "remove",
    value: function remove(frequency) {
      if (frequency === undefined) return false;

      if (this.frequencyHistogram.has(frequency)) {
        this.frequencyHistogram.set(frequency, this.frequencyHistogram.get(frequency) - 1);

        if (this.frequencyHistogram.get(frequency) < 1) {
          this.frequencyHistogram["delete"](frequency); // nothing subscribed to this anymore...it is invalid

          if (this.frequencyHistogram.size === 0) {
            this.cleanup();
            return true;
          } // this was the min, so find the next size


          if (frequency <= this.frequency) {
            this.frequency = Math.min.apply(Math, _toConsumableArray(this.frequencyHistogram.keys()));
            this.run();
          }
        }
      } else if (process.env.NODE_ENV !== 'production') {
        console.error("Mismatched remove: ".concat(frequency, " is not subscribed for ").concat(this.url));
      }

      return false;
    }
    /** Cleanup means clearing out background interval. */

  }, {
    key: "cleanup",
    value: function cleanup() {
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = undefined;
      }

      if (this.lastIntervalId) {
        clearInterval(this.lastIntervalId);
        this.lastIntervalId = undefined;
      }
    }
    /** Trigger request for latest resource */

  }, {
    key: "update",
    value: function update() {
      this.dispatch({
        type: 'rest-hooks/fetch',
        payload: this.fetch,
        meta: {
          schema: this.schema,
          url: this.url,
          responseType: 'rest-hooks/receive',
          throttle: true,
          options: {
            dataExpiryLength: this.frequency / 2,
            errorExpiryLength: this.frequency / 10
          },
          resolve: function resolve() {},
          reject: function reject() {}
        }
      });
    }
    /** Run polling process with current frequency
     *
     * Will clean up old poll interval on next run
     */

  }, {
    key: "run",
    value: function run() {
      var _this = this;

      this.lastIntervalId = this.intervalId;
      this.intervalId = setInterval(function () {
        // since we don't know how long into the last poll it was before resetting
        // we wait til the next fetch to clear old intervals
        if (_this.lastIntervalId) {
          clearInterval(_this.lastIntervalId);
          _this.lastIntervalId = undefined;
        }

        _this.update();
      }, this.frequency);
    }
  }]);

  return PollingSubscription;
}();

/** Handles subscription actions -> fetch or receive actions
 *
 * Constructor takes a SubscriptionConstructable class to control how
 * subscriptions are handled. (e.g., polling, websockets)
 */
var SubscriptionManager =
/*#__PURE__*/
function () {
  function SubscriptionManager(Subscription) {
    _classCallCheck(this, SubscriptionManager);

    _defineProperty(this, "subscriptions", {});

    _defineProperty(this, "Subscription", void 0);

    this.Subscription = Subscription;
    this.getMiddleware = _memoize(this.getMiddleware);
  }
  /** Ensures all subscriptions are cleaned up. */


  _createClass(SubscriptionManager, [{
    key: "cleanup",
    value: function cleanup() {
      for (var _url in this.subscriptions) {
        this.subscriptions[_url].cleanup();
      }
    }
    /** Called when middleware intercepts 'rest-hooks/subscribe' action.
     *
     */

  }, {
    key: "handleSubscribe",
    value: function handleSubscribe(action, dispatch) {
      var url = action.meta.url;

      if (url in this.subscriptions) {
        this.subscriptions[url].add(action.meta.frequency);
      } else {
        this.subscriptions[url] = new this.Subscription({
          schema: action.meta.schema,
          fetch: action.meta.fetch,
          frequency: action.meta.frequency,
          url: url
        }, dispatch);
      }
    }
    /** Called when middleware intercepts 'rest-hooks/unsubscribe' action.
     *
     */

  }, {
    key: "handleUnsubscribe",
    value: function handleUnsubscribe(action, dispatch) {
      var url = action.meta.url;

      if (url in this.subscriptions) {
        var empty = this.subscriptions[url].remove(action.meta.frequency);

        if (empty) {
          delete this.subscriptions[url];
        }
      } else if (process.env.NODE_ENV !== 'production') {
        console.error("Mismatched unsubscribe: ".concat(url, " is not subscribed"));
      }
    }
    /** Attaches Manager to store
     *
     * Intercepts 'rest-hooks/subscribe'/'rest-hooks/unsubscribe' to register resources that
     * need to be kept up to date.
     *
     * Will possibly dispatch 'rest-hooks/fetch' or 'rest-hooks/receive' to keep resources fresh
     *
     */

  }, {
    key: "getMiddleware",
    value: function getMiddleware() {
      var _this = this;

      return function (_ref) {
        var dispatch = _ref.dispatch;
        return function (next) {
          return function (action) {
            switch (action.type) {
              case 'rest-hooks/subscribe':
                _this.handleSubscribe(action, dispatch);

                return Promise.resolve();

              case 'rest-hooks/unsubscribe':
                _this.handleUnsubscribe(action, dispatch);

                return Promise.resolve();

              default:
                return next(action);
            }
          };
        };
      };
    }
  }]);

  return SubscriptionManager;
}();

// copied from https://github.com/TehShrike/is-mergeable-object
function isMergeableObject(value) {
  return isNonNullObject(value) && !isSpecial(value);
}

function isNonNullObject(value) {
  return !!value && _typeof(value) === 'object';
}

function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
} // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25


var canUseSymbol = typeof Symbol === 'function' && Symbol["for"];
/* istanbul ignore next */

var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol["for"]('react.element') : 0xeac7;

function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}

/**
 * Deep merge two objects or arrays. Uses static merge function if exists.
 */

function mergeDeepCopy(target, source) {
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  var Static = source && source.constructor;

  if (target && Static && isMergeable(Static)) {
    if (isMergeable(target.constructor)) {
      return Static.merge(target, source);
    } else {
      return source;
    }
  } else if (isMergeableObject(source)) {
    // target and source are mergeable
    if (isMergeableObject(target) && sourceAndTargetTypesMatch) {
      var destination = targetIsArray ? _toConsumableArray(target) : _objectSpread2({}, target);
      Object.keys(source).forEach(function (key) {
        destination[key] = mergeDeepCopy(destination[key], source[key]);
      });
      return destination; // not mergeable, but still need to clone source
    } else {
      return mergeDeepCopy(sourceIsArray ? [] : {}, source);
    }
  } else if (source === undefined) {
    return target;
  }

  return source;
}

function isMergeable(constructor) {
  return constructor && typeof constructor.merge === 'function';
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function applyUpdatersToResults(results, result, updaters) {
  if (!updaters) return results;
  return _objectSpread2({}, results, {}, Object.fromEntries(Object.entries(updaters).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        fetchKey = _ref2[0],
        updater = _ref2[1];

    return [fetchKey, updater(result, results[fetchKey])];
  })));
}

var initialState = {
  entities: {},
  results: {},
  meta: {}
};
function reducer(state, action) {
  if (!state) state = initialState;

  switch (action.type) {
    case 'rest-hooks/receive':
      {
        if (action.error) {
          return _objectSpread2({}, state, {
            meta: _objectSpread2({}, state.meta, _defineProperty({}, action.meta.url, {
              date: action.meta.date,
              error: action.payload,
              expiresAt: action.meta.expiresAt
            }))
          });
        }

        var _normalize = normalize$1(action.payload, action.meta.schema),
            result = _normalize.result,
            entities = _normalize.entities;

        var results = _objectSpread2({}, state.results, _defineProperty({}, action.meta.url, result));

        results = applyUpdatersToResults(results, result, action.meta.updaters);
        return {
          entities: mergeDeepCopy(state.entities, entities),
          results: results,
          meta: _objectSpread2({}, state.meta, _defineProperty({}, action.meta.url, {
            date: action.meta.date,
            expiresAt: action.meta.expiresAt
          }))
        };
      }

    case 'rest-hooks/rpc':
      {
        if (action.error) return state;

        var _normalize2 = normalize$1(action.payload, action.meta.schema),
            _entities = _normalize2.entities,
            _result = _normalize2.result;

        var _results = applyUpdatersToResults(state.results, _result, action.meta.updaters);

        return _objectSpread2({}, state, {
          entities: mergeDeepCopy(state.entities, _entities),
          results: _results
        });
      }

    case 'rest-hooks/purge':
      {
        if (action.error) return state;
        var key = action.meta.schema.key;
        var pk = action.meta.url;

        var _entities2 = purgeEntity(state.entities, key, pk);

        return _objectSpread2({}, state, {
          entities: _entities2
        });
      }

    case 'rest-hooks/invalidate':
      return _objectSpread2({}, state, {
        meta: _objectSpread2({}, state.meta, _defineProperty({}, action.meta.url, _objectSpread2({}, state.meta[action.meta.url], {
          expiresAt: 0
        })))
      });

    case 'rest-hooks/reset':
      return initialState;

    default:
      // If 'fetch' action reaches the reducer there are no middlewares installed to handle it
      if (process.env.NODE_ENV !== 'production' && action.type === 'rest-hooks/fetch') {
        console.warn('Reducer recieved fetch action - you are likely missing the NetworkManager middleware');
        console.warn('See https://resthooks.io/docs/guides/redux#indextsx for hooking up redux');
      } // A reducer must always return a valid state.
      // Alternatively you can throw an error if an invalid action is dispatched.


      return state;
  }
}

// equivalent to entities.deleteIn(key, pk)
function purgeEntity(entities, key, pk) {
  var copy = _objectSpread2({}, entities);

  copy[key] = _objectSpread2({}, copy[key]);
  delete copy[key][pk];
  return copy;
}

function getEntityPath(schema$1) {
  if (isEntity(schema$1) || schema$1 instanceof schema.Array || Array.isArray(schema$1)) {
    return [];
  }

  var o = schema$1 instanceof schema.Object ? schema$1.schema : schema$1;

  for (var k in o) {
    if (!o[k]) continue;
    var path = getEntityPath(o[k]);

    if (path !== false) {
      // mutation is ok because there is only one path
      path.unshift(k);
      return path;
    }
  }

  return false;
}

/**
 * Build the result parameter to denormalize from schema alone.
 * Tries to compute the entity ids from params.
 */

function buildInferredResults(schema$1, params) {
  if (isEntity(schema$1)) {
    var id = schema$1.getId(params, undefined, ''); // Was unable to infer the entity's primary key from params

    if (id === undefined || id === '') return null;
    return id;
  }

  if (schema$1 instanceof schema.Array || Array.isArray(schema$1) || schema$1 instanceof schema.Values) {
    // array schemas should not be inferred because they're likely to be missing many members
    // Values cannot be inferred because they have aribtrary keys
    return null;
  }

  if (schema$1 instanceof schema.Union) {
    var discriminatedSchema = schema$1.inferSchema(params, undefined, ''); // Was unable to infer the entity's schema from params

    if (discriminatedSchema === undefined) return null;
    return {
      id: buildInferredResults(discriminatedSchema, params),
      schema: schema$1.getSchemaAttribute(params, parent, '')
    };
  }

  var o = schema$1 instanceof schema.Object ? schema$1.schema : schema$1;
  var resultObject = {};

  for (var k in o) {
    if (!isSchema(o[k])) {
      resultObject[k] = o[k];
    } else {
      var results = buildInferredResults(o[k], params);
      if (!results) return null;
      resultObject[k] = results;
    }
  }

  return resultObject;
}

function isSchema(candidate) {
  // TODO: improve detection
  return _typeof(candidate) === 'object' && candidate !== null;
}

/**
 * Selects the Denormalize form from `state` cache.
 *
 * If `result` is not found, will attempt to generate it naturally
 * using params and schema. This increases cache hit rate for many
 * detail shapes.
 */

function useDenormalizedLegacy(_ref, params, state) {
  var schema = _ref.schema,
      getFetchKey = _ref.getFetchKey;
  // Select from state
  var entities = state.entities;
  var cacheResults = params && state.results[getFetchKey(params)]; // We can grab entities without actual results if the params compute a primary key

  var results = React.useMemo(function () {
    if (!params) return null;
    if (cacheResults) return cacheResults; // in case we don't even have entities for a model yet, denormalize() will throw
    // entities[entitySchema.key] === undefined

    return buildInferredResults(schema, params); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [cacheResults, params && getFetchKey(params)]); // The final denormalize block

  return React.useMemo(function () {
    if (!entities || !params || !results) return null; // Warn users with bad configurations

    if (process.env.NODE_ENV !== 'production' && isEntity(schema)) {
      if (Array.isArray(results)) {
        throw new Error("url ".concat(getFetchKey(params), " has list results when single result is expected"));
      }

      if (_typeof(results) === 'object') {
        throw new Error("url ".concat(getFetchKey(params), " has object results when single result is expected"));
      }
    } // Select the actual results now


    var _denormalize = denormalize$1(results, schema, entities),
        _denormalize2 = _slicedToArray(_denormalize, 2),
        denormalized = _denormalize2[0],
        entitiesFound = _denormalize2[1];

    if (!entitiesFound && !cacheResults) return null;
    return denormalized; // TODO: would be nice to make this only recompute on the entity types that are in schema
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [entities, params && getFetchKey(params), results]);
}

function useSchemaSelect(_ref, params, state) {
  var schema = _ref.schema,
      getFetchKey = _ref.getFetchKey;
  var denormalized = useDenormalizedLegacy({
    schema: schema,
    getFetchKey: getFetchKey
  }, params, state); // eslint-disable-next-line react-hooks/exhaustive-deps

  var getItemsFromResults = React.useMemo(function () {
    return resultFinderFromSchema(schema);
  }, []);
  var output = React.useMemo(function () {
    return getItemsFromResults && denormalized ? getItemsFromResults(denormalized) : denormalized;
  }, [denormalized, getItemsFromResults]);
  if (output === undefined) return null;
  return output;
} // TODO: there should honestly be a way to use the pre-existing normalizr object
// to not even need this implementation

function resultFinderFromSchema(schema) {
  var path = getEntityPath(schema);
  if (path === false) throw new Error('Schema invalid - no path to entity found');
  if (path.length === 0) return null;
  return function (results) {
    var cur = results;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = path[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var p = _step.value;
        cur = cur[p];
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return cur;
  };
}

/**
 * Build the result parameter to denormalize from schema alone.
 * Tries to compute the entity ids from params.
 */

function buildInferredResults$1(schema$1, params) {
  if (isEntity(schema$1)) {
    if (!params) return undefined;
    var id = schema$1.getId(params, undefined, ''); // Was unable to infer the entity's primary key from params

    if (id === undefined || id === '') return undefined;
    return id;
  }

  if (schema$1 instanceof schema.Union) {
    var discriminatedSchema = schema$1.inferSchema(params, undefined, ''); // Was unable to infer the entity's schema from params

    if (discriminatedSchema === undefined) return undefined;
    return {
      id: buildInferredResults$1(discriminatedSchema, params),
      schema: schema$1.getSchemaAttribute(params, parent, '')
    };
  }

  if (schema$1 instanceof schema.Array || Array.isArray(schema$1)) {
    return undefined;
  }

  if (schema$1 instanceof schema.Values) {
    return {};
  }

  var o = schema$1 instanceof schema.Object ? schema$1.schema : schema$1;
  var resultObject = {};

  for (var k in o) {
    if (!isSchema$1(o[k])) {
      resultObject[k] = o[k];
    } else {
      resultObject[k] = buildInferredResults$1(o[k], params);
    }
  }

  return resultObject;
}

function isSchema$1(candidate) {
  // TODO: improve detection
  return _typeof(candidate) === 'object' && candidate !== null && candidate !== undefined;
}

/**
 * Selects the denormalized form from `state` cache.
 *
 * If `result` is not found, will attempt to generate it naturally
 * using params and schema. This increases cache hit rate for many
 * detail shapes.
 *
 * @returns [denormalizedValue, allEntitiesFound]
 */

function useDenormalized(_ref, params, state) {
  var schema = _ref.schema,
      getFetchKey = _ref.getFetchKey;
  // Select from state
  var entities = state.entities;
  var cacheResults = params && state.results[getFetchKey(params)]; // We can grab entities without actual results if the params compute a primary key

  var results = React.useMemo(function () {
    if (cacheResults) return cacheResults; // in case we don't even have entities for a model yet, denormalize() will throw
    // entities[entitySchema.key] === undefined

    return buildInferredResults$1(schema, params); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [cacheResults, params && getFetchKey(params)]); // The final denormalize block

  return React.useMemo(function () {
    // Warn users with bad configurations
    if (process.env.NODE_ENV !== 'production' && isEntity(schema)) {
      var paramEncoding = params ? getFetchKey(params) : '';

      if (Array.isArray(results)) {
        throw new Error("url ".concat(paramEncoding, " has list results when single result is expected"));
      }

      if (_typeof(results) === 'object') {
        throw new Error("url ".concat(paramEncoding, " has object results when single result is expected"));
      }
    } // second argument is false if any entities are missing


    var _denormalize = denormalize$1(results, schema, entities),
        _denormalize2 = _slicedToArray(_denormalize, 2),
        denormalized = _denormalize2[0],
        entitiesFound = _denormalize2[1];

    return [denormalized, entitiesFound]; // TODO: would be nice to make this only recompute on the entity types that are in schema
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [entities, params && getFetchKey(params), results]);
}

function selectMeta(state, fetchKey) {
  return state.meta[fetchKey];
}

var REACT_ELEMENT_TYPE$1;
function _createRawReactElement(type, props, key, children) {
  if (!REACT_ELEMENT_TYPE$1) {
    REACT_ELEMENT_TYPE$1 = typeof Symbol === "function" && Symbol["for"] && Symbol["for"]("react.element") || 0xeac7;
  }

  var defaultProps = type && type.defaultProps;
  var childrenLength = arguments.length - 3;

  if (!props && childrenLength !== 0) {
    props = {
      children: void 0
    };
  }

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = new Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 3];
    }

    props.children = childArray;
  }

  if (props && defaultProps) {
    for (var propName in defaultProps) {
      if (props[propName] === void 0) {
        props[propName] = defaultProps[propName];
      }
    }
  } else if (!props) {
    props = defaultProps || {};
  }

  return {
    $$typeof: REACT_ELEMENT_TYPE$1,
    type: type,
    key: key === undefined ? null : '' + key,
    ref: null,
    props: props,
    _owner: null
  };
}

function isNetworkError(error) {
  return Object.prototype.hasOwnProperty.call(error, 'status');
}

var NetworkErrorBoundary =
/*#__PURE__*/
function (_React$Component) {
  _inherits(NetworkErrorBoundary, _React$Component);

  function NetworkErrorBoundary() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, NetworkErrorBoundary);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(NetworkErrorBoundary)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "state", {});

    return _this;
  }

  _createClass(NetworkErrorBoundary, [{
    key: "render",
    value: function render() {
      if (!this.state.error) {
        return this.props.children;
      }

      return _createRawReactElement(this.props.fallbackComponent, {
        error: this.state.error
      });
    }
  }], [{
    key: "getDerivedStateFromError",
    value: function getDerivedStateFromError(error) {
      if (isNetworkError(error)) {
        return {
          error: error
        };
      }
    }
  }]);

  return NetworkErrorBoundary;
}(React__default.Component);

_defineProperty(NetworkErrorBoundary, "defaultProps", {
  fallbackComponent: function fallbackComponent(_ref) {
    var error = _ref.error;
    return _createRawReactElement("div", {}, void 0, error.status, " ", error.response && error.response.statusText);
  }
});

var StateContext = React__default.createContext(initialState);
var DispatchContext = React__default.createContext(function (value) {
  if (process.env.NODE_ENV !== 'production') {
    console.error('It appears you are trying to use Rest Hooks without a provider.\nFollow instructions: https://resthooks.io/docs/getting-started/installation#add-provider-at-top-level-component');

    if (process.env.NODE_ENV === 'test') {
      console.error('If you are trying to test: https://resthooks.io/docs/guides/unit-testing-hooks');
    }
  }

  return Promise.resolve();
});

function usePromisifiedDispatch(dispatch, state) {
  var dispatchPromiseRef = React.useRef(null);
  React.useEffect(function () {
    if (dispatchPromiseRef.current) {
      dispatchPromiseRef.current.resolve();
      dispatchPromiseRef.current = null;
    }
  }, [state]);
  return React.useCallback(function (action) {
    if (!dispatchPromiseRef.current) {
      dispatchPromiseRef.current = NewPromiseHolder();
    } // we use the promise before dispatch so we know it will be resolved
    // however that can also make the ref clear, so we need to make sure we have to promise before
    // dispatching so we can return it even if the ref changes.


    var promise = dispatchPromiseRef.current.promise;
    dispatch(action);
    return promise;
  }, [dispatch]);
}

function NewPromiseHolder() {
  // any so we can build it
  var promiseHolder = {};
  promiseHolder.promise = new Promise(function (resolve) {
    promiseHolder.resolve = resolve;
  });
  return promiseHolder;
}

/** Redux-middleware compatible integration for useReducer() */

function createEnhancedReducerHook() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  var useEnhancedReducer = function useEnhancedReducer(reducer, startingState) {
    var stateRef = React.useRef(startingState);

    var _useReducer = React.useReducer(reducer, startingState),
        _useReducer2 = _slicedToArray(_useReducer, 2),
        state = _useReducer2[0],
        realDispatch = _useReducer2[1];

    React.useEffect(function () {
      stateRef.current = state;
    }, [state]);
    var dispatchWithPromise = usePromisifiedDispatch(realDispatch, state);
    var outerDispatch = React.useMemo(function () {
      var _dispatch = function dispatch() {
        throw new Error("Dispatching while constructing your middleware is not allowed. " + "Other middleware would not be applied to this dispatch.");
      }; // closure here around dispatch allows us to change it after middleware is constructed


      var middlewareAPI = {
        getState: function getState() {
          return stateRef.current;
        },
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose(chain)(dispatchWithPromise);
      return _dispatch;
    }, [dispatchWithPromise]);
    return [state, outerDispatch];
  };

  return useEnhancedReducer;
}

var compose = function compose(fns) {
  return function (initial) {
    return fns.reduceRight(function (v, f) {
      return f(v);
    }, initial);
  };
};

/** Controller managing state of the REST cache and coordinating network requests. */
function CacheProvider(_ref) {
  var children = _ref.children,
      managers = _ref.managers,
      initialState = _ref.initialState;
  var useEnhancedReducer = createEnhancedReducerHook.apply(void 0, _toConsumableArray(managers.map(function (manager) {
    return manager.getMiddleware();
  })));

  var _useEnhancedReducer = useEnhancedReducer(reducer, initialState),
      _useEnhancedReducer2 = _slicedToArray(_useEnhancedReducer, 2),
      state = _useEnhancedReducer2[0],
      dispatch = _useEnhancedReducer2[1]; // if we change out the manager we need to make sure it has no hanging async


  React.useEffect(function () {
    return function () {
      for (var i = 0; i < managers.length; ++i) {
        managers[i].cleanup();
      }
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, managers);
  return _createRawReactElement(DispatchContext.Provider, {
    value: dispatch
  }, void 0, _createRawReactElement(StateContext.Provider, {
    value: state
  }, void 0, children));
}
CacheProvider.defaultProps = {
  managers: [new NetworkManager(), new SubscriptionManager(PollingSubscription)],
  initialState: initialState
};

function ExternalCacheProvider(_ref) {
  var children = _ref.children,
      store = _ref.store,
      selector = _ref.selector;

  var _useState = React.useState(function () {
    return selector(store.getState());
  }),
      _useState2 = _slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  React.useEffect(function () {
    var unsubscribe = store.subscribe(function () {
      setState(selector(store.getState()));
    });
    return unsubscribe; // we don't care to recompute if they change selector - only when store updates
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [store]);
  var dispatch = usePromisifiedDispatch(store.dispatch, state);
  return _createRawReactElement(DispatchContext.Provider, {
    value: dispatch
  }, void 0, _createRawReactElement(StateContext.Provider, {
    value: state
  }, void 0, children));
}

var PromiseifyMiddleware = function PromiseifyMiddleware(_) {
  return function (next) {
    return function (action) {
      next(action);
      return Promise.resolve();
    };
  };
};

var SHAPE_TYPE_TO_RESPONSE_TYPE = {
  read: 'rest-hooks/receive',
  mutate: 'rest-hooks/rpc',
  "delete": 'rest-hooks/purge'
};

/** Build an imperative dispatcher to issue network requests. */
function useFetcher(fetchShape) {
  var throttle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var dispatch = React.useContext(DispatchContext); // we just want the current values when we dispatch, so
  // box the shape in a ref to make react-hooks/exhaustive-deps happy

  var shapeRef = React.useRef(fetchShape);
  shapeRef.current = fetchShape;
  var fetchDispatcher = React.useCallback(function (params, body, updateParams) {
    var _shapeRef$current = shapeRef.current,
        fetch = _shapeRef$current.fetch,
        schema = _shapeRef$current.schema,
        type = _shapeRef$current.type,
        getFetchKey = _shapeRef$current.getFetchKey,
        options = _shapeRef$current.options;
    var responseType = SHAPE_TYPE_TO_RESPONSE_TYPE[type];
    var key = getFetchKey(params);
    var identifier = isDeleteShape(shapeRef.current) ? shapeRef.current.schema.getId(params) : key;
    var resolve = 0;
    var reject = 0;
    var promise = new Promise(function (a, b) {
      resolve = a;
      reject = b;
    });
    var meta = {
      schema: schema,
      responseType: responseType,
      url: identifier,
      throttle: throttle,
      options: options,
      resolve: resolve,
      reject: reject
    };

    if (updateParams) {
      meta.updaters = updateParams.reduce(function (accumulator, _ref) {
        var _ref2 = _slicedToArray(_ref, 3),
            toShape = _ref2[0],
            toParams = _ref2[1],
            updateFn = _ref2[2];

        return _objectSpread2(_defineProperty({}, toShape.getFetchKey(toParams), updateFn), accumulator);
      }, {});
    }

    dispatch({
      type: 'rest-hooks/fetch',
      payload: function payload() {
        return fetch(params, body);
      },
      meta: meta
    });
    return promise;
  }, [dispatch, throttle]); // any is due to the ternary that we don't want to deal with in our implementation

  return fetchDispatcher;
}

/** Access a resource if it is available. */

function useCache(fetchShape, params) {
  var state = React.useContext(StateContext);
  return useDenormalized(fetchShape, params, state)[0];
}

/** Access a resource if it is available. */

function useCacheLegacy(fetchShape, params) {
  var state = React.useContext(StateContext);
  return useSchemaSelect(fetchShape, params, state);
}

/** Gets meta for a url. */

function useMeta(_ref, params) {
  var getFetchKey = _ref.getFetchKey;
  var state = React.useContext(StateContext);
  var url = params ? getFetchKey(params) : '';
  return React.useMemo(function () {
    if (!url) return null;
    return selectMeta(state, url);
  }, [url, state]);
}

/** Returns whether the data at this url is fresh or stale */

function useExpiresAt(fetchShape, params) {
  var meta = useMeta(fetchShape, params);

  if (!meta) {
    return 0;
  }

  return meta.expiresAt;
}
/** Request a resource if it is not in cache. */


function useRetrieve(fetchShape, params) {
  var fetch = useFetcher(fetchShape, true);
  var expiresAt = useExpiresAt(fetchShape, params);
  return React.useMemo(function () {
    if (Date.now() <= expiresAt) return; // null params mean don't do anything

    if (!params) return;
    return fetch(params); // we need to check against serialized params, since params can change frequently
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [expiresAt, fetch, params && fetchShape.getFetchKey(params)]);
}

/** Access a resource or error if failed to get it */
function useError(fetchShape, params, cacheReady) {
  var meta = useMeta(fetchShape, params);
  if (!params) return;

  if (!cacheReady) {
    if (!meta) return;

    if (!meta.error) {
      // this means we probably deleted the entity found in this result
      var err = new Error("Resource not found in cache ".concat(params ? fetchShape.getFetchKey(params) : ''));
      err.status = 404;
      return err;
    } else {
      return meta.error;
    }
  }
}

/** If the invalidIfStale option is set we suspend if resource has expired */
function hasUsableData(cacheReady, fetchShape) {
  return !(fetchShape.options && fetchShape.options.invalidIfStale || !cacheReady);
}

/** single form resource */
function useOneResource(fetchShape, params) {
  var maybePromise = useRetrieve(fetchShape, params);
  var state = React.useContext(StateContext);

  var _useDenormalized = useDenormalized(fetchShape, params, state),
      _useDenormalized2 = _slicedToArray(_useDenormalized, 2),
      denormalized = _useDenormalized2[0],
      ready = _useDenormalized2[1];

  var error = useError(fetchShape, params, ready);
  if (!hasUsableData(ready, fetchShape) && maybePromise) throw maybePromise;
  if (error) throw error;
  return denormalized;
}
/** many form resource */


function useManyResources() {
  for (var _len = arguments.length, resourceList = new Array(_len), _key = 0; _key < _len; _key++) {
    resourceList[_key] = arguments[_key];
  }

  var state = React.useContext(StateContext);
  var denormalizedValues = resourceList.map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        fetchShape = _ref2[0],
        params = _ref2[1];

    return (// eslint-disable-next-line react-hooks/rules-of-hooks
      useDenormalized(fetchShape, params, state)
    );
  });
  var promises = resourceList.map(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        fetchShape = _ref4[0],
        params = _ref4[1];

    return (// eslint-disable-next-line react-hooks/rules-of-hooks
      useRetrieve(fetchShape, params)
    );
  }) // only wait on promises without results
  .map(function (p, i) {
    return !hasUsableData(denormalizedValues[i][1], resourceList[i][0]) && p;
  }); // throw first valid error

  for (var i = 0; i < resourceList.length; i++) {
    var _resourceList$i = _slicedToArray(resourceList[i], 2),
        _fetchShape = _resourceList$i[0],
        _params = _resourceList$i[1];

    var _denormalizedValues$i = _slicedToArray(denormalizedValues[i], 2),
        _ = _denormalizedValues$i[0],
        ready = _denormalizedValues$i[1]; // eslint-disable-next-line react-hooks/rules-of-hooks


    var error = useError(_fetchShape, _params, ready);
    if (error && !promises[i]) throw error;
  }

  var promise = React.useMemo(function () {
    var activePromises = promises.filter(function (p) {
      return p;
    });

    if (activePromises.length) {
      return Promise.all(activePromises);
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, promises);
  if (promise) throw promise;
  return denormalizedValues.map(function (_ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
        denormalized = _ref6[0];

    return denormalized;
  });
}

function useResource() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  // this conditional use of hooks is ok as long as the structure of the arguments don't change
  if (Array.isArray(args[0])) {
    // TODO: provide type guard function to detect this
    // eslint-disable-next-line react-hooks/rules-of-hooks
    return useManyResources.apply(void 0, _toConsumableArray(args));
  }

  args = args; // TODO: make return types match up with the branching logic we put in here.
  // eslint-disable-next-line react-hooks/rules-of-hooks

  return useOneResource(args[0], args[1]);
}

/** single form resource */
function useOneResource$1(fetchShape, params) {
  // maybePromise is undefined when data is stale or params is null
  var maybePromise = useRetrieve(fetchShape, params); // resource is null when it is not in cache or params is null

  var resource = useCacheLegacy(fetchShape, params);
  var error = useError(fetchShape, params, !!resource);
  if (!hasUsableData(!!resource, fetchShape) && maybePromise) throw maybePromise;
  if (error) throw error;
  return resource;
}
/** many form resource */


function useManyResources$1() {
  for (var _len = arguments.length, resourceList = new Array(_len), _key = 0; _key < _len; _key++) {
    resourceList[_key] = arguments[_key];
  }

  var resources = resourceList.map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        fetchShape = _ref2[0],
        params = _ref2[1];

    return (// eslint-disable-next-line react-hooks/rules-of-hooks
      useCacheLegacy(fetchShape, params)
    );
  });
  var promises = resourceList.map(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        fetchShape = _ref4[0],
        params = _ref4[1];

    return (// eslint-disable-next-line react-hooks/rules-of-hooks
      useRetrieve(fetchShape, params)
    );
  }) // only wait on promises without results
  .map(function (p, i) {
    return !hasUsableData(!!resources[i], resourceList[i][0]) && p;
  }); // throw first valid error

  for (var i = 0; i < resourceList.length; i++) {
    var _resourceList$i = _slicedToArray(resourceList[i], 2),
        _fetchShape = _resourceList$i[0],
        _params = _resourceList$i[1];

    var resource = resources[i]; // eslint-disable-next-line react-hooks/rules-of-hooks

    var error = useError(_fetchShape, _params, !!resource);
    if (error && !promises[i]) throw error;
  }

  var promise = React.useMemo(function () {
    var activePromises = promises.filter(function (p) {
      return p;
    });

    if (activePromises.length) {
      return Promise.all(activePromises);
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, promises);
  if (promise) throw promise;
  return resources;
}

function useResourceLegacy() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  // this conditional use of hooks is ok as long as the structure of the arguments don't change
  if (Array.isArray(args[0])) {
    // TODO: provide type guard function to detect this
    // eslint-disable-next-line react-hooks/rules-of-hooks
    return useManyResources$1.apply(void 0, _toConsumableArray(args));
  }

  args = args; // TODO: make return types match up with the branching logic we put in here.
  // eslint-disable-next-line react-hooks/rules-of-hooks

  return useOneResource$1(args[0], args[1]);
}

/** Keeps a resource fresh by subscribing to updates. */
function useSubscription(fetchShape, params) {
  var dispatch = React.useContext(DispatchContext);
  /*
  we just want the current values when we dispatch, so
  box the shape in a ref to make react-hooks/exhaustive-deps happy
   "Although useEffect is deferred until after the browser has painted, it’s guaranteed to fire before any new renders.
  React will always flush a previous render’s effects before starting a new update." - https://reactjs.org/docs/hooks-reference.html#useeffect
  */

  var shapeRef = React.useRef(fetchShape);
  shapeRef.current = fetchShape;
  React.useEffect(function () {
    if (!params) return;
    var _shapeRef$current = shapeRef.current,
        _fetch = _shapeRef$current.fetch,
        schema = _shapeRef$current.schema,
        getFetchKey = _shapeRef$current.getFetchKey,
        options = _shapeRef$current.options;
    var url = getFetchKey(params);
    dispatch({
      type: 'rest-hooks/subscribe',
      meta: {
        schema: schema,
        fetch: function fetch() {
          return _fetch(params);
        },
        url: url,
        frequency: options && options.pollFrequency
      }
    });
    return function () {
      dispatch({
        type: 'rest-hooks/unsubscribe',
        meta: {
          url: url,
          frequency: options && options.pollFrequency
        }
      });
    }; // serialize params
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dispatch, params && fetchShape.getFetchKey(params)]);
}

/** Invalidate a certain item within the cache */

function useInvalidator(fetchShape) {
  var dispatch = React.useContext(DispatchContext);
  var getFetchKeyRef = React.useRef(fetchShape.getFetchKey);
  getFetchKeyRef.current = fetchShape.getFetchKey;
  var invalidateDispatcher = React.useCallback(function (params) {
    if (!params) return;
    dispatch({
      type: 'rest-hooks/invalidate',
      meta: {
        url: getFetchKeyRef.current(params)
      }
    });
  }, [dispatch]);
  return invalidateDispatcher;
}

/** Returns a function to completely clear the cache of all entries */

function useResetter() {
  var dispatch = React.useContext(DispatchContext);
  var resetDispatcher = React.useCallback(function () {
    dispatch({
      type: 'rest-hooks/reset'
    });
  }, [dispatch]);
  return resetDispatcher;
}

/** Use selector to access part of state */
function useSelectionUnstable(select, params, paramSerializer) {
  var state = React.useContext(StateContext); // TODO: if this is identical to before and render was triggered by state update,
  // we should short-circuit entire rest of render
  // params must be serialized in check
  // eslint-disable-next-line react-hooks/exhaustive-deps

  var resource = React.useMemo(function () {
    return params && select(state, params);
  }, [// eslint-disable-next-line react-hooks/exhaustive-deps
  params && paramSerializer(params), select, state]);
  return resource;
}

var __INTERNAL__ = {
  initialState: initialState,
  StateContext: StateContext,
  DispatchContext: DispatchContext,
  RIC: RIC
};

exports.CacheProvider = CacheProvider;
exports.ExternalCacheProvider = ExternalCacheProvider;
exports.NetworkErrorBoundary = NetworkErrorBoundary;
exports.NetworkManager = NetworkManager;
exports.PollingSubscription = PollingSubscription;
exports.PromiseifyMiddleware = PromiseifyMiddleware;
exports.Resource = Resource;
exports.SimpleResource = SimpleResource;
exports.SubscriptionManager = SubscriptionManager;
exports.SuperagentResource = SuperagentResource;
exports.__INTERNAL__ = __INTERNAL__;
exports.reducer = reducer;
exports.schemas = schema;
exports.useCache = useCache;
exports.useCacheLegacy = useCacheLegacy;
exports.useDenormalized = useDenormalized;
exports.useError = useError;
exports.useFetcher = useFetcher;
exports.useInvalidator = useInvalidator;
exports.useMeta = useMeta;
exports.useResetter = useResetter;
exports.useResource = useResource;
exports.useResourceLegacy = useResourceLegacy;
exports.useRetrieve = useRetrieve;
exports.useSelectionUnstable = useSelectionUnstable;
exports.useSubscription = useSubscription;
